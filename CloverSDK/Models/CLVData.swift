/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */
 
import ObjectMapper

class CLVData {
  class Account {

    class Account: Mappable {
      var id: String?
      var name: String?
      var email: String?
      /// The primary merchant
      var primaryMerchant: CLVData.Base.Reference?
      /// The primary developer
      var primaryDeveloper: CLVData.Base.Reference?
      /// The primary reseller
      var primaryReseller: CLVData.Base.Reference?
      var isActive: Bool?
      var createdTime: NSDate?
      var claimedTime: NSDate?
      var lastLogin: Int?
      var inviteSent: Bool?
      var status: String?
      var merchants: [CLVData.Base.Reference]?
      var developers: [CLVData.Base.Reference]?
      var resellers: [CLVData.Base.Reference]?
      var csrfToken: String?
      var authFactors: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        email <- map["email"]
        primaryMerchant <- map["primaryMerchant"]
        primaryDeveloper <- map["primaryDeveloper"]
        primaryReseller <- map["primaryReseller"]
        isActive <- map["isActive"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        claimedTime <- (map["claimedTime"], CLVDateTransform())
        lastLogin <- map["lastLogin"]
        inviteSent <- map["inviteSent"]
        status <- map["status"]
        merchants <- map["merchants"]
        developers <- map["developers"]
        resellers <- map["resellers"]
        csrfToken <- map["csrfToken"]
        authFactors <- map["authFactors"]
      }
    }

    class AuthFactor: Mappable {
      /// Unique identifier
      var id: String?
      var type: CLVData.Account.AuthFactorType?
      var phoneNumber: String?
      var backupCodes: String?
      var totpKey: String?
      var createdTime: NSDate?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        type <- map["type"]
        phoneNumber <- map["phoneNumber"]
        backupCodes <- map["backupCodes"]
        totpKey <- map["totpKey"]
        createdTime <- (map["createdTime"], CLVDateTransform())
      }
    }

    enum AuthFactorType {
      case SMS
      case TOTP
      case BACKUP_CODES
    }
  }

  class Apps {

    class AndroidPermission: Mappable {
      /// Unique identifier
      var id: String?
      var permission: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        permission <- map["permission"]
      }
    }

    class AndroidVersion: Mappable {
      var id: String?
      /// Creation timestamp
      var createdAt: Int?
      /// Unique identifier
      var version: Int?
      var versionName: String?
      var approved: Bool?
      var hash: String?
      var deviceInstallCount: Int?
      var hashOriginal: String?
      var approvalStatus: CLVData.Base.ApprovalStatus?
      /// VirusTotal scan status
      var scanStatus: CLVData.Apps.ScanStatus?
      /// VirusTotal scan_id field, which is the sha256 hash joined with the timestamp by a hyphen
      var scanId: String?
      /// The minSdkVersion attribute parsed from the AndroidManifest.xml
      var minSdkVersion: Int?
      /// The message digest algorithm used to digest the entries of the APK
      var digestAlg: String?
      /// Url to download the APK
      var apkUrl: String?
      /// List of android permissions
      var permissions: [String]?
      /// Reference to the app this Android version belongs to
      var app: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        createdAt <- map["createdAt"]
        version <- map["version"]
        versionName <- map["versionName"]
        approved <- map["approved"]
        hash <- map["hash"]
        deviceInstallCount <- map["deviceInstallCount"]
        hashOriginal <- map["hashOriginal"]
        approvalStatus <- map["approvalStatus"]
        scanStatus <- map["scanStatus"]
        scanId <- map["scanId"]
        minSdkVersion <- map["minSdkVersion"]
        digestAlg <- map["digestAlg"]
        apkUrl <- map["apkUrl"]
        permissions <- map["permissions"]
        app <- map["app"]
      }
    }

    class App: Mappable {
      var id: String?
      /// Name of the app
      var name: String?
      var published: Bool?
      var developer: CLVData.Developer.Developer?
      /// Only available when app is installed to a merchant
      var merchant: CLVData.Merchant.Merchant?
      /// App Description
      var description: String?
      /// Short tagline for the app
      var tagline: String?
      /// URL for embedded video
      var videoUrl: String?
      /// Activation url for redirecting users after app installation.
      var activationUrl: String?
      /// Site url for oauth redirect and web app launch from appmarket.
      var siteUrl: String?
      /// Default oauth response type.
      var defaultResponseType: CLVData.Apps.OAuthResponseType?
      var appDomain: String?
      var androidVersion: CLVData.Apps.AndroidVersion?
      var packageName: String?
      var approved: Bool?
      var systemApp: Bool?
      var hidden: Bool?
      var filenameIcon: String?
      /// URL to the icon of the app. Generated from filenameIcon.
      var filenameIconSmall: String?
      /// URL to the icon of the app. Generated from filenameIcon.
      var filenameIconLarge: String?
      var installCount: Int?
      var sortOrder: Int?
      var permissionMerchantRead: Bool?
      var permissionMerchantWrite: Bool?
      var permissionCustomersRead: Bool?
      var permissionCustomersWrite: Bool?
      var permissionInventoryRead: Bool?
      var permissionInventoryWrite: Bool?
      var permissionOrdersRead: Bool?
      var permissionOrdersWrite: Bool?
      var permissionPaymentsRead: Bool?
      var permissionPaymentsWrite: Bool?
      var permissionEmployeesRead: Bool?
      var permissionEmployeesWrite: Bool?
      var permissionProcessCards: Bool?
      var permissionMidRead: Bool?
      var privacyPolicy: String?
      var eula: String?
      var supportPhone: String?
      var supportPhoneHours: String?
      var supportEmail: String?
      var supportUrl: String?
      var productType: CLVData.Apps.ProductType?
      var approvalStatus: CLVData.Base.ApprovalStatus?
      /// The app's android permissions
      var androidPermissions: [CLVData.Apps.AndroidPermission]?
      /// The app's screenshots
      var screenshots: [CLVData.Apps.Screenshot]?
      /// Available subscription options for this app
      var availableSubscriptions: [CLVData.Apps.AppSubscription]?
      /// Subscription options for this app
      var subscriptions: [CLVData.Apps.AppSubscription]?
      /// Available metered options for this app
      var availableMetereds: [CLVData.Apps.AppMetered]?
      /// Metered options for this app
      var metereds: [CLVData.Apps.AppMetered]?
      /// USB devices with which this app will communicate
      var usbDevices: [CLVData.Apps.AppUsbDevice]?
      /// DEPRECATED: This is now derived directly from billingStartTime (if future -> in trial; if past -> not in trial).  So it is now unnecessary.  Please update client code to not use it.
      var isMerchantInTrial: Bool?
      /// The merchant's current subscription for this app
      var currentSubscription: CLVData.Apps.AppSubscription?
      /// The app's web hook
      var webhook: CLVData.Apps.WebHook?
      /// The app's uploaded apks
      var androidVersions: [CLVData.Apps.AndroidVersion]?
      ///  Whether the app is installed 
      var installed: Bool?
      /// If the merchant has the app installed, this is the timestamp of when they installed the app.
      var installedTime: NSDate?
      /// If the app is a paid app, this tells whether it currently offers a 30 day free trial or not.  Developer can toggle at will.
      var paidAppHasTrial: Bool?
      /// Records the time that the approval status last changed
      var approvalStatusModifiedTime: NSDate?
      /// Text will print on printed receipts for this app
      var smartReceiptText: String?
      /// URL we will expose on printed and web receipts for this app
      var smartReceiptUrl: String?
      /// If the merchant has the app installed, this is the timestamp of when they start/started paying.  If the merchant doesn't have the app installed, this is the timestamp of when they would start paying.  In UTC.  Applies to paid apps only.
      var billingStartTime: NSDate?
      /// App's client secret for use with oauth
      var appSecret: String?
      /// App's associated business types
      var businessTypes: [CLVData.Apps.BusinessType]?
      /// App's supported device types
      var deviceTypes: [CLVData.Apps.DeviceType]?
      var modules: [CLVData.Merchant.Module]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        published <- map["published"]
        developer <- map["developer"]
        merchant <- map["merchant"]
        description <- map["description"]
        tagline <- map["tagline"]
        videoUrl <- map["videoUrl"]
        activationUrl <- map["activationUrl"]
        siteUrl <- map["siteUrl"]
        defaultResponseType <- map["defaultResponseType"]
        appDomain <- map["appDomain"]
        androidVersion <- map["androidVersion"]
        packageName <- map["packageName"]
        approved <- map["approved"]
        systemApp <- map["systemApp"]
        hidden <- map["hidden"]
        filenameIcon <- map["filenameIcon"]
        filenameIconSmall <- map["filenameIconSmall"]
        filenameIconLarge <- map["filenameIconLarge"]
        installCount <- map["installCount"]
        sortOrder <- map["sortOrder"]
        permissionMerchantRead <- map["permissionMerchantRead"]
        permissionMerchantWrite <- map["permissionMerchantWrite"]
        permissionCustomersRead <- map["permissionCustomersRead"]
        permissionCustomersWrite <- map["permissionCustomersWrite"]
        permissionInventoryRead <- map["permissionInventoryRead"]
        permissionInventoryWrite <- map["permissionInventoryWrite"]
        permissionOrdersRead <- map["permissionOrdersRead"]
        permissionOrdersWrite <- map["permissionOrdersWrite"]
        permissionPaymentsRead <- map["permissionPaymentsRead"]
        permissionPaymentsWrite <- map["permissionPaymentsWrite"]
        permissionEmployeesRead <- map["permissionEmployeesRead"]
        permissionEmployeesWrite <- map["permissionEmployeesWrite"]
        permissionProcessCards <- map["permissionProcessCards"]
        permissionMidRead <- map["permissionMidRead"]
        privacyPolicy <- map["privacyPolicy"]
        eula <- map["eula"]
        supportPhone <- map["supportPhone"]
        supportPhoneHours <- map["supportPhoneHours"]
        supportEmail <- map["supportEmail"]
        supportUrl <- map["supportUrl"]
        productType <- map["productType"]
        approvalStatus <- map["approvalStatus"]
        androidPermissions <- map["androidPermissions"]
        screenshots <- map["screenshots"]
        availableSubscriptions <- map["availableSubscriptions"]
        subscriptions <- map["subscriptions"]
        availableMetereds <- map["availableMetereds"]
        metereds <- map["metereds"]
        usbDevices <- map["usbDevices"]
        isMerchantInTrial <- map["isMerchantInTrial"]
        currentSubscription <- map["currentSubscription"]
        webhook <- map["webhook"]
        androidVersions <- map["androidVersions"]
        installed <- map["installed"]
        installedTime <- (map["installedTime"], CLVDateTransform())
        paidAppHasTrial <- map["paidAppHasTrial"]
        approvalStatusModifiedTime <- (map["approvalStatusModifiedTime"], CLVDateTransform())
        smartReceiptText <- map["smartReceiptText"]
        smartReceiptUrl <- map["smartReceiptUrl"]
        billingStartTime <- (map["billingStartTime"], CLVDateTransform())
        appSecret <- map["appSecret"]
        businessTypes <- map["businessTypes"]
        deviceTypes <- map["deviceTypes"]
        modules <- map["modules"]
      }
    }

    class AppBillingInfo: Mappable {
      /// Current subscription level of the merchant for this app
      var appSubscription: CLVData.Apps.AppSubscription?
      /// Returns true if the merchant is in trial for this app.  Only valid for paid apps that offer trials.  Trials apply to app metereds and app subscriptions
      var isInTrial: Bool?
      /// When the merchant's trial ends.  Only valid for paid apps that offer trials
      var billingStartTime: NSDate?
      /// Returns active if a merchant has a credit card on file, and if it's currently authorizing properly.  Returns lapsed if their card is absent or most recently declined
      var status: CLVData.Apps.MerchantBillingStatus?
      /// If the merchant's account is lapsed (i.e. merchant is behind on paying), the number of days since it lapsed
      var daysLapsed: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        appSubscription <- map["appSubscription"]
        isInTrial <- map["isInTrial"]
        billingStartTime <- (map["billingStartTime"], CLVDateTransform())
        status <- map["status"]
        daysLapsed <- map["daysLapsed"]
      }
    }

    class AppBundle: Mappable {
      /// Unique identifier
      var id: String?
      /// The name of the bundle
      var name: String?
      /// DEPRECATED: Instead use per country pricing in bundleCountries
      var price: Int?
      /// DEPRECATED: Instead use per country pricing in bundleCountries
      var pricePerDevice: Int?
      var includedApps: [CLVData.Base.Reference]?
      /// Bundle country options for this app bundle
      var bundleCountries: [CLVData.Apps.AppBundleCountry]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        price <- map["price"]
        pricePerDevice <- map["pricePerDevice"]
        includedApps <- map["includedApps"]
        bundleCountries <- map["bundleCountries"]
      }
    }

    class AppBundleCountry: Mappable {
      /// Unique identifier
      var id: String?
      var price: Int?
      var pricePerDevice: Int?
      /// The country of the app bundle country
      var country: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        price <- map["price"]
        pricePerDevice <- map["pricePerDevice"]
        country <- map["country"]
      }
    }

    class AppMetered: Mappable {
      /// Unique identifier
      var id: String?
      /// DEPRECATED: App metered amount. Instead use per country pricing in meteredCountries
      var amount: Int?
      /// DEPRECATED: App metered action. Instead use per country pricing in meteredCountries
      var action: String?
      /// DEPRECATED: App metered active status. Instead use per country pricing in meteredCountries
      var active: Bool?
      /// Metered country options for this app metered
      var meteredCountries: [CLVData.Apps.AppMeteredCountry]?
      /// Reference to the app this metered belongs to
      var app: CLVData.Base.Reference?
      /// A label used to identify this metered action
      var label: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        amount <- map["amount"]
        action <- map["action"]
        active <- map["active"]
        meteredCountries <- map["meteredCountries"]
        app <- map["app"]
        label <- map["label"]
      }
    }

    class AppMeteredCountry: Mappable {
      /// Unique identifier
      var id: String?
      /// App metered action
      var action: String?
      /// The cost of the metered country
      var amount: Int?
      /// The country of the metered country
      var country: String?
      /// App metered country active status
      var active: Bool?
      /// Reference to metered this metered country belongs to
      var appMetered: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        action <- map["action"]
        amount <- map["amount"]
        country <- map["country"]
        active <- map["active"]
        appMetered <- map["appMetered"]
      }
    }

    class AppNotification: Mappable {
      /// The app the notification will be sent to. This will be autopopulated by the server.
      var app: CLVData.Base.Reference?
      /// 
      var event: String?
      /// The time to live of the notification in seconds. By default this is 5 days.
      var timeToLive: Int?
      /// Payload of the notification. This is at most 4000 characters.
      var data: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        app <- map["app"]
        event <- map["event"]
        timeToLive <- map["timeToLive"]
        data <- map["data"]
      }
    }

    class AppSubscription: Mappable {
      /// Unique identifier
      var id: String?
      /// DEPRECATED: App subscription name.  Per country pricing in subscriptionCountries.
      var name: String?
      /// DEPRECATED: The cost of the subscription.  Per country pricing in subscriptionCountries.
      var amount: Int?
      /// DEPRECATED: App subscription name.  Per country pricing in subscriptionCountries.
      var description: String?
      /// DEPRECATED: App subscription active status.  Per country pricing in subscriptionCountries.
      var active: Bool?
      /// Subscription country options for this app subscription
      var subscriptionCountries: [CLVData.Apps.AppSubscriptionCountry]?
      /// Reference to app this subscription belongs to
      var app: CLVData.Base.Reference?
      /// App subscription label
      var label: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        description <- map["description"]
        active <- map["active"]
        subscriptionCountries <- map["subscriptionCountries"]
        app <- map["app"]
        label <- map["label"]
      }
    }

    class AppSubscriptionCountry: Mappable {
      /// Unique identifier
      var id: String?
      /// App subscription country name
      var name: String?
      /// The cost of the subscription country
      var amount: Int?
      /// The country of the subscription country
      var country: String?
      /// App subscription country name
      var description: String?
      /// App subscription country active status
      var active: Bool?
      /// Reference to subscription this subscription country belongs to
      var appSubscription: CLVData.Base.Reference?
      /// The number of merchants that have this app subscription country installed
      var installCount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        country <- map["country"]
        description <- map["description"]
        active <- map["active"]
        appSubscription <- map["appSubscription"]
        installCount <- map["installCount"]
      }
    }

    class AppUsbDevice: Mappable {
      var packageName: String?
      var vendorId: Int?
      var productId: Int?
      var app: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        packageName <- map["packageName"]
        vendorId <- map["vendorId"]
        productId <- map["productId"]
        app <- map["app"]
      }
    }

    class BusinessType: Mappable {
      var businessTypeGroupCode: CLVData.Apps.BusinessTypeGroupCode?
      /// localized business type group
      var businessTypeGroupName: String?
      var code: CLVData.Base.BusinessTypeCode?
      /// Localized business type
      var name: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        businessTypeGroupCode <- map["businessTypeGroupCode"]
        businessTypeGroupName <- map["businessTypeGroupName"]
        code <- map["code"]
        name <- map["name"]
      }
    }

    enum BusinessTypeGroupCode {
      case FOOD
      case RETAIL
      case SERVICES
    }

    class DeviceType: Mappable {
      var name: String?
      var displayName: String?
      var models: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        name <- map["name"]
        displayName <- map["displayName"]
        models <- map["models"]
      }
    }

    enum MerchantBillingStatus {
      case ACTIVE
      case LAPSED
    }

    enum OAuthResponseType {
      case TOKEN
      case CODE
    }

    enum ProductType {
      case ANDROID
      case WEB
      case BOTH
    }

    enum ScanStatus {
      case NOT_SCANNED
      case IN_PROGRESS
      case PASSED
      case FAILED
    }

    class Screenshot: Mappable {
      /// URL for the app screenshot
      var name: String?
      /// URL for the small version (80 x 80) of the app screenshot
      var small: String?
      /// URL for the medium version (200 x 200) of the app screenshot
      var medium: String?
      /// URL for the large version (800 x 800) of the app screenshot
      var large: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        name <- map["name"]
        small <- map["small"]
        medium <- map["medium"]
        large <- map["large"]
      }
    }

    class WebHook: Mappable {
      var url: String?
      /// A secret string included as a header in the HTTP request from Clover to the developer's web hook callback URL.
      var secret: String?
      var valid: Bool?
      /// The verification code that was sent to the developer's web hook callback URL.
      var verification: String?
      var orders: Bool?
      var app: Bool?
      var payments: Bool?
      var inventory: Bool?
      var customers: Bool?
      var merchants: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        url <- map["url"]
        secret <- map["secret"]
        valid <- map["valid"]
        verification <- map["verification"]
        orders <- map["orders"]
        app <- map["app"]
        payments <- map["payments"]
        inventory <- map["inventory"]
        customers <- map["customers"]
        merchants <- map["merchants"]
      }
    }
  }

  class Base {

    class Address: Mappable {
      var address1: String?
      var address2: String?
      var address3: String?
      var city: String?
      var country: String?
      var phoneNumber: String?
      var state: String?
      var zip: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        address1 <- map["address1"]
        address2 <- map["address2"]
        address3 <- map["address3"]
        city <- map["city"]
        country <- map["country"]
        phoneNumber <- map["phoneNumber"]
        state <- map["state"]
        zip <- map["zip"]
      }
    }

    enum ApprovalStatus {
      case NEW
      case PENDING
      case APPROVED_PENDING_SIGNING
      case APPROVED
      case DENIED
      case PUBLISHED
    }

    enum BusinessTypeCode {
      case FULL_SERVICE_RESTAURANT
      case QUICK_SERVICE_RESTAURANT
      case COFFEE_SHOP
      case BAKERY
      case BAR
      case FOOD_TRUCK
      case FROZEN_YOGURT
      case PIZZA
      case DELI
      case OTHER_RESTAURANT
      case BOUTIQUE
      case CONVENIENCE_STORE
      case GROCERY
      case LIQUOR_STORE
      case VAPE_SHOP
      case JEWELRY
      case FLORIST
      case OTHER_RETAIL
      case FITNESS
      case SPA
      case HAIR_SALON
      case HOME_AND_REPAIR
      case PROFESSIONAL_SERVICES
      case CATERING
      case OTHER_SERVICE
    }

    class CountryInfo: Mappable {
      /// ISO 3166-1-alpha-2 code
      var countryCode: String?
      var displayName: String?
      var localDisplayName: String?
      var defaultCurrency: String?
      var defaultTimezone: String?
      /// Indicates whether the state/province field is required when creating the address
      var stateProvinceRequired: Bool?
      /// Indicates whether the ZIP/Postal code field is required when creating the address
      var zipPostalRequired: Bool?
      /// Indicates whether the county field is required when creating the address
      var countyRequired: Bool?
      var defaultLocale: String?
      /// Indicates whether the country is enabled for app market billing
      var appMarketBillingEnabled: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        countryCode <- map["countryCode"]
        displayName <- map["displayName"]
        localDisplayName <- map["localDisplayName"]
        defaultCurrency <- map["defaultCurrency"]
        defaultTimezone <- map["defaultTimezone"]
        stateProvinceRequired <- map["stateProvinceRequired"]
        zipPostalRequired <- map["zipPostalRequired"]
        countyRequired <- map["countyRequired"]
        defaultLocale <- map["defaultLocale"]
        appMarketBillingEnabled <- map["appMarketBillingEnabled"]
      }
    }

    class Reference: Mappable {
      /// Unique identifier
      var id: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
      }
    }

    class ServiceCharge: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the service charge is associated
      var orderRef: CLVData.Base.Reference?
      /// Service charge name
      var name: String?
      /// If this service charge is enabled
      var enabled: Bool?
      /// Percent to charge; TODO: support non-integer service charges, e.g. 12.5%
      var percentage: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        name <- map["name"]
        enabled <- map["enabled"]
        percentage <- map["percentage"]
      }
    }

    class Tender: Mappable {
      /// Unique identifier
      var id: String?
      /// If this merchant tender is editable
      var editable: Bool?
      /// Label Key
      var labelKey: String?
      /// Label Key
      var label: String?
      /// If this tender opens the cash drawer
      var opensCashDrawer: Bool?
      /// Allow tipping on payment from tender
      var supportsTipping: Bool?
      /// If this merchant tender is enabled
      var enabled: Bool?
      /// If this merchant tender is visible
      var visible: Bool?
      /// Label Key
      var instructions: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        editable <- map["editable"]
        labelKey <- map["labelKey"]
        label <- map["label"]
        opensCashDrawer <- map["opensCashDrawer"]
        supportsTipping <- map["supportsTipping"]
        enabled <- map["enabled"]
        visible <- map["visible"]
        instructions <- map["instructions"]
      }
    }
  }

  class Customers {

    class Address: Mappable {
      var id: String?
      var address1: String?
      var address2: String?
      var address3: String?
      var city: String?
      var country: String?
      var state: String?
      var zip: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        address1 <- map["address1"]
        address2 <- map["address2"]
        address3 <- map["address3"]
        city <- map["city"]
        country <- map["country"]
        state <- map["state"]
        zip <- map["zip"]
      }
    }

    class Customer: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the customer is associated
      var orderRef: CLVData.Base.Reference?
      /// First/given name of the customer
      var firstName: String?
      /// Last name/surname of the customer
      var lastName: String?
      var marketingAllowed: Bool?
      var customerSince: Int?
      var orders: [CLVData.Base.Reference]?
      var addresses: [CLVData.Customers.Address]?
      var emailAddresses: [CLVData.Customers.EmailAddress]?
      var phoneNumbers: [CLVData.Customers.PhoneNumber]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        firstName <- map["firstName"]
        lastName <- map["lastName"]
        marketingAllowed <- map["marketingAllowed"]
        customerSince <- map["customerSince"]
        orders <- map["orders"]
        addresses <- map["addresses"]
        emailAddresses <- map["emailAddresses"]
        phoneNumbers <- map["phoneNumbers"]
      }
    }

    class EmailAddress: Mappable {
      var id: String?
      var emailAddress: String?
      var verifiedTime: NSDate?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        emailAddress <- map["emailAddress"]
        verifiedTime <- (map["verifiedTime"], CLVDateTransform())
      }
    }

    class PhoneNumber: Mappable {
      var id: String?
      var phoneNumber: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        phoneNumber <- map["phoneNumber"]
      }
    }
  }

  class Developer {

    class Developer: Mappable {
      /// Unique identifier
      var id: String?
      /// Developer's name.  Could be a company name.  Whatever is to be shown as who made the app in App Marketplace, e.g. NoshList, Pioneer Works Inc., Seven Spaces, etc.  Also used as (optional) Business DBA (Doing Business Name) name when sending to Braintree for app billing background check.
      var name: String?
      /// Developer's individual first name
      var firstName: String?
      /// Developer's individual last name
      var lastName: String?
      /// Developer's email
      var email: String?
      /// Developer's phone
      var phone: String?
      /// Developer's date of birth
      var dob: String?
      /// Developer's SSN; won't be stored in the clear in the DB; will be stored encrypted in sensitiveInfo
      var ssn: String?
      /// Developer's address
      var address: String?
      /// Developer's city
      var city: String?
      /// Developer's county
      var county: String?
      /// Developer's state
      var state: String?
      /// Developer's country
      var country: String?
      /// Developer's postal code
      var postalCode: String?
      /// Developer's bank account number; won't be stored in the clear in the DB; will be stored encrypted in sensitiveInfo
      var bankAccountNumber: String?
      /// Developer's bank routing number
      var bankRoutingNumber: String?
      /// Developer's business legal name
      var businessLegalName: String?
      /// Developer's Tax ID
      var tin: String?
      /// Developer's VAT Register Number
      var vatRegisterNumber: String?
      /// Sensitive data encrypted
      var sensitiveData: String?
      /// Developer's business address
      var businessAddress: String?
      /// Developer's business city
      var businessCity: String?
      /// Developer's business state
      var businessState: String?
      /// Developer's business country
      var businessCountry: String?
      /// Developer's business postal code
      var businessPostalCode: String?
      /// Developer's billing status
      var billingStatus: CLVData.Developer.DeveloperBillingStatus?
      /// Developer's billing status message
      var billingStatusMessage: String?
      var approvalStatus: CLVData.Base.ApprovalStatus?
      /// If the user has accepted the developer agreement
      var acceptedAgreement: Bool?
      /// Name of public relations contact
      var prName: String?
      /// Email of public relations contact
      var prEmail: String?
      /// Phone of public relations contact
      var prPhone: String?
      /// Developer's business website
      var website: String?
      /// Timestamp indicating the last time the developer was modified.
      var modifiedTime: NSDate?
      /// The user account that owns this developer account.
      var owner: CLVData.Base.Reference?
      /// Temporary while we are switching US billing systems
      var appBillingSystem: String?
      /// The Infolease vendor code.  This is generated when the developer is on-boarded in the Infolease system.
      var infoleaseVendorCode: String?
      /// The Infolease GL (General Ledger) code.  Only for specific apps.  Will usually be null.
      var infoleaseGlCode: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        firstName <- map["firstName"]
        lastName <- map["lastName"]
        email <- map["email"]
        phone <- map["phone"]
        dob <- map["dob"]
        ssn <- map["ssn"]
        address <- map["address"]
        city <- map["city"]
        county <- map["county"]
        state <- map["state"]
        country <- map["country"]
        postalCode <- map["postalCode"]
        bankAccountNumber <- map["bankAccountNumber"]
        bankRoutingNumber <- map["bankRoutingNumber"]
        businessLegalName <- map["businessLegalName"]
        tin <- map["tin"]
        vatRegisterNumber <- map["vatRegisterNumber"]
        sensitiveData <- map["sensitiveData"]
        businessAddress <- map["businessAddress"]
        businessCity <- map["businessCity"]
        businessState <- map["businessState"]
        businessCountry <- map["businessCountry"]
        businessPostalCode <- map["businessPostalCode"]
        billingStatus <- map["billingStatus"]
        billingStatusMessage <- map["billingStatusMessage"]
        approvalStatus <- map["approvalStatus"]
        acceptedAgreement <- map["acceptedAgreement"]
        prName <- map["prName"]
        prEmail <- map["prEmail"]
        prPhone <- map["prPhone"]
        website <- map["website"]
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        owner <- map["owner"]
        appBillingSystem <- map["appBillingSystem"]
        infoleaseVendorCode <- map["infoleaseVendorCode"]
        infoleaseGlCode <- map["infoleaseGlCode"]
      }
    }

    enum DeveloperBillingStatus {
      case PENDING
      case APPROVED
      case DECLINED
      case ERROR
    }

    class MerchantGroup: Mappable {
      /// Unique identifier
      var id: String?
      /// Group name.
      var name: String?
      /// The developer that created this merchant group.
      var developer_: CLVData.Base.Reference?
      /// Timestamp indicating when the group was created.
      var createdTime: NSDate?
      /// The merchants directly added to the group (static merchants).
      var merchants: [CLVData.Merchant.Merchant]?
      /// The filter query parameters used to join merchants to this group.
      var merchantFilter: String?
      /// The merchants in the group joined by the filter.
      var filterMerchants: [CLVData.Merchant.Merchant]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        developer_ <- map["developer_"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        merchants <- map["merchants"]
        merchantFilter <- map["merchantFilter"]
        filterMerchants <- map["filterMerchants"]
      }
    }
  }

  class Device {

    enum BuildType {
      case ENG
      case USER
    }

    class Device: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the device (if entered)
      var name: String?
      var model: String?
      var orderPrefix: String?
      var terminalPrefix: Int?
      var serial: String?
      var buildNumber: Int?
      var secureId: String?
      var buildType: CLVData.Device.BuildType?
      var cpuId: String?
      /// The IMEI of the device
      var imei: String?
      /// The IMSI of the SIM in the device (if present)
      var imsi: String?
      /// The ICCID of the SIM in the device (if present)
      var simIccid: String?
      var deviceCertificate: String?
      var pedCertificate: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        model <- map["model"]
        orderPrefix <- map["orderPrefix"]
        terminalPrefix <- map["terminalPrefix"]
        serial <- map["serial"]
        buildNumber <- map["buildNumber"]
        secureId <- map["secureId"]
        buildType <- map["buildType"]
        cpuId <- map["cpuId"]
        imei <- map["imei"]
        imsi <- map["imsi"]
        simIccid <- map["simIccid"]
        deviceCertificate <- map["deviceCertificate"]
        pedCertificate <- map["pedCertificate"]
      }
    }

    class DeviceProvision: Mappable {
      /// Unique identifier
      var id: String?
      var deviceRef: CLVData.Base.Reference?
      var state: CLVData.Device.DeviceProvisionState?
      var lastActivationCode: String?
      var activationCode: String?
      var emailSent: Bool?
      var hasShipment: Bool?
      var serialNumber: String?
      var merchant: CLVData.Base.Reference?
      var deviceType: String?
      var provisionedTime: NSDate?
      var activatedTime: NSDate?
      var reseller: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        deviceRef <- map["deviceRef"]
        state <- map["state"]
        lastActivationCode <- map["lastActivationCode"]
        activationCode <- map["activationCode"]
        emailSent <- map["emailSent"]
        hasShipment <- map["hasShipment"]
        serialNumber <- map["serialNumber"]
        merchant <- map["merchant"]
        deviceType <- map["deviceType"]
        provisionedTime <- (map["provisionedTime"], CLVDateTransform())
        activatedTime <- (map["activatedTime"], CLVDateTransform())
        reseller <- map["reseller"]
      }
    }

    enum DeviceProvisionState {
      case NOT_ASSOCIATED
      case DISASSOCIATED
      case ASSOCIATED
    }
  }

  class Employees {

    enum AccountRole {
      case ADMIN
      case MANAGER
      case EMPLOYEE
    }

    class Employee: Mappable {
      /// Unique identifier
      var id: String?
      /// Full name of the employee
      var name: String?
      /// Nickname of the employee (shows up on receipts)
      var nickname: String?
      /// Custom ID of the employee
      var customId: String?
      /// Email of the employee (optional)
      var email: String?
      /// Returns true if this employee was sent an invite to activate their account
      var inviteSent: Bool?
      /// Timestamp of when this employee claimed their account
      var claimedTime: NSDate?
      /// Employee PIN (hashed)
      var pin: String?
      /// Employee PIN
      var unhashedPin: String?
      /// Employee System Role
      var role: CLVData.Employees.AccountRole?
      var roles: [CLVData.Base.Reference]?
      /// Returns true if this employee is the owner account for this merchant
      var isOwner: Bool?
      /// This employee's shifts
      var shifts: [CLVData.Base.Reference]?
      /// This employee's payments
      var payments: [CLVData.Base.Reference]?
      /// This employee's orders
      var orders: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        nickname <- map["nickname"]
        customId <- map["customId"]
        email <- map["email"]
        inviteSent <- map["inviteSent"]
        claimedTime <- (map["claimedTime"], CLVDateTransform())
        pin <- map["pin"]
        unhashedPin <- map["unhashedPin"]
        role <- map["role"]
        roles <- map["roles"]
        isOwner <- map["isOwner"]
        shifts <- map["shifts"]
        payments <- map["payments"]
        orders <- map["orders"]
      }
    }

    enum Permission {
      case ORDERS_R
      case ORDERS_W
      case INVENTORY_R
      case INVENTORY_W
      case PAYMENTS_R
      case PAYMENTS_W
      case CUSTOMERS_R
      case CUSTOMERS_W
      case EMPLOYEES_R
      case EMPLOYEES_W
      case MERCHANT_R
      case MERCHANT_W
    }

    class PermissionSet: Mappable {
      /// Unique identifier
      var id: String?
      /// Key of the permissionSet
      var name: String?
      /// Label of the permissionSet
      var label: String?
      var app: CLVData.Base.Reference?
      var employeeDefault: Bool?
      var managerDefault: Bool?
      /// Bitmap of permissions
      var permissions: CLVData.Employees.Permissions?
      /// roles enabled for this merchant
      var roles: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        label <- map["label"]
        app <- map["app"]
        employeeDefault <- map["employeeDefault"]
        managerDefault <- map["managerDefault"]
        permissions <- map["permissions"]
        roles <- map["roles"]
      }
    }

    class PermissionSetRole: Mappable {
      /// Unique identifier
      var id: String?
      /// The role
      var role: CLVData.Base.Reference?
      /// The role
      var permissionSet: CLVData.Base.Reference?
      var modified_time: Int?
      var deleted_time: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        role <- map["role"]
        permissionSet <- map["permissionSet"]
        modified_time <- map["modified_time"]
        deleted_time <- map["deleted_time"]
      }
    }

    class Permissions: Mappable {
      /// Unique identifier
      var id: String?
      /// A bitmap representing the permissions
      var bits: Int?
      /// A readable list of permissions
      var readablePermissions: [CLVData.Employees.Permission]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        bits <- map["bits"]
        readablePermissions <- map["readablePermissions"]
      }
    }

    class Role: Mappable {
      /// Unique identifier
      var id: String?
      /// Full name of the role
      var name: String?
      /// Base System Role
      var systemRole: CLVData.Employees.AccountRole?
      /// employees with this role
      var employeesRef: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        systemRole <- map["systemRole"]
        employeesRef <- map["employeesRef"]
      }
    }

    class Shift: Mappable {
      /// Unique identifier
      var id: String?
      /// The employee that worked this shift
      var employee: CLVData.Employees.Employee?
      /// Amount of cash tips collected
      var cashTipsCollected: Int?
      /// Whether the employee used server banking
      var serverBanking: Bool?
      /// Clock in time
      var inTime: NSDate?
      /// Overridden clock in time
      var overrideInTime: NSDate?
      /// The employee who overrode the clock in time
      var overrideInEmployee: CLVData.Employees.Employee?
      /// Clock out time
      var outTime: NSDate?
      /// Overridden clock out time
      var overrideOutTime: NSDate?
      /// The employee who overrode the clock out time
      var overrideOutEmployee: CLVData.Employees.Employee?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        employee <- map["employee"]
        cashTipsCollected <- map["cashTipsCollected"]
        serverBanking <- map["serverBanking"]
        inTime <- (map["inTime"], CLVDateTransform())
        overrideInTime <- (map["overrideInTime"], CLVDateTransform())
        overrideInEmployee <- map["overrideInEmployee"]
        outTime <- (map["outTime"], CLVDateTransform())
        overrideOutTime <- (map["overrideOutTime"], CLVDateTransform())
        overrideOutEmployee <- map["overrideOutEmployee"]
      }
    }
  }

  class Hours {

    class HourRange: Mappable {
      var start: Int?
      var end: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        start <- map["start"]
        end <- map["end"]
      }
    }

    class HoursSet: Mappable {
      /// Unique identifier
      var id: String?
      /// Friendly name to describe the hours
      var name: String?
      var reference: CLVData.Hours.Reference?
      var sunday: [CLVData.Hours.HourRange]?
      var monday: [CLVData.Hours.HourRange]?
      var tuesday: [CLVData.Hours.HourRange]?
      var wednesday: [CLVData.Hours.HourRange]?
      var thursday: [CLVData.Hours.HourRange]?
      var friday: [CLVData.Hours.HourRange]?
      var saturday: [CLVData.Hours.HourRange]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        reference <- map["reference"]
        sunday <- map["sunday"]
        monday <- map["monday"]
        tuesday <- map["tuesday"]
        wednesday <- map["wednesday"]
        thursday <- map["thursday"]
        friday <- map["friday"]
        saturday <- map["saturday"]
      }
    }

    class Reference: Mappable {
      /// ID of the reference that uses this set of hours
      var id: String?
      /// External type that these hours reference
      var type: CLVData.Hours.ReferenceType?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        type <- map["type"]
      }
    }

    enum ReferenceType {
      case ORDER_TYPE
      case ITEM_GROUP
    }
  }

  class Inventory {

    class Attribute: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of this attribute
      var name: String?
      /// The item group this attribute belongs to
      var itemGroup: CLVData.Base.Reference?
      /// Options associated with this attribute
      var options: [CLVData.Inventory.Option]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        itemGroup <- map["itemGroup"]
        options <- map["options"]
      }
    }

    class Category: Mappable {
      /// Unique identifier
      var id: String?
      /// 
      var name: String?
      var sortOrder: Int?
      /// Items associated with this category
      var items: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        sortOrder <- map["sortOrder"]
        items <- map["items"]
      }
    }

    class CategoryItem: Mappable {
      var item: CLVData.Inventory.Item?
      var category: CLVData.Inventory.Category?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        item <- map["item"]
        category <- map["category"]
      }
    }

    class Discount: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the discount
      var name: String?
      /// Discount amount in fraction of currency unit (e.g. cents) based on currency fraction digits supported
      var amount: Int?
      /// Discount amount in percent
      var percentage: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        percentage <- map["percentage"]
      }
    }

    class Item: Mappable {
      /// Unique identifier
      var id: String?
      /// True if this item is hidden from register
      var hidden: Bool?
      /// Reference to an item group
      var itemGroup: CLVData.Base.Reference?
      /// Name of the item
      var name: String?
      /// Alternate name of the item
      var alternateName: String?
      /// Product code, e.g. UPC or EAN
      var code: String?
      /// SKU of the item
      var sku: String?
      /// Price of the item, typically in cents; use priceType and merchant currency to determine actual item price
      var price: Int?
      var priceType: CLVData.Inventory.PriceType?
      /// Flag to indicate whether or not to use default tax rates
      var defaultTaxRates: Bool?
      /// Unit name, e.g. oz, lb
      var unitName: String?
      /// Cost of the item to merchant, as opposed to customer price
      var cost: Int?
      /// True if this item should be counted as revenue, for example gift cards and donations would not
      var isRevenue: Bool?
      /// DEPRECATED: use itemStock instead
      var stockCount: Int?
      var taxRates: [CLVData.Inventory.TaxRate]?
      var modifierGroups: [CLVData.Inventory.ModifierGroup]?
      /// Categories associated with this item
      var categories: [CLVData.Inventory.Category]?
      /// Tags associated with this item
      var tags: [CLVData.Inventory.Tag]?
      /// Item stock attribute that can be expanded to show stock quantity
      var itemStock: CLVData.Inventory.ItemStock?
      var modifiedTime: NSDate?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        hidden <- map["hidden"]
        itemGroup <- map["itemGroup"]
        name <- map["name"]
        alternateName <- map["alternateName"]
        code <- map["code"]
        sku <- map["sku"]
        price <- map["price"]
        priceType <- map["priceType"]
        defaultTaxRates <- map["defaultTaxRates"]
        unitName <- map["unitName"]
        cost <- map["cost"]
        isRevenue <- map["isRevenue"]
        stockCount <- map["stockCount"]
        taxRates <- map["taxRates"]
        modifierGroups <- map["modifierGroups"]
        categories <- map["categories"]
        tags <- map["tags"]
        itemStock <- map["itemStock"]
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
      }
    }

    class ItemGroup: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the option
      var name: String?
      /// Items that are members of this group
      var items: [CLVData.Base.Reference]?
      /// Attributes that belong to this group
      var attributes: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        items <- map["items"]
        attributes <- map["attributes"]
      }
    }

    class ItemModifierGroup: Mappable {
      var item: CLVData.Inventory.Item?
      var modifierGroup: CLVData.Inventory.ModifierGroup?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        item <- map["item"]
        modifierGroup <- map["modifierGroup"]
      }
    }

    /// The class is used to update the item stock
    class ItemStock: Mappable {
      /// Reference to an item
      var item: CLVData.Base.Reference?
      /// DEPRECATED: use quantity instead
      var stockCount: Int?
      /// Current count of this item in stock
      var quantity: Double?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        item <- map["item"]
        stockCount <- map["stockCount"]
        quantity <- map["quantity"]
      }
    }

    class Modifier: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the modifier
      var name: String?
      /// Alternate name of the modifier
      var alternateName: String?
      var price: Int?
      var modifierGroup: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        alternateName <- map["alternateName"]
        price <- map["price"]
        modifierGroup <- map["modifierGroup"]
      }
    }

    class ModifierGroup: Mappable {
      var id: String?
      /// Name of the modifier group
      var name: String?
      var alternateName: String?
      var minRequired: Int?
      var maxAllowed: Int?
      var showByDefault: Bool?
      var modifiers: [CLVData.Inventory.Modifier]?
      /// The ordered, comma-separated list of modifier ids in this group.
      var modifierIds: String?
      var items: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        alternateName <- map["alternateName"]
        minRequired <- map["minRequired"]
        maxAllowed <- map["maxAllowed"]
        showByDefault <- map["showByDefault"]
        modifiers <- map["modifiers"]
        modifierIds <- map["modifierIds"]
        items <- map["items"]
      }
    }

    class Option: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the option
      var name: String?
      var attribute: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        attribute <- map["attribute"]
      }
    }

    /// This class represents the association between an item and an option
    class OptionItem: Mappable {
      /// Reference to an option
      var option: CLVData.Base.Reference?
      /// Reference to an item
      var item: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        option <- map["option"]
        item <- map["item"]
      }
    }

    enum PriceType {
      case FIXED
      case VARIABLE
      case PER_UNIT
    }

    class Tag: Mappable {
      /// Unique identifier
      var id: String?
      /// Tag name
      var name: String?
      /// Items associated with this tag
      var items: [CLVData.Base.Reference]?
      /// Printers associated with this tag
      var printers: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        items <- map["items"]
        printers <- map["printers"]
      }
    }

    class TagItem: Mappable {
      var tag: CLVData.Inventory.Tag?
      var item: CLVData.Inventory.Item?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        tag <- map["tag"]
        item <- map["item"]
      }
    }

    class TagPrinter: Mappable {
      var tag: CLVData.Inventory.Tag?
      var printer: CLVData.Printer.Printer?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        tag <- map["tag"]
        printer <- map["printer"]
      }
    }

    class TaxRate: Mappable {
      var id: String?
      /// The line item with which the tax rate is associated
      var lineItemRef: CLVData.Base.Reference?
      var name: String?
      var rate: Int?
      var isDefault: Bool?
      /// Items associated with this tax rate
      var items: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        lineItemRef <- map["lineItemRef"]
        name <- map["name"]
        rate <- map["rate"]
        isDefault <- map["isDefault"]
        items <- map["items"]
      }
    }

    class TaxRateItem: Mappable {
      var taxRate: CLVData.Inventory.TaxRate?
      var item: CLVData.Inventory.Item?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        taxRate <- map["taxRate"]
        item <- map["item"]
      }
    }
  }

  class Merchant {

    class Gateway: Mappable {
      var paymentProcessorName: String?
      var authorizationFrontEnd: String?
      var acquiringBackEnd: String?
      var paymentGatewayApi: String?
      var accountName: String?
      var mid: String?
      var tid: String?
      var storeId: String?
      var supportsTipping: Bool?
      var frontendMid: String?
      var backendMid: String?
      var supportsTipAdjust: Bool?
      var supportsNakedCredit: Bool?
      var keyPrefix: String?
      var keyInfo: [String:String]?
      var closingTime: String?
      var newBatchCloseEnabled: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        paymentProcessorName <- map["paymentProcessorName"]
        authorizationFrontEnd <- map["authorizationFrontEnd"]
        acquiringBackEnd <- map["acquiringBackEnd"]
        paymentGatewayApi <- map["paymentGatewayApi"]
        accountName <- map["accountName"]
        mid <- map["mid"]
        tid <- map["tid"]
        storeId <- map["storeId"]
        supportsTipping <- map["supportsTipping"]
        frontendMid <- map["frontendMid"]
        backendMid <- map["backendMid"]
        supportsTipAdjust <- map["supportsTipAdjust"]
        supportsNakedCredit <- map["supportsNakedCredit"]
        keyPrefix <- map["keyPrefix"]
        keyInfo <- map["keyInfo"]
        closingTime <- map["closingTime"]
        newBatchCloseEnabled <- map["newBatchCloseEnabled"]
      }
    }

    class Logo: Mappable {
      /// The type of merchant logo
      var logoType: CLVData.Merchant.LogoType?
      /// The filename of the logo
      var logoFilename: String?
      /// URL of the logo file. Generated from filename.
      var url: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        logoType <- map["logoType"]
        logoFilename <- map["logoFilename"]
        url <- map["url"]
      }
    }

    enum LogoType {
      case BUSINESS
      case RECEIPT
    }

    class Merchant: Mappable {
      /// Unique identifier
      var id: String?
      /// Name of the merchant
      var name: String?
      /// The account that owns this merchant
      var owner: CLVData.Employees.Employee?
      /// The address of the merchant.
      var address: CLVData.Base.Address?
      var merchantPlan: CLVData.Merchant.MerchantPlan?
      var defaultCurrency: String?
      var phoneNumber: String?
      var website: String?
      var logos: [CLVData.Merchant.Logo]?
      var createdTime: NSDate?
      var properties: CLVData.Merchant.MerchantProperties?
      var gateway: CLVData.Merchant.Gateway?
      var tipSuggestions: [CLVData.Merchant.TipSuggestion]?
      /// This merchant's employees
      var employees: [CLVData.Employees.Employee]?
      /// This merchant's inventory items
      var items: [CLVData.Inventory.Item]?
      /// This merchant's inventory tags
      var tags: [CLVData.Inventory.Tag]?
      /// This merchant's supported tenders
      var tenders: [CLVData.Base.Tender]?
      /// This merchant's employees' shifts
      var shifts: [CLVData.Employees.Shift]?
      /// This merchant's orders
      var orders: [CLVData.Order.Order]?
      /// This merchant's order payments
      var payments: [CLVData.Payments.Payment]?
      var taxRates: [CLVData.Inventory.TaxRate]?
      var printers: [CLVData.Printer.Printer]?
      var modifierGroups: [CLVData.Inventory.ModifierGroup]?
      var orderTypes: [CLVData.Order.OrderType]?
      /// The merchant's reseller
      var reseller: CLVData.Base.Reference?
      /// This merchant's opening hours
      var opening_hours: [CLVData.Hours.HoursSet]?
      /// The business type of the merchant
      var businessTypeCode: CLVData.Base.BusinessTypeCode?
      /// Returns true when the merchant is billable.
      var isBillable: Bool?
      /// A list of devices a merchant owns
      var devices: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        owner <- map["owner"]
        address <- map["address"]
        merchantPlan <- map["merchantPlan"]
        defaultCurrency <- map["defaultCurrency"]
        phoneNumber <- map["phoneNumber"]
        website <- map["website"]
        logos <- map["logos"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        properties <- map["properties"]
        gateway <- map["gateway"]
        tipSuggestions <- map["tipSuggestions"]
        employees <- map["employees"]
        items <- map["items"]
        tags <- map["tags"]
        tenders <- map["tenders"]
        shifts <- map["shifts"]
        orders <- map["orders"]
        payments <- map["payments"]
        taxRates <- map["taxRates"]
        printers <- map["printers"]
        modifierGroups <- map["modifierGroups"]
        orderTypes <- map["orderTypes"]
        reseller <- map["reseller"]
        opening_hours <- map["opening_hours"]
        businessTypeCode <- map["businessTypeCode"]
        isBillable <- map["isBillable"]
        devices <- map["devices"]
      }
    }

    class MerchantPlan: Mappable {
      /// Unique identifier
      var id: String?
      /// The name of the merchant plan
      var name: String?
      /// Description of the plan
      var description: String?
      var price: Int?
      var modules: [CLVData.Merchant.Module]?
      var appBundle: CLVData.Apps.AppBundle?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        description <- map["description"]
        price <- map["price"]
        modules <- map["modules"]
        appBundle <- map["appBundle"]
      }
    }

    class MerchantProperties: Mappable {
      var defaultCurrency: String?
      var tipsEnabled: Bool?
      var receiptProperties: String?
      var summaryHour: Int?
      var signatureThreshold: Int?
      var hasDefaultEmployee: Bool?
      var tipRateDefault: Int?
      var onPaperTipSignatures: Bool?
      var autoLogout: Bool?
      var orderTitle: CLVData.Merchant.OrderTitle?
      var orderTitleMax: Int?
      var resetOnReportingTime: Bool?
      var notesOnOrders: Bool?
      var deleteOrders: Bool?
      var removeTaxEnabled: Bool?
      var groupLineItems: Bool?
      var alternateInventoryNames: Bool?
      var autoPrint: Bool?
      var hardwareProfile: String?
      var infoleaseSuppressBilling: Bool?
      var infoleaseSuppressPlanBilling: Bool?
      var shippingAddress: String?
      var marketingEnabled: Bool?
      var marketingPreferenceText: String?
      var bankMarker: Int?
      var supportPhone: String?
      var supportEmail: String?
      var manualCloseout: Bool?
      var showCloseoutOrders: Bool?
      var sendCloseoutEmail: Bool?
      var stayInCategory: Bool?
      /// The locale of the merchant.
      var locale: String?
      var timezone: String?
      /// Whether this merchant is in a VAT country
      var vat: Bool?
      /// The VAT tax name that is shown on receipts
      var vatTaxName: String?
      /// Temporary while we are switching US billing systems
      var appBillingSystem: String?
      /// The ABA Account Number.  Supplied by First Data.
      var abaAccountNumber: String?
      /// The Masked DDA Account Number.  Supplied by First Data.
      var ddaAccountNumber: String?
      var trackStock: Bool?
      var updateStock: Bool?
      var allowClockOutWithOpenOrders: Bool?
      var logInClockInPrompt: Bool?
      var accountType: String?
      /// The business type of the merchant
      var businessTypeCode: CLVData.Base.BusinessTypeCode?
      var pinLength: Int?
      /// Whether cash back is enabled for this merchant
      var cashBackEnabled: Bool?
      /// List of cash back possible cash back amounts
      var cashBackOptions: String?
      /// The maximum amount of cash back that the customer can select.
      var maxCashBack: Int?
      /// Merchant hierarchy (Business, Bank, Agent, Corp, Chain). Supplied by First Data.
      var hierarchy: String?
      /// Whether or not merchant has consented to infolease billing
      var hasConsented: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        defaultCurrency <- map["defaultCurrency"]
        tipsEnabled <- map["tipsEnabled"]
        receiptProperties <- map["receiptProperties"]
        summaryHour <- map["summaryHour"]
        signatureThreshold <- map["signatureThreshold"]
        hasDefaultEmployee <- map["hasDefaultEmployee"]
        tipRateDefault <- map["tipRateDefault"]
        onPaperTipSignatures <- map["onPaperTipSignatures"]
        autoLogout <- map["autoLogout"]
        orderTitle <- map["orderTitle"]
        orderTitleMax <- map["orderTitleMax"]
        resetOnReportingTime <- map["resetOnReportingTime"]
        notesOnOrders <- map["notesOnOrders"]
        deleteOrders <- map["deleteOrders"]
        removeTaxEnabled <- map["removeTaxEnabled"]
        groupLineItems <- map["groupLineItems"]
        alternateInventoryNames <- map["alternateInventoryNames"]
        autoPrint <- map["autoPrint"]
        hardwareProfile <- map["hardwareProfile"]
        infoleaseSuppressBilling <- map["infoleaseSuppressBilling"]
        infoleaseSuppressPlanBilling <- map["infoleaseSuppressPlanBilling"]
        shippingAddress <- map["shippingAddress"]
        marketingEnabled <- map["marketingEnabled"]
        marketingPreferenceText <- map["marketingPreferenceText"]
        bankMarker <- map["bankMarker"]
        supportPhone <- map["supportPhone"]
        supportEmail <- map["supportEmail"]
        manualCloseout <- map["manualCloseout"]
        showCloseoutOrders <- map["showCloseoutOrders"]
        sendCloseoutEmail <- map["sendCloseoutEmail"]
        stayInCategory <- map["stayInCategory"]
        locale <- map["locale"]
        timezone <- map["timezone"]
        vat <- map["vat"]
        vatTaxName <- map["vatTaxName"]
        appBillingSystem <- map["appBillingSystem"]
        abaAccountNumber <- map["abaAccountNumber"]
        ddaAccountNumber <- map["ddaAccountNumber"]
        trackStock <- map["trackStock"]
        updateStock <- map["updateStock"]
        allowClockOutWithOpenOrders <- map["allowClockOutWithOpenOrders"]
        logInClockInPrompt <- map["logInClockInPrompt"]
        accountType <- map["accountType"]
        businessTypeCode <- map["businessTypeCode"]
        pinLength <- map["pinLength"]
        cashBackEnabled <- map["cashBackEnabled"]
        cashBackOptions <- map["cashBackOptions"]
        maxCashBack <- map["maxCashBack"]
        hierarchy <- map["hierarchy"]
        hasConsented <- map["hasConsented"]
      }
    }

    class Module: Mappable {
      /// Unique identifier
      var id: String?
      var name: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
      }
    }

    enum OrderTitle {
      case NONE
      case MANUAL
      case AUTOMATIC
    }

    enum SyncLevel {
      case LOW
      case MEDIUM
      case HIGH
      case NONE
    }

    class SyncSettings: Mappable {
      /// Sync authoirty
      var authority: String?
      /// The minumum sync level rquired for this authority
      var level: CLVData.Merchant.SyncLevel?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        authority <- map["authority"]
        level <- map["level"]
      }
    }

    class TipSuggestion: Mappable {
      var id: String?
      /// Name of the tip
      var name: String?
      /// Suggested tip percentage
      var percentage: Int?
      var isEnabled: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        percentage <- map["percentage"]
        isEnabled <- map["isEnabled"]
      }
    }
  }

  class Order {

    enum CustomerIdMethod {
      case NAME
      case TABLE
      case NAME_TABLE
    }

    class Discount: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the discount is associated
      var orderRef: CLVData.Base.Reference?
      /// The lineItem with which the discount is associated
      var lineItemRef: CLVData.Base.Reference?
      /// If this item is based on a standard discount, this will point to the appropriate inventory.Discount
      var discount: CLVData.Base.Reference?
      /// Name of the discount
      var name: String?
      /// Discount amount in fraction of currency unit (e.g. cents) based on currency fraction digits supported
      var amount: Int?
      /// Discount amount in percent
      var percentage: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        lineItemRef <- map["lineItemRef"]
        discount <- map["discount"]
        name <- map["name"]
        amount <- map["amount"]
        percentage <- map["percentage"]
      }
    }

    class FireOrder: Mappable {
      /// Unique identifier
      var id: String?
      /// The id of the order to fire.
      var orderId: String?
      /// How long in seconds to wait before calling fire.
      var delay: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderId <- map["orderId"]
        delay <- map["delay"]
      }
    }

    enum HoursAvailable {
      case ALL
      case BUSINESS
      case CUSTOM
    }

    class LineItem: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the line item is associated
      var orderRef: CLVData.Base.Reference?
      /// Inventory item used to create this line item
      var item: CLVData.Base.Reference?
      /// Line item name
      var name: String?
      /// Alternate name of the line item
      var alternateName: String?
      /// Price of the item, typically in cents; use priceType and merchant currency to determine actual item price
      var price: Int?
      /// Unit quantity
      var unitQty: Int?
      /// Unit name (e.g. oz, lb, etc.)
      var unitName: String?
      var itemCode: String?
      var note: String?
      var printed: Bool?
      var exchangedLineItem: CLVData.Base.Reference?
      var binName: String?
      var userData: String?
      var createdTime: NSDate?
      var orderClientCreatedTime: NSDate?
      var discounts: [CLVData.Order.Discount]?
      /// does the calculated flag actually do anything?
      var discountAmount: Int?
      var exchanged: Bool?
      var modifications: [CLVData.Order.Modification]?
      var refunded: Bool?
      /// True if this item should be counted as revenue, for example gift cards and donations would not
      var isRevenue: Bool?
      var taxRates: [CLVData.Inventory.TaxRate]?
      /// Payments that were made for this line item
      var payments: [CLVData.Payments.LineItemPayment]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        item <- map["item"]
        name <- map["name"]
        alternateName <- map["alternateName"]
        price <- map["price"]
        unitQty <- map["unitQty"]
        unitName <- map["unitName"]
        itemCode <- map["itemCode"]
        note <- map["note"]
        printed <- map["printed"]
        exchangedLineItem <- map["exchangedLineItem"]
        binName <- map["binName"]
        userData <- map["userData"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        orderClientCreatedTime <- (map["orderClientCreatedTime"], CLVDateTransform())
        discounts <- map["discounts"]
        discountAmount <- map["discountAmount"]
        exchanged <- map["exchanged"]
        modifications <- map["modifications"]
        refunded <- map["refunded"]
        isRevenue <- map["isRevenue"]
        taxRates <- map["taxRates"]
        payments <- map["payments"]
      }
    }

    /// Snapshot of a line item modifier at the time that the order was placed.
    class Modification: Mappable {
      var id: String?
      /// The line item with which the modification is associated
      var lineItemRef: CLVData.Base.Reference?
      var name: String?
      var alternateName: String?
      var amount: Int?
      /// The modifier object.  Values from the Modifier are copied to the Modification at the time that the order is placed.  Modifier values may change after the order is placed.
      var modifier: CLVData.Inventory.Modifier?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        lineItemRef <- map["lineItemRef"]
        name <- map["name"]
        alternateName <- map["alternateName"]
        amount <- map["amount"]
        modifier <- map["modifier"]
      }
    }

    class Order: Mappable {
      /// Unique identifier
      var id: String?
      /// Currency of this order
      var currency: String?
      var customers: [CLVData.Customers.Customer]?
      /// The employee who took this order
      var employee: CLVData.Base.Reference?
      /// Total price of the order
      var total: Int?
      var title: String?
      var note: String?
      var orderType: CLVData.Order.OrderType?
      var taxRemoved: Bool?
      var isVat: Bool?
      var state: String?
      var manualTransaction: Bool?
      var groupLineItems: Bool?
      var testMode: Bool?
      var payType: CLVData.Order.PayType?
      /// Creation timestamp
      var createdTime: NSDate?
      var clientCreatedTime: NSDate?
      /// Last modified time of the order
      var modifiedTime: NSDate?
      var deletedTimestamp: NSDate?
      /// Optional service charge (gratuity) applied to this order
      var serviceCharge: CLVData.Base.ServiceCharge?
      var discounts: [CLVData.Order.Discount]?
      var lineItems: [CLVData.Order.LineItem]?
      var taxRates: [CLVData.Order.OrderTaxRate]?
      /// Payments that were made for this order
      var payments: [CLVData.Payments.Payment]?
      /// Refunds that were made for this order
      var refunds: [CLVData.Payments.Refund]?
      var credits: [CLVData.Payments.Credit]?
      /// Voided payments associated with this order
      var voids: [CLVData.Payments.Payment]?
      /// Device which created the order
      var device: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        currency <- map["currency"]
        customers <- map["customers"]
        employee <- map["employee"]
        total <- map["total"]
        title <- map["title"]
        note <- map["note"]
        orderType <- map["orderType"]
        taxRemoved <- map["taxRemoved"]
        isVat <- map["isVat"]
        state <- map["state"]
        manualTransaction <- map["manualTransaction"]
        groupLineItems <- map["groupLineItems"]
        testMode <- map["testMode"]
        payType <- map["payType"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        deletedTimestamp <- (map["deletedTimestamp"], CLVDateTransform())
        serviceCharge <- map["serviceCharge"]
        discounts <- map["discounts"]
        lineItems <- map["lineItems"]
        taxRates <- map["taxRates"]
        payments <- map["payments"]
        refunds <- map["refunds"]
        credits <- map["credits"]
        voids <- map["voids"]
        device <- map["device"]
      }
    }

    class OrderTaxRate: Mappable {
      var id: String?
      var name: String?
      var amount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
      }
    }

    class OrderType: Mappable {
      /// Unique identifier
      var id: String?
      /// Label Key
      var labelKey: String?
      /// Label Key
      var label: String?
      /// If this order type is taxable
      var taxable: Bool?
      /// If this order type is the default
      var isDefault: Bool?
      /// If set to false, then this order type includes all of the merchant's categories. Otherwise, it only contains the categories defined in the "categories" field on this object.
      var filterCategories: Bool?
      /// If this order type is hidden on the register
      var isHidden: Bool?
      /// The price of a fee added to this order type
      var fee: Int?
      /// The minimum amount required for an order to be placed
      var minOrderAmount: Int?
      /// The maximum amount for an order allowed
      var maxOrderAmount: Int?
      /// The maximum radius allowed for an order (i.e. delivery)
      var maxRadius: Int?
      /// The average time it takes to complete the order
      var avgOrderTime: Int?
      var hoursAvailable: CLVData.Order.HoursAvailable?
      var customerIdMethod: CLVData.Order.CustomerIdMethod?
      /// If this order type is deleted
      var isDeleted: Bool?
      /// Optional system order type that this order type is associated with.
      var systemOrderTypeId: String?
      /// The hours this order type is available (if they differ from normal merchant hours)
      var hours: CLVData.Hours.HoursSet?
      /// The categories of items that can be assigned to this order type
      var categories: [CLVData.Base.Reference]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        labelKey <- map["labelKey"]
        label <- map["label"]
        taxable <- map["taxable"]
        isDefault <- map["isDefault"]
        filterCategories <- map["filterCategories"]
        isHidden <- map["isHidden"]
        fee <- map["fee"]
        minOrderAmount <- map["minOrderAmount"]
        maxOrderAmount <- map["maxOrderAmount"]
        maxRadius <- map["maxRadius"]
        avgOrderTime <- map["avgOrderTime"]
        hoursAvailable <- map["hoursAvailable"]
        customerIdMethod <- map["customerIdMethod"]
        isDeleted <- map["isDeleted"]
        systemOrderTypeId <- map["systemOrderTypeId"]
        hours <- map["hours"]
        categories <- map["categories"]
      }
    }

    class OrderTypeCategory: Mappable {
      var orderType: CLVData.Order.OrderType?
      var category: CLVData.Inventory.Category?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        orderType <- map["orderType"]
        category <- map["category"]
      }
    }

    enum PayType {
      case SPLIT_GUEST
      case SPLIT_ITEM
      case SPLIT_CUSTOM
      case FULL
    }

    class SystemOrderType: Mappable {
      /// Unqiue identifier
      var id: String?
      /// Label Key
      var labelKey: String?
      /// Is for quick service restraunts?
      var isQsr: Bool?
      /// Is for full service restraunts?
      var isFsr: Bool?
      /// Is for retail stores?
      var isRetail: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        labelKey <- map["labelKey"]
        isQsr <- map["isQsr"]
        isFsr <- map["isFsr"]
        isRetail <- map["isRetail"]
      }
    }

    /// Symbols beginning with USER_ or REJECT_ are user-initiated.  Others are client- or server-initiated.
    enum VoidReason {
      case USER_CANCEL
      case TRANSPORT_ERROR
      case REJECT_SIGNATURE
      case REJECT_PARTIAL_AUTH
      case NOT_APPROVED
      case FAILED
      case AUTH_CLOSED_NEW_CARD
      case DEVELOPER_PAY_PARTIAL_AUTH
      case REJECT_DUPLICATE
    }
  }

  class Payments {

    enum AVSResult {
      case SUCCESS
      case ZIP_CODE_MATCH
      case ZIP_CODE_MATCH_ADDRESS_NOT_CHECKED
      case ADDRESS_MATCH
      case ADDRESS_MATCH_ZIP_NOT_CHECKED
      case NEITHER_MATCH
      case SERVICE_FAILURE
      case SERVICE_UNAVAILABLE
      case NOT_CHECKED
      case ZIP_CODE_NOT_MATCHED_ADDRESS_NOT_CHECKED
      case ADDRESS_NOT_MATCHED_ZIP_CODE_NOT_CHECKED
    }

    class Authorization: Mappable {
      /// Unique identifier
      var id: String?
      /// Payment that the auth was opened with
      var payment: CLVData.Payments.Payment?
      /// Name of tab
      var tabName: String?
      /// Amount authorized
      var amount: Int?
      /// Type of credit card used for authorization
      var cardType: CLVData.Payments.CardType?
      /// Last 4 digits of credit card used for authorization
      var last4: String?
      /// Authorization code
      var authcode: String?
      var type: CLVData.Payments.Type?
      var note: String?
      /// Payment that the auth was closed with
      var closingPayment: CLVData.Payments.Payment?
      /// Time authorization was recorded on server
      var createdTime: NSDate?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        payment <- map["payment"]
        tabName <- map["tabName"]
        amount <- map["amount"]
        cardType <- map["cardType"]
        last4 <- map["last4"]
        authcode <- map["authcode"]
        type <- map["type"]
        note <- map["note"]
        closingPayment <- map["closingPayment"]
        createdTime <- (map["createdTime"], CLVDateTransform())
      }
    }

    class Batch: Mappable {
      var id: String?
      var merchantId: Int?
      var firstGatewayTxId: Int?
      var lastGatewayTxId: Int?
      /// The id of employee who executed batch
      var accountId: Int?
      /// The number of transactions being batched
      var txCount: Int?
      /// Total amount closed
      var totalBatchAmount: Int?
      /// List of devices in batch
      var devices: String?
      var state: CLVData.Payments.BatchState?
      var batchType: CLVData.Payments.BatchType?
      /// Created time of batch
      var createdTime: NSDate?
      /// Modified time of batch
      var modifiedTime: NSDate?
      /// Details split based on card / employees
      var batchDetails: CLVData.Payments.BatchDetail?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        merchantId <- map["merchantId"]
        firstGatewayTxId <- map["firstGatewayTxId"]
        lastGatewayTxId <- map["lastGatewayTxId"]
        accountId <- map["accountId"]
        txCount <- map["txCount"]
        totalBatchAmount <- map["totalBatchAmount"]
        devices <- map["devices"]
        state <- map["state"]
        batchType <- map["batchType"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        batchDetails <- map["batchDetails"]
      }
    }

    class BatchCardTotal: Mappable {
      var cardType: CLVData.Payments.CardType?
      /// Total count of types
      var count: Int?
      /// Total amount for type
      var total: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        cardType <- map["cardType"]
        count <- map["count"]
        total <- map["total"]
      }
    }

    class BatchDetail: Mappable {
      var batchTotals: CLVData.Payments.BatchTotalStats?
      var serverTotals: [CLVData.Payments.ServerTotalStats]?
      var cardTotals: [CLVData.Payments.BatchCardTotal]?
      /// Number of open tips.
      var openTips: Int?
      /// Number of open tabs.
      var openTabs: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        batchTotals <- map["batchTotals"]
        serverTotals <- map["serverTotals"]
        cardTotals <- map["cardTotals"]
        openTips <- map["openTips"]
        openTabs <- map["openTabs"]
      }
    }

    class BatchRequest: Mappable {
      var devices: [String]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        devices <- map["devices"]
      }
    }

    enum BatchState {
      case OPEN
      case QUEUED_FOR_PROCESSING
      case PROCESSING
      case CLOSED
      case FAILED
    }

    class BatchTotalStats: Mappable {
      var sales: CLVData.Payments.BatchTotalType?
      var refunds: CLVData.Payments.BatchTotalType?
      var net: CLVData.Payments.BatchTotalType?
      var giftCardLoads: CLVData.Payments.BatchTotalType?
      var giftCardCashOuts: CLVData.Payments.BatchTotalType?
      var tax: CLVData.Payments.BatchTotalType?
      var tips: CLVData.Payments.BatchTotalType?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }

    class BatchTotalType: Mappable {
      /// Total count of types
      var count: Int?
      /// Total amount for type
      var total: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        count <- map["count"]
        total <- map["total"]
      }
    }

    enum BatchType {
      case MANUAL_CLOSE
      case AUTO_CLOSE
    }

    enum CVVResult {
      case SUCCESS
      case FAILURE
      case NOT_PROCESSED
      case NOT_PRESENT
    }

    enum CardEntryType {
      case SWIPED
      case KEYED
      case VOICE
      case VAULTED
      case OFFLINE_SWIPED
      case OFFLINE_KEYED
      case EMV_CONTACT
      case EMV_CONTACTLESS
      case MSD_CONTACTLESS
      case PINPAD_MANUAL_ENTRY
    }

    class CardTransaction: Mappable {
      /// The payment with which the card transaction is associated
      var paymentRef: CLVData.Base.Reference?
      /// The credit with which the card transaction is associated
      var creditRef: CLVData.Base.Reference?
      var cardType: CLVData.Payments.CardType?
      var entryType: CLVData.Payments.CardEntryType?
      /// The last four digits of the credit card number
      var last4: String?
      var type: CLVData.Payments.CardTransactionType?
      /// Authorization code (if successful)
      var authCode: String?
      var referenceId: String?
      var transactionNo: String?
      var state: CLVData.Payments.CardTransactionState?
      /// Extra info to be stored as part of gateway/card transaction
      var extra: [String:String]?
      var begBalance: Int?
      var endBalance: Int?
      var avsResult: CLVData.Payments.AVSResult?
      var cardholderName: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        paymentRef <- map["paymentRef"]
        creditRef <- map["creditRef"]
        cardType <- map["cardType"]
        entryType <- map["entryType"]
        last4 <- map["last4"]
        type <- map["type"]
        authCode <- map["authCode"]
        referenceId <- map["referenceId"]
        transactionNo <- map["transactionNo"]
        state <- map["state"]
        extra <- map["extra"]
        begBalance <- map["begBalance"]
        endBalance <- map["endBalance"]
        avsResult <- map["avsResult"]
        cardholderName <- map["cardholderName"]
      }
    }

    enum CardTransactionState {
      case PENDING
      case CLOSED
    }

    enum CardTransactionType {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }

    enum CardType {
      case VISA
      case MC
      case AMEX
      case DISCOVER
      case DINERS_CLUB
      case JCB
      case MAESTRO
      case SOLO
      case LASER
      case CHINA_UNION_PAY
      case CARTE_BLANCHE
      case UNKNOWN
      case GIFT_CARD
      case EBT
    }

    class Credit: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the credit is associated
      var orderRef: CLVData.Base.Reference?
      /// Device which processed this credit
      var device: CLVData.Base.Reference?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      var tender: CLVData.Base.Tender?
      /// The employee who processed the payment
      var employee: CLVData.Base.Reference?
      /// Customer who received the credit/refund
      var customers: CLVData.Customers.Customer?
      /// Amount paid in tax
      var amount: Int?
      /// Amount paid in tax
      var taxAmount: Int?
      var taxRates: [CLVData.Payments.TaxableAmountRate]?
      /// Time payment was recorded on server
      var createdTime: NSDate?
      var clientCreatedTime: NSDate?
      /// Information about the card used for credit/debit card payments
      var cardTransaction: CLVData.Payments.CardTransaction?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        device <- map["device"]
        tender <- map["tender"]
        employee <- map["employee"]
        customers <- map["customers"]
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        taxRates <- map["taxRates"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        cardTransaction <- map["cardTransaction"]
      }
    }

    enum Currency {
      case USD
      case GBP
      case EUR
    }

    enum CvmResult {
      case NO_CVM_REQUIRED
      case SIGNATURE
      case PIN
      case ONLINE_PIN
      case SIGNATURE_AND_PIN
      case CVM_FAILED
      case DEVICE
    }

    enum GatewayTxState {
      case INITIATED
      case INITIATED_ON_AUTH
      case ACKNOWLEDGED
      case CONNECT_FAILED
      case TIMEOUT
      case FAILED
      case REVERSE_INITIATED
      case REVERSE_INITIATED_ON_AUTH
      case REVERSED
      case REVERSAL_FAILED
    }

    enum GatewayTxType {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }

    class GatewayTxs: Mappable {
      var merchantGatewayId: Int?
      var clientId: String?
      var amount: Int?
      var adjustAmount: Int?
      var taxAmount: Int?
      var tipAmount: Int?
      var currency: CLVData.Payments.Currency?
      var state: CLVData.Payments.GatewayTxState?
      var retries: Int?
      var type: CLVData.Payments.GatewayTxType?
      var entryType: CLVData.Payments.CardEntryType?
      var responseCode: String?
      var responseMessage: String?
      var first4: String?
      var last4: String?
      var cardType: CLVData.Payments.CardType?
      var refnum: String?
      var token: String?
      var authcode: String?
      var employeeId: String?
      var extra: String?
      var captured: Bool?
      var swiperSerial: String?
      var ksnPrefix: String?
      var createdTime: NSDate?
      var modifiedTime: NSDate?
      var refundId: Int?
      var paymentRefundId: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        merchantGatewayId <- map["merchantGatewayId"]
        clientId <- map["clientId"]
        amount <- map["amount"]
        adjustAmount <- map["adjustAmount"]
        taxAmount <- map["taxAmount"]
        tipAmount <- map["tipAmount"]
        currency <- map["currency"]
        state <- map["state"]
        retries <- map["retries"]
        type <- map["type"]
        entryType <- map["entryType"]
        responseCode <- map["responseCode"]
        responseMessage <- map["responseMessage"]
        first4 <- map["first4"]
        last4 <- map["last4"]
        cardType <- map["cardType"]
        refnum <- map["refnum"]
        token <- map["token"]
        authcode <- map["authcode"]
        employeeId <- map["employeeId"]
        extra <- map["extra"]
        captured <- map["captured"]
        swiperSerial <- map["swiperSerial"]
        ksnPrefix <- map["ksnPrefix"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        refundId <- map["refundId"]
        paymentRefundId <- map["paymentRefundId"]
      }
    }

    class GiftCard: Mappable {
      /// Track 2 Card Data
      var track2: String?
      /// Embossed Card Number
      var cardNumber: String?
      /// Was Account Number Manually Entered
      var isManuallyEntered: Bool?
      var deviceSerial: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        track2 <- map["track2"]
        cardNumber <- map["cardNumber"]
        isManuallyEntered <- map["isManuallyEntered"]
        deviceSerial <- map["deviceSerial"]
      }
    }

    class GiftCardResponse: Mappable {
      var txType: CLVData.Payments.TxType?
      var state: CLVData.Payments.GiftCardState?
      /// Transaction Amount
      var requestAmount: Int?
      var payment: CLVData.Payments.Payment?
      var responseMessage: String?
      var requestSuccessful: Bool?
      var accountNumber: String?
      var giftCardTxUuid: String?
      var transactionId: String?
      var referenceUuid: String?
      var authCode: String?
      var begBal: Int?
      var endBal: Int?
      var holdBal: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        txType <- map["txType"]
        state <- map["state"]
        requestAmount <- map["requestAmount"]
        payment <- map["payment"]
        responseMessage <- map["responseMessage"]
        requestSuccessful <- map["requestSuccessful"]
        accountNumber <- map["accountNumber"]
        giftCardTxUuid <- map["giftCardTxUuid"]
        transactionId <- map["transactionId"]
        referenceUuid <- map["referenceUuid"]
        authCode <- map["authCode"]
        begBal <- map["begBal"]
        endBal <- map["endBal"]
        holdBal <- map["holdBal"]
      }
    }

    enum GiftCardState {
      case INVALID
      case ACTIVATED
      case INACTIVE
    }

    class GiftCardTransaction: Mappable {
      /// Transaction Amount
      var amount: Int?
      /// Tax Amount
      var taxAmount: Int?
      var orderId: String?
      /// Gift Card
      var card: CLVData.Payments.GiftCard?
      var paymentIds: [String]?
      var ignorePayment: Bool?
      var serviceChargeAmount: CLVData.Payments.ServiceChargeAmount?
      var taxableAmountRates: [CLVData.Payments.TaxableAmountRate]?
      /// Payments that were made for this line item
      var lineItems: [CLVData.Payments.LineItemPayment]?
      var employeeId: String?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        orderId <- map["orderId"]
        card <- map["card"]
        paymentIds <- map["paymentIds"]
        ignorePayment <- map["ignorePayment"]
        serviceChargeAmount <- map["serviceChargeAmount"]
        taxableAmountRates <- map["taxableAmountRates"]
        lineItems <- map["lineItems"]
        employeeId <- map["employeeId"]
      }
    }

    class LineItemPayment: Mappable {
      /// Unique identifier; TBD this is confusing because it's used as either line item id or payment id
      var id: String?
      /// The line item with which the line item payment is associated
      var lineItemRef: CLVData.Base.Reference?
      /// The payment with which the line item payment is associated
      var paymentRef: CLVData.Base.Reference?
      /// Percent of this line item covered by this payment
      var percentage: Int?
      /// Bin this line item payment was for
      var binName: String?
      /// Payment has been refunded
      var refunded: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        lineItemRef <- map["lineItemRef"]
        paymentRef <- map["paymentRef"]
        percentage <- map["percentage"]
        binName <- map["binName"]
        refunded <- map["refunded"]
      }
    }

    class Payment: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the payment is associated
      var order: CLVData.Base.Reference?
      /// Device which processed the transaction for this payment
      var device: CLVData.Base.Reference?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      var tender: CLVData.Base.Tender?
      /// Total amount paid
      var amount: Int?
      /// Amount paid in tips
      var tipAmount: Int?
      /// Amount paid in tax
      var taxAmount: Int?
      /// Amount given back in a cash back transaction
      var cashbackAmount: Int?
      /// Amount of cash given by the customer
      var cashTendered: Int?
      var externalPaymentId: String?
      /// The employee who processed the payment
      var employee: CLVData.Base.Reference?
      /// Time payment was recorded on server
      var createdTime: NSDate?
      var clientCreatedTime: NSDate?
      /// Last modified time of the payment
      var modifiedTime: NSDate?
      var offline: Bool?
      var result: CLVData.Payments.Result?
      /// Information about the card used for credit/debit card payments
      var cardTransaction: CLVData.Payments.CardTransaction?
      /// Amount record as a service charge
      var serviceCharge: CLVData.Payments.ServiceChargeAmount?
      var taxRates: [CLVData.Payments.PaymentTaxRate]?
      var refunds: [CLVData.Payments.Refund]?
      var note: String?
      var lineItemPayments: [CLVData.Payments.LineItemPayment]?
      /// If voided, the reason why (when available)
      var voidReason: CLVData.Order.VoidReason?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        order <- map["order"]
        device <- map["device"]
        tender <- map["tender"]
        amount <- map["amount"]
        tipAmount <- map["tipAmount"]
        taxAmount <- map["taxAmount"]
        cashbackAmount <- map["cashbackAmount"]
        cashTendered <- map["cashTendered"]
        externalPaymentId <- map["externalPaymentId"]
        employee <- map["employee"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        modifiedTime <- (map["modifiedTime"], CLVDateTransform())
        offline <- map["offline"]
        result <- map["result"]
        cardTransaction <- map["cardTransaction"]
        serviceCharge <- map["serviceCharge"]
        taxRates <- map["taxRates"]
        refunds <- map["refunds"]
        note <- map["note"]
        lineItemPayments <- map["lineItemPayments"]
        voidReason <- map["voidReason"]
      }
    }

    class PaymentResponse: Mappable {
      var requestSuccessful: Bool?
      var responseErrorMessage: String?
      var payment: CLVData.Payments.Payment?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        requestSuccessful <- map["requestSuccessful"]
        responseErrorMessage <- map["responseErrorMessage"]
        payment <- map["payment"]
      }
    }

    class PaymentTaxRate: Mappable {
      var id: String?
      /// The payment with which the payment tax rate is associated
      var paymentRef: CLVData.Base.Reference?
      var name: String?
      var rate: Int?
      var isDefault: Bool?
      var taxableAmount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        paymentRef <- map["paymentRef"]
        name <- map["name"]
        rate <- map["rate"]
        isDefault <- map["isDefault"]
        taxableAmount <- map["taxableAmount"]
      }
    }

    class Refund: Mappable {
      /// Unique identifier
      var id: String?
      /// The order with which the refund is associated
      var orderRef: CLVData.Base.Reference?
      /// Device which processed the transaction for this refund
      var device: CLVData.Base.Reference?
      /// Total amount refunded, including tax
      var amount: Int?
      /// Tax amount refunded
      var taxAmount: Int?
      /// The time when the refund was recorded on the server
      var createdTime: NSDate?
      /// The time when the refund was recorded on the client
      var clientCreatedTime: NSDate?
      /// The payment with which the refund is associated
      var payment: CLVData.Base.Reference?
      var employee: CLVData.Base.Reference?
      var lineItems: [CLVData.Base.Reference]?
      /// The tender type associated with this payment, e.g. credit card, cash, etc.
      var overrideMerchantTender: CLVData.Base.Tender?
      var taxableAmountRates: [CLVData.Payments.TaxableAmountRate]?
      var serviceChargeAmount: CLVData.Payments.ServiceChargeAmount?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        orderRef <- map["orderRef"]
        device <- map["device"]
        amount <- map["amount"]
        taxAmount <- map["taxAmount"]
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        payment <- map["payment"]
        employee <- map["employee"]
        lineItems <- map["lineItems"]
        overrideMerchantTender <- map["overrideMerchantTender"]
        taxableAmountRates <- map["taxableAmountRates"]
        serviceChargeAmount <- map["serviceChargeAmount"]
      }
    }

    enum Result {
      case SUCCESS
      case FAIL
      case INITIATED
      case VOIDED
      case VOIDING
      case AUTH
    }

    class ServerTotalStats: Mappable {
      /// Employee corresponding to these stats
      var employeeId: String?
      var employeeName: String?
      var sales: CLVData.Payments.BatchTotalType?
      var refunds: CLVData.Payments.BatchTotalType?
      var net: CLVData.Payments.BatchTotalType?
      var giftCardLoads: CLVData.Payments.BatchTotalType?
      var giftCardCashOuts: CLVData.Payments.BatchTotalType?
      var tax: CLVData.Payments.BatchTotalType?
      var tips: CLVData.Payments.BatchTotalType?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        employeeId <- map["employeeId"]
        employeeName <- map["employeeName"]
        sales <- map["sales"]
        refunds <- map["refunds"]
        net <- map["net"]
        giftCardLoads <- map["giftCardLoads"]
        giftCardCashOuts <- map["giftCardCashOuts"]
        tax <- map["tax"]
        tips <- map["tips"]
      }
    }

    class ServiceChargeAmount: Mappable {
      var id: String?
      var name: String?
      var amount: Int?
      /// The payment with which the payment tax rate is associated
      var paymentRef: CLVData.Base.Reference?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        amount <- map["amount"]
        paymentRef <- map["paymentRef"]
      }
    }

    class TaxableAmountRate: Mappable {
      var id: String?
      var name: String?
      var taxableAmount: Int?
      var rate: Int?
      var isVat: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        taxableAmount <- map["taxableAmount"]
        rate <- map["rate"]
        isVat <- map["isVat"]
      }
    }

    class Transaction: Mappable {
      /// The time when the transaction was recorded on the server
      var createdTime: NSDate?
      /// The time when the transaction was recorded on the client
      var clientCreatedTime: NSDate?
      var payment: CLVData.Payments.Payment?
      var refund: CLVData.Payments.Refund?
      var credit: CLVData.Payments.Credit?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        createdTime <- (map["createdTime"], CLVDateTransform())
        clientCreatedTime <- (map["clientCreatedTime"], CLVDateTransform())
        payment <- map["payment"]
        refund <- map["refund"]
        credit <- map["credit"]
      }
    }

    enum TxType {
      case AUTH
      case PREAUTH
      case PREAUTHCAPTURE
      case ADJUST
      case VOID
      case VOIDRETURN
      case RETURN
      case REFUND
      case NAKEDREFUND
      case GETBALANCE
      case BATCHCLOSE
      case ACTIVATE
      case BALANCE_LOCK
      case LOAD
      case CASHOUT
      case CASHOUT_ACTIVE_STATUS
      case REDEMPTION
      case REDEMPTION_UNLOCK
      case RELOAD
    }

    enum Type {
      case TAB
      case AUTH
    }
  }

  class Printer {

    class Printer: Mappable {
      /// Unique identifier
      var id: String?
      /// MAC address of a network printer
      var mac: String?
      var model: String?
      var name: String?
      /// IP address of a network printer
      var ipAddress: String?
      /// NETWORK is a printer that's directly connected to the network.  MY_LOCAL represents the printer that's connected to the device that's making the request.
      var type: CLVData.Printer.PrinterType?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        mac <- map["mac"]
        model <- map["model"]
        name <- map["name"]
        ipAddress <- map["ipAddress"]
        type <- map["type"]
      }
    }

    enum PrinterType {
      case NETWORK
      case MY_LOCAL
    }
  }

  class Report {

    class CardType: Mappable {
      var type: String?
      var amount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        type <- map["type"]
        amount <- map["amount"]
      }
    }

    class Category: Mappable {
      var id: String?
      var name: String?
      var items: [CLVData.Report.Item]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        items <- map["items"]
      }
    }

    class Discount: Mappable {
      var id: String?
      var name: String?
      var numberSold: Double?
      var amountSold: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        numberSold <- map["numberSold"]
        amountSold <- map["amountSold"]
      }
    }

    class EmployeeSummary: Mappable {
      var name: String?
      var employee: CLVData.Employees.Employee?
      var numPayments: Int?
      var paymentsAmount: Int?
      var numRefunds: Int?
      var refundsAmount: Int?
      var numCredits: Int?
      var creditsAmount: Int?
      var tipsDue: Int?
      var serviceCharges: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        name <- map["name"]
        employee <- map["employee"]
        numPayments <- map["numPayments"]
        paymentsAmount <- map["paymentsAmount"]
        numRefunds <- map["numRefunds"]
        refundsAmount <- map["refundsAmount"]
        numCredits <- map["numCredits"]
        creditsAmount <- map["creditsAmount"]
        tipsDue <- map["tipsDue"]
        serviceCharges <- map["serviceCharges"]
      }
    }

    class Item: Mappable {
      var id: String?
      var name: String?
      var numberSold: Double?
      var amountSold: Int?
      var numberRefunds: Double?
      var amountRefunds: Int?
      var numberExchanges: Double?
      var amountExchanged: Int?
      var discounts: [CLVData.Report.Discount]?
      var modifiers: [CLVData.Report.Modifier]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        numberSold <- map["numberSold"]
        amountSold <- map["amountSold"]
        numberRefunds <- map["numberRefunds"]
        amountRefunds <- map["amountRefunds"]
        numberExchanges <- map["numberExchanges"]
        amountExchanged <- map["amountExchanged"]
        discounts <- map["discounts"]
        modifiers <- map["modifiers"]
      }
    }

    class Modifier: Mappable {
      var id: String?
      var name: String?
      var numberSold: Double?
      var amountSold: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        numberSold <- map["numberSold"]
        amountSold <- map["amountSold"]
      }
    }

    class Report: Mappable {
      /// Reports By Payments
      var payments: CLVData.Report.ReportPayments?
      /// Reports By Items
      var items: CLVData.Report.ReportItems?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        payments <- map["payments"]
        items <- map["items"]
      }
    }

    class ReportEmployee: Mappable {
      /// Unique identifier
      var id: String?
      /// The employee being reported on
      var employee: CLVData.Base.Reference?
      /// Number and amounts for payments processed
      var paymentSummary: CLVData.Report.RevenueSummary?
      /// Number and amounts for refunds processed
      var refundSummary: CLVData.Report.RevenueSummary?
      /// Number and amounts for credits processed
      var creditSummary: CLVData.Report.RevenueSummary?
      /// The time range for which the report is generated
      var timeRange: CLVData.Report.TimeRange?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        employee <- map["employee"]
        paymentSummary <- map["paymentSummary"]
        refundSummary <- map["refundSummary"]
        creditSummary <- map["creditSummary"]
        timeRange <- map["timeRange"]
      }
    }

    class ReportItems: Mappable {
      var categories: [CLVData.Report.Category]?
      /// The time range for which the report is generated
      var timeRange: CLVData.Report.TimeRange?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        categories <- map["categories"]
        timeRange <- map["timeRange"]
      }
    }

    class ReportPayments: Mappable {
      /// Number and amounts for payments processed
      var paymentSummary: CLVData.Report.RevenueSummary?
      /// Number and amounts for refunds processed
      var refundSummary: CLVData.Report.RevenueSummary?
      /// Number and amounts for credits processed
      var creditSummary: CLVData.Report.RevenueSummary?
      /// Breakdown by employee
      var employeeSummary: [CLVData.Report.EmployeeSummary]?
      /// The time range for which the report is generated
      var timeRange: CLVData.Report.TimeRange?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        paymentSummary <- map["paymentSummary"]
        refundSummary <- map["refundSummary"]
        creditSummary <- map["creditSummary"]
        employeeSummary <- map["employeeSummary"]
        timeRange <- map["timeRange"]
      }
    }

    class ReportTaxes: Mappable {
      /// Taxes for payments processed
      var paymentSummary: [CLVData.Report.TaxableRateSummary]?
      /// Taxes for refunds processed
      var refundSummary: [CLVData.Report.TaxableRateSummary]?
      /// Taxes for credits processed
      var creditSummary: [CLVData.Report.TaxableRateSummary]?
      /// The time range for which the report is generated
      var timeRange: CLVData.Report.TimeRange?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        paymentSummary <- map["paymentSummary"]
        refundSummary <- map["refundSummary"]
        creditSummary <- map["creditSummary"]
        timeRange <- map["timeRange"]
      }
    }

    class RevenueSummary: Mappable {
      var num: Int?
      var amount: Int?
      var tipAmount: Int?
      var taxAmount: Int?
      var serviceChargeAmount: Int?
      /// Split by tender type
      var byTender: [CLVData.Report.TenderStats]?
      /// Split by credit card type
      var byCardType: [CLVData.Report.CardType]?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        num <- map["num"]
        amount <- map["amount"]
        tipAmount <- map["tipAmount"]
        taxAmount <- map["taxAmount"]
        serviceChargeAmount <- map["serviceChargeAmount"]
        byTender <- map["byTender"]
        byCardType <- map["byCardType"]
      }
    }

    class Summary: Mappable {
      var num: Int?
      var amount: Int?
      var tipAmount: Int?
      var taxAmount: Int?
      var serviceChargeAmount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        num <- map["num"]
        amount <- map["amount"]
        tipAmount <- map["tipAmount"]
        taxAmount <- map["taxAmount"]
        serviceChargeAmount <- map["serviceChargeAmount"]
      }
    }

    class SummaryGroup: Mappable {
      var id: String?
      var summaryObject: CLVData.Base.Reference?
      var paymentsSummary: CLVData.Report.Summary?
      var refundsSummary: CLVData.Report.Summary?
      var creditsSummary: CLVData.Report.Summary?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        summaryObject <- map["summaryObject"]
        paymentsSummary <- map["paymentsSummary"]
        refundsSummary <- map["refundsSummary"]
        creditsSummary <- map["creditsSummary"]
      }
    }

    class SummaryMerchantCharges: Mappable {
      var currency: String?
      var num: Int?
      var totalAmount: Int?
      var totalTax: Int?
      var totalDeveloperPortion: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        currency <- map["currency"]
        num <- map["num"]
        totalAmount <- map["totalAmount"]
        totalTax <- map["totalTax"]
        totalDeveloperPortion <- map["totalDeveloperPortion"]
      }
    }

    class TaxableRateSummary: Mappable {
      var id: String?
      var name: String?
      var taxableAmount: Int?
      var rate: Int?
      var isVat: Bool?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        id <- map["id"]
        name <- map["name"]
        taxableAmount <- map["taxableAmount"]
        rate <- map["rate"]
        isVat <- map["isVat"]
      }
    }

    class TenderStats: Mappable {
      var type: String?
      var amount: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        type <- map["type"]
        amount <- map["amount"]
      }
    }

    class TimeRange: Mappable {
      var start: Int?
      var end: Int?
      
      init() {}
      required init?(_ map: Map) {}

      // Mappable
      func mapping(map: Map) {
        start <- map["start"]
        end <- map["end"]
      }
    }
  }

}
