/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Order {

    public class OrderExpansion: Codable {

        /// Unique identifier
        public var id: String?
        /// True if order has credit.
        public var hasCredit: Bool?
        /// True if order has credit.
        public var hasCreditCardTransaction: Bool?
        /// True if order has customer
        public var hasCustomer: Bool?
        /// True if customer has email address
        public var hasCustomerEmailAddress: Bool?
        /// True if customer has address
        public var hasCustomerAddress: Bool?
        /// True if customer has phone
        public var hasCustomerPhone: Bool?
        /// True if order has discount
        public var hasDiscount: Bool?
        /// True if order has line item discount
        public var hasLineItemDiscount: Bool?
        /// Check for order has service charge
        public var hasServiceCharge: Bool?
        /// True if order has a refund
        public var hasRefund: Bool?
        /// True if order has void
        public var hasVoid: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case hasCredit
            case hasCreditCardTransaction
            case hasCustomer
            case hasCustomerEmailAddress
            case hasCustomerAddress
            case hasCustomerPhone
            case hasDiscount
            case hasLineItemDiscount
            case hasServiceCharge
            case hasRefund
            case hasVoid
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCredit = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCredit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCreditCardTransaction = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCreditCardTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCustomer = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCustomer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCustomerEmailAddress = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCustomerEmailAddress)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCustomerAddress = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCustomerAddress)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasCustomerPhone = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasCustomerPhone)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasDiscount = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasDiscount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasLineItemDiscount = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasLineItemDiscount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasServiceCharge = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasServiceCharge)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasRefund = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasRefund)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasVoid = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasVoid)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (hasCredit != nil) { try container.encode(hasCredit, forKey: .hasCredit) }
            if (hasCreditCardTransaction != nil) { try container.encode(hasCreditCardTransaction, forKey: .hasCreditCardTransaction) }
            if (hasCustomer != nil) { try container.encode(hasCustomer, forKey: .hasCustomer) }
            if (hasCustomerEmailAddress != nil) { try container.encode(hasCustomerEmailAddress, forKey: .hasCustomerEmailAddress) }
            if (hasCustomerAddress != nil) { try container.encode(hasCustomerAddress, forKey: .hasCustomerAddress) }
            if (hasCustomerPhone != nil) { try container.encode(hasCustomerPhone, forKey: .hasCustomerPhone) }
            if (hasDiscount != nil) { try container.encode(hasDiscount, forKey: .hasDiscount) }
            if (hasLineItemDiscount != nil) { try container.encode(hasLineItemDiscount, forKey: .hasLineItemDiscount) }
            if (hasServiceCharge != nil) { try container.encode(hasServiceCharge, forKey: .hasServiceCharge) }
            if (hasRefund != nil) { try container.encode(hasRefund, forKey: .hasRefund) }
            if (hasVoid != nil) { try container.encode(hasVoid, forKey: .hasVoid) }
        }
    }

}