/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Order {

    public class OrderType: Codable {

        /// Unique identifier
        public var id: String?
        /// Label Key
        public var labelKey: String?
        /// Label Key
        public var label: String?
        /// If this order type is taxable
        public var taxable: Bool?
        /// If this order type is the default
        public var isDefault: Bool?
        /// If set to false, then this order type includes all of the merchant's categories. Otherwise, it only contains the categories defined in the "categories" field on this object.
        public var filterCategories: Bool?
        /// If this order type is hidden on the register
        public var isHidden: Bool?
        /// The price of a fee added to this order type, not fully implemented at this time.
        public var fee: CLVModels.Variant?
        /// The minimum amount required for an order to be placed
        public var minOrderAmount: CLVModels.Variant?
        /// The maximum amount for an order allowed
        public var maxOrderAmount: CLVModels.Variant?
        /// The maximum radius allowed for an order (i.e. delivery)
        public var maxRadius: CLVModels.Variant?
        /// The average time it takes to complete the order
        public var avgOrderTime: Date?
        public var hoursAvailable: CLVModels.Order.HoursAvailable?
        public var customerIdMethod: CLVModels.Order.CustomerIdMethod?
        /// If this order type is deleted
        public var isDeleted: Bool?
        /// Optional system order type that this order type is associated with.
        public var systemOrderTypeId: String?
        /// The system_order_type table's database ID. Internal only. The ID mentioned above is the UUID.
        public var systemOrderTypeDatabaseId: Int64?
        /// The hours this order type is available (if they differ from normal merchant hours)
        public var hours: CLVModels.Hours.HoursSet?
        /// The categories of items that can be assigned to this order type
        public var categories: [CLVModels.Base.Reference]?
        /// Optional: the online order services that this order type can map to if there are online order providers enabled on this merchant.
        public var onlineOrderServices: [CLVModels.Base.Reference]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case labelKey
            case label
            case taxable
            case isDefault
            case filterCategories
            case isHidden
            case fee
            case minOrderAmount
            case maxOrderAmount
            case maxRadius
            case avgOrderTime
            case hoursAvailable
            case customerIdMethod
            case isDeleted
            case systemOrderTypeId
            case systemOrderTypeDatabaseId
            case hours
            case categories
            case onlineOrderServices
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.labelKey = try rootContainer.decodeIfPresent(String.self, forKey: .labelKey)
            } catch {
                decodeError.append(error)
            }
            do {
                self.label = try rootContainer.decodeIfPresent(String.self, forKey: .label)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxable = try rootContainer.decodeIfPresent(Bool.self, forKey: .taxable)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isDefault = try rootContainer.decodeIfPresent(Bool.self, forKey: .isDefault)
            } catch {
                decodeError.append(error)
            }
            do {
                self.filterCategories = try rootContainer.decodeIfPresent(Bool.self, forKey: .filterCategories)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isHidden = try rootContainer.decodeIfPresent(Bool.self, forKey: .isHidden)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fee = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .fee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.minOrderAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .minOrderAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maxOrderAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .maxOrderAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maxRadius = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .maxRadius)
            } catch {
                decodeError.append(error)
            }
            do {
                self.avgOrderTime = try rootContainer.decodeIfPresent(Date.self, forKey: .avgOrderTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hoursAvailable = try rootContainer.decodeIfPresent(CLVModels.Order.HoursAvailable.self, forKey: .hoursAvailable)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerIdMethod = try rootContainer.decodeIfPresent(CLVModels.Order.CustomerIdMethod.self, forKey: .customerIdMethod)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isDeleted = try rootContainer.decodeIfPresent(Bool.self, forKey: .isDeleted)
            } catch {
                decodeError.append(error)
            }
            do {
                self.systemOrderTypeId = try rootContainer.decodeIfPresent(String.self, forKey: .systemOrderTypeId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.systemOrderTypeDatabaseId = try rootContainer.decodeIfPresent(Int64.self, forKey: .systemOrderTypeDatabaseId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hours = try rootContainer.decodeIfPresent(CLVModels.Hours.HoursSet.self, forKey: .hours)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.categories)) {
                do {
                    let categoriesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .categories)
                    self.categories = try categoriesContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.onlineOrderServices)) {
                do {
                    let onlineOrderServicesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .onlineOrderServices)
                    self.onlineOrderServices = try onlineOrderServicesContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (labelKey != nil) { try container.encode(labelKey, forKey: .labelKey) }
            if (label != nil) { try container.encode(label, forKey: .label) }
            if (taxable != nil) { try container.encode(taxable, forKey: .taxable) }
            if (isDefault != nil) { try container.encode(isDefault, forKey: .isDefault) }
            if (filterCategories != nil) { try container.encode(filterCategories, forKey: .filterCategories) }
            if (isHidden != nil) { try container.encode(isHidden, forKey: .isHidden) }
            if (fee != nil) { try container.encode(fee, forKey: .fee) }
            if (minOrderAmount != nil) { try container.encode(minOrderAmount, forKey: .minOrderAmount) }
            if (maxOrderAmount != nil) { try container.encode(maxOrderAmount, forKey: .maxOrderAmount) }
            if (maxRadius != nil) { try container.encode(maxRadius, forKey: .maxRadius) }
            if (avgOrderTime != nil) { try container.encode(avgOrderTime, forKey: .avgOrderTime) }
            if (hoursAvailable != nil) { try container.encode(hoursAvailable, forKey: .hoursAvailable) }
            if (customerIdMethod != nil) { try container.encode(customerIdMethod, forKey: .customerIdMethod) }
            if (isDeleted != nil) { try container.encode(isDeleted, forKey: .isDeleted) }
            if (systemOrderTypeId != nil) { try container.encode(systemOrderTypeId, forKey: .systemOrderTypeId) }
            if (systemOrderTypeDatabaseId != nil) { try container.encode(systemOrderTypeDatabaseId, forKey: .systemOrderTypeDatabaseId) }
            if (hours != nil) { try container.encode(hours, forKey: .hours) }
            if (categories != nil) { try container.encode(categories, forKey: .categories) }
            if (onlineOrderServices != nil) { try container.encode(onlineOrderServices, forKey: .onlineOrderServices) }
        }
    }

}