/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Order {

    public class DisplayLineItem: Codable {

        /// Unique identifier
        public var id: String?
        /// The order with which the line item is associated
        public var orderId: String?
        /// Line item name
        public var name: CLVModels.Variant?
        /// Alternate name of the line item
        public var alternateName: CLVModels.Variant?
        /// Formatted total price of the line item
        public var price: String?
        /// Formatted unit price in cases if applicable
        public var unitPrice: String?
        /// Formatted quantity
        public var quantity: CLVModels.Variant?
        /// Formatted unit quantity - such as 10 @ $1.99/oz
        public var unitQuantity: CLVModels.Variant?
        public var note: CLVModels.Variant?
        public var printed: Bool?
        public var binName: CLVModels.Variant?
        public var userData: CLVModels.Variant?
        public var discounts: [CLVModels.Order.DisplayDiscount]?
        public var discountAmount: CLVModels.Variant?
        public var exchanged: Bool?
        /// Formatted exchanged amount
        public var exchangedAmount: CLVModels.Variant?
        public var modifications: [CLVModels.Order.DisplayModification]?
        public var refunded: Bool?
        /// Formatted refunded amount
        public var refundedAmount: CLVModels.Variant?
        public var percent: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderId
            case name
            case alternateName
            case price
            case unitPrice
            case quantity
            case unitQuantity
            case note
            case printed
            case binName
            case userData
            case discounts
            case discountAmount
            case exchanged
            case exchangedAmount
            case modifications
            case refunded
            case refundedAmount
            case percent
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderId = try rootContainer.decodeIfPresent(String.self, forKey: .orderId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.alternateName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .alternateName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.price = try rootContainer.decodeIfPresent(String.self, forKey: .price)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unitPrice = try rootContainer.decodeIfPresent(String.self, forKey: .unitPrice)
            } catch {
                decodeError.append(error)
            }
            do {
                self.quantity = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .quantity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unitQuantity = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unitQuantity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.note = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            do {
                self.printed = try rootContainer.decodeIfPresent(Bool.self, forKey: .printed)
            } catch {
                decodeError.append(error)
            }
            do {
                self.binName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .binName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.userData = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .userData)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.discounts)) {
                do {
                    let discountsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .discounts)
                    self.discounts = try discountsContainer.decodeIfPresent([CLVModels.Order.DisplayDiscount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.discountAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .discountAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchanged = try rootContainer.decodeIfPresent(Bool.self, forKey: .exchanged)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchangedAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .exchangedAmount)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.modifications)) {
                do {
                    let modificationsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .modifications)
                    self.modifications = try modificationsContainer.decodeIfPresent([CLVModels.Order.DisplayModification].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.refunded = try rootContainer.decodeIfPresent(Bool.self, forKey: .refunded)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundedAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .refundedAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.percent = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .percent)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderId != nil) { try container.encode(orderId, forKey: .orderId) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (alternateName != nil) { try container.encode(alternateName, forKey: .alternateName) }
            if (price != nil) { try container.encode(price, forKey: .price) }
            if (unitPrice != nil) { try container.encode(unitPrice, forKey: .unitPrice) }
            if (quantity != nil) { try container.encode(quantity, forKey: .quantity) }
            if (unitQuantity != nil) { try container.encode(unitQuantity, forKey: .unitQuantity) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (printed != nil) { try container.encode(printed, forKey: .printed) }
            if (binName != nil) { try container.encode(binName, forKey: .binName) }
            if (userData != nil) { try container.encode(userData, forKey: .userData) }
            if (discounts != nil) { try container.encode(discounts, forKey: .discounts) }
            if (discountAmount != nil) { try container.encode(discountAmount, forKey: .discountAmount) }
            if (exchanged != nil) { try container.encode(exchanged, forKey: .exchanged) }
            if (exchangedAmount != nil) { try container.encode(exchangedAmount, forKey: .exchangedAmount) }
            if (modifications != nil) { try container.encode(modifications, forKey: .modifications) }
            if (refunded != nil) { try container.encode(refunded, forKey: .refunded) }
            if (refundedAmount != nil) { try container.encode(refundedAmount, forKey: .refundedAmount) }
            if (percent != nil) { try container.encode(percent, forKey: .percent) }
        }
    }

}