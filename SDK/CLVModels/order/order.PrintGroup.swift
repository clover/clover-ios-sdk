/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    Groups together a set of line items to display under a heading on receipts.
*/

import Foundation

extension CLVModels.Order {

    public class PrintGroup: Codable {

        /// Unique identifier.
        public var id: String?
        /// Reference to the order associated with this PrintGroup.
        public var orderRef: CLVModels.Base.Reference?
        /// The print group heading that will be displayed on receipts.
        public var name: String?
        /// The order in which this print group is displayed relative to other print groups on the same receipt. Print groups with identical sort orders will be ordered by name.
        public var sortOrder: CLVModels.Variant?
        /// True if this print group has been sent to an order printer.
        public var fired: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderRef
            case name
            case sortOrder
            case fired
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .orderRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sortOrder = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .sortOrder)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fired = try rootContainer.decodeIfPresent(Bool.self, forKey: .fired)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderRef != nil) { try container.encode(orderRef, forKey: .orderRef) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (sortOrder != nil) { try container.encode(sortOrder, forKey: .sortOrder) }
            if (fired != nil) { try container.encode(fired, forKey: .fired) }
        }
    }

}