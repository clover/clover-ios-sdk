/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Order {

    public class LineItem: Codable {

        /// Unique identifier.
        public var id: String?
        /// Reference to the order with which the line item is associated.
        public var orderRef: CLVModels.Base.Reference?
        /// A reference to the inventory item that was used to create this line item. Note that since this a reference the item can be changed and deleted any time such that it no longer matches this line item.
        public var item: CLVModels.Variant?
        /// Line item name.
        public var name: CLVModels.Variant?
        /// Alternate name of the line item.
        public var alternateName: CLVModels.Variant?
        /// Price of the item, typically in cents of merchant currency. When unit quantity is not null then this is the price for a single unit and is not the complete price.
        public var price: Int64?
        /// Price of item after adding all modifications. This is used only for reporting.
        public var priceWithModifiers: Int64?
        /// Price of item after adding all modifications and subtracting all line item and order level discounts. This is used only for reporting.
        public var priceWithModifiersAndItemAndOrderDiscounts: Int64?
        /// Unit quantity if this line item is priced by quantity, or null if the item is not priced by quantity. The value is a fixed-point integer with scaling factor of 1000 (e.g. if charging by ounces then the value should be set to 2500 for 2.5 ounces). To compute the complete price perform the following calculation: PRICE * (UNIT QTY / 1000).
        public var unitQty: CLVModels.Variant?
        /// Unit name (e.g. oz, lb, etc) if priced by unit, otherwise null.
        public var unitName: CLVModels.Variant?
        public var itemCode: CLVModels.Variant?
        public var note: CLVModels.Variant?
        /// True if this line item has been printed out on an order printer at least once already.
        public var printed: Bool?
        public var exchangedLineItem: CLVModels.Variant?
        public var binName: CLVModels.Variant?
        public var userData: CLVModels.Variant?
        public var createdTime: Date?
        public var orderClientCreatedTime: Date?
        /// List of discounts applied to the line item. Each line item on an order may have zero or more percentage or amount discounts. Line item discounts are separate from order-level discounts (which are applied to the order subtotal).
        public var discounts: [CLVModels.Order.Discount]?
        /// List of order level discounts attributed to this line item. Amounts are rounded to the nearest penny. This is for reporting purposes only. These rounding approximates are not used when calculating the transaction.
        public var orderLevelDiscounts: [CLVModels.Order.Discount]?
        /// Unnamed fixed discount amount in cents. Or, in reporting, this may be the calculated sum of all the line item discounts.
        public var discountAmount: CLVModels.Variant?
        /// The calculated sum of order level discounts attributed, approximately to the nearest cent, to this the line item. This is only used in reporting.
        public var orderLevelDiscountAmount: Int64?
        public var exchanged: Bool?
        /// List of references to modifications applied to this line item.
        public var modifications: [CLVModels.Order.Modification]?
        /// List of tags associated with this line item.
        public var tags: [CLVModels.Inventory.Tag]?
        /// True if this line item has been refunded
        public var refunded: Bool?
        /// direct item refund
        public var refund: CLVModels.Payments.Refund?
        /// True if this item should be counted as revenue, for example gift cards and donations would not.
        public var isRevenue: Bool?
        /// Tax rates that apply to this line item
        public var taxRates: [CLVModels.Inventory.TaxRate]?
        /// Payments that apply to this line item
        public var payments: [CLVModels.Payments.LineItemPayment]?
        /// Revenue collected for this. This field is only used in reporting.
        public var revenueAmount: Int64?
        /// Quantity sold for this line item. This field is only used in reporting
        public var quantitySold: Double?
        /// Optional reference to the print group that this line item belongs to.
        public var printGroup: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderRef
            case item
            case name
            case alternateName
            case price
            case priceWithModifiers
            case priceWithModifiersAndItemAndOrderDiscounts
            case unitQty
            case unitName
            case itemCode
            case note
            case printed
            case exchangedLineItem
            case binName
            case userData
            case createdTime
            case orderClientCreatedTime
            case discounts
            case orderLevelDiscounts
            case discountAmount
            case orderLevelDiscountAmount
            case exchanged
            case modifications
            case tags
            case refunded
            case refund
            case isRevenue
            case taxRates
            case payments
            case revenueAmount
            case quantitySold
            case printGroup
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .orderRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.item = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .item)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.alternateName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .alternateName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.price = try rootContainer.decodeIfPresent(Int64.self, forKey: .price)
            } catch {
                decodeError.append(error)
            }
            do {
                self.priceWithModifiers = try rootContainer.decodeIfPresent(Int64.self, forKey: .priceWithModifiers)
            } catch {
                decodeError.append(error)
            }
            do {
                self.priceWithModifiersAndItemAndOrderDiscounts = try rootContainer.decodeIfPresent(Int64.self, forKey: .priceWithModifiersAndItemAndOrderDiscounts)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unitQty = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unitQty)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unitName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unitName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.itemCode = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .itemCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.note = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            do {
                self.printed = try rootContainer.decodeIfPresent(Bool.self, forKey: .printed)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchangedLineItem = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .exchangedLineItem)
            } catch {
                decodeError.append(error)
            }
            do {
                self.binName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .binName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.userData = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .userData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderClientCreatedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .orderClientCreatedTime)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.discounts)) {
                do {
                    let discountsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .discounts)
                    self.discounts = try discountsContainer.decodeIfPresent([CLVModels.Order.Discount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.orderLevelDiscounts)) {
                do {
                    let orderLevelDiscountsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .orderLevelDiscounts)
                    self.orderLevelDiscounts = try orderLevelDiscountsContainer.decodeIfPresent([CLVModels.Order.Discount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.discountAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .discountAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderLevelDiscountAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .orderLevelDiscountAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchanged = try rootContainer.decodeIfPresent(Bool.self, forKey: .exchanged)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.modifications)) {
                do {
                    let modificationsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .modifications)
                    self.modifications = try modificationsContainer.decodeIfPresent([CLVModels.Order.Modification].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.tags)) {
                do {
                    let tagsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tags)
                    self.tags = try tagsContainer.decodeIfPresent([CLVModels.Inventory.Tag].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.refunded = try rootContainer.decodeIfPresent(Bool.self, forKey: .refunded)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refund = try rootContainer.decodeIfPresent(CLVModels.Payments.Refund.self, forKey: .refund)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isRevenue = try rootContainer.decodeIfPresent(Bool.self, forKey: .isRevenue)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent([CLVModels.Inventory.TaxRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.payments)) {
                do {
                    let paymentsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .payments)
                    self.payments = try paymentsContainer.decodeIfPresent([CLVModels.Payments.LineItemPayment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.revenueAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .revenueAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.quantitySold = try rootContainer.decodeIfPresent(Double.self, forKey: .quantitySold)
            } catch {
                decodeError.append(error)
            }
            do {
                self.printGroup = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .printGroup)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderRef != nil) { try container.encode(orderRef, forKey: .orderRef) }
            if (item != nil) { try container.encode(item, forKey: .item) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (alternateName != nil) { try container.encode(alternateName, forKey: .alternateName) }
            if (price != nil) { try container.encode(price, forKey: .price) }
            if (priceWithModifiers != nil) { try container.encode(priceWithModifiers, forKey: .priceWithModifiers) }
            if (priceWithModifiersAndItemAndOrderDiscounts != nil) { try container.encode(priceWithModifiersAndItemAndOrderDiscounts, forKey: .priceWithModifiersAndItemAndOrderDiscounts) }
            if (unitQty != nil) { try container.encode(unitQty, forKey: .unitQty) }
            if (unitName != nil) { try container.encode(unitName, forKey: .unitName) }
            if (itemCode != nil) { try container.encode(itemCode, forKey: .itemCode) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (printed != nil) { try container.encode(printed, forKey: .printed) }
            if (exchangedLineItem != nil) { try container.encode(exchangedLineItem, forKey: .exchangedLineItem) }
            if (binName != nil) { try container.encode(binName, forKey: .binName) }
            if (userData != nil) { try container.encode(userData, forKey: .userData) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (orderClientCreatedTime != nil) { try container.encode(orderClientCreatedTime, forKey: .orderClientCreatedTime) }
            if (discounts != nil) { try container.encode(discounts, forKey: .discounts) }
            if (orderLevelDiscounts != nil) { try container.encode(orderLevelDiscounts, forKey: .orderLevelDiscounts) }
            if (discountAmount != nil) { try container.encode(discountAmount, forKey: .discountAmount) }
            if (orderLevelDiscountAmount != nil) { try container.encode(orderLevelDiscountAmount, forKey: .orderLevelDiscountAmount) }
            if (exchanged != nil) { try container.encode(exchanged, forKey: .exchanged) }
            if (modifications != nil) { try container.encode(modifications, forKey: .modifications) }
            if (tags != nil) { try container.encode(tags, forKey: .tags) }
            if (refunded != nil) { try container.encode(refunded, forKey: .refunded) }
            if (refund != nil) { try container.encode(refund, forKey: .refund) }
            if (isRevenue != nil) { try container.encode(isRevenue, forKey: .isRevenue) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (payments != nil) { try container.encode(payments, forKey: .payments) }
            if (revenueAmount != nil) { try container.encode(revenueAmount, forKey: .revenueAmount) }
            if (quantitySold != nil) { try container.encode(quantitySold, forKey: .quantitySold) }
            if (printGroup != nil) { try container.encode(printGroup, forKey: .printGroup) }
        }
    }

}