/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    The Order object is at the core of Clover’s transaction data. Almost every transaction either creates or updates an Order. When an order is created or updated via one of the Clover SDKs, the order data is automatically synchronized between the Clover Server and the merchant’s Clover devices.
*/

import Foundation

extension CLVModels.Order {

    public class Order: Codable {

        /// Unique identifier
        public var id: String?
        /// Currency of this order. For example, "USD"
        public var currency: String?
        public var customerId: Int64?
        public var customerUuid: String?
        public var orderTypeId: Int64?
        /// List of customers associated with this order.
        public var customers: [CLVModels.Customers.Customer]?
        /// The employee who took this order
        public var employee: CLVModels.Variant?
        /// Total price of the order in cents
        public var total: CLVModels.Variant?
        /// External reference id if present in the order
        public var externalReferenceId: CLVModels.Variant?
        /// The net of orders with payment minus the amount collected. Includes refunds, manual refunds, tax, tip, service charge, non-revenue items, paid gift card activations and loads and discounts
        public var unpaidBalance: CLVModels.Variant?
        /// Is this order paid or not?
        public var paymentState: CLVModels.Variant?
        public var title: CLVModels.Variant?
        /// An arbitrary string with information about this order, may be printed on the order receipt and displayed in apps
        public var note: CLVModels.Variant?
        public var orderType: CLVModels.Variant?
        /// If true then this order should not have taxes applied to it
        public var taxRemoved: Bool?
        /// This order was created by merchant with VAT enabled.
        public var isVat: Bool?
        /// A String generally describing the state of the Order. When creating an Order, the value must be manually set to "open". If no value is set, the state defaults to null, which indicates an unfinished Order. An unfinished order is not displayed in user interfaces and can only be retrieved by its id. Non-null values such as "open" and "locked" are not checked or enforced by the server. Therefore, these values should not be used to make any logical decisions about the Order.
        public var state: CLVModels.Variant?
        /// Whether this order represents a manual transaction. A manual transaction is a transaction that has an arbitrary amount defined and is not associated with any inventory items. For example, the Clover Sale App and Clover Manual Transaction App create manual transactions. A manual transactions will have a single associated line item to hold the sale amount, but the generated receipt will display this differently to indicate that it is not considered a typical order with inventory items.
        public var manualTransaction: Bool?
        /// Whether similar line items should be grouped together on the receipt that this order generates. Item "similarity" is based on items having matching values for a set of properties including price, modifiers, and discounts.
        public var groupLineItems: Bool?
        /// Whether this order was created in test mode. Payments made against test orders are not processed. Test mode orders can be deleted from the Orders App on the merchant's device or web dashboard (https://www.clover.com/orders/m/{mId}/orders). They will also be deleted when the device sends a POST to the /v2/merchant/{mId}/orders/delete_all_tests endpoint.
        public var testMode: Bool?
        /// Possible values: SPLIT_GUEST, SPLIT_ITEM, SPLIT_CUSTOM, FULL. During the payment flow, if the user chooses to split the payment for this order, this field will be set to one of the SPLIT_* values to indicate how the full amount should be split. If the user chooses to pay for the order in full with one payment, then this field will be FULL.
        public var payType: CLVModels.Order.PayType?
        /// Creation timestamp
        public var createdTime: Date?
        /// The time at which the client created this order
        public var clientCreatedTime: Date?
        /// Last modified time of the order
        public var modifiedTime: Date?
        public var deletedTimestamp: Date?
        /// Optional service charge (gratuity) applied to this order
        public var serviceCharge: CLVModels.Variant?
        /// Amount or percentage discounts applied to the order subtotal. To retrieve discounts applied to individual items, use the Get all line items for an order endpoint with the discounts field expanded (v3/merchants/{mId}/orders/{orderId}/line_items?expand=discounts).
        public var discounts: [CLVModels.Order.Discount]?
        /// Line items associated with this order
        public var lineItems: [CLVModels.Order.LineItem]?
        public var taxRates: [CLVModels.Order.OrderTaxRate]?
        /// Payments that were made for this order. If multiple payments were made, then the payType field should reflect the method used to split the total amount.
        public var payments: [CLVModels.Payments.Payment]?
        /// Refunds that were made for this order
        public var refunds: [CLVModels.Payments.Refund]?
        /// Credits associated with this order.
        public var credits: [CLVModels.Payments.Credit]?
        /// Voided payments associated with this order
        public var voids: [CLVModels.Payments.Payment]?
        /// Pre-authorizations associated with this order
        public var preAuths: [CLVModels.Payments.Payment]?
        /// Device which created the order, a 128-bit UUID, not a normal base-13 Clover ID.
        public var device: CLVModels.Variant?
        /// Card authorizations associated with this order
        public var authorizations: [CLVModels.Payments.Authorization]?
        public var merchant: CLVModels.Base.Reference?
        public var onlineOrder: CLVModels.Variant?
        /// Print groups for line items of this order.
        public var printGroups: [CLVModels.Order.PrintGroup]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case currency
            case customerId
            case customerUuid
            case orderTypeId
            case customers
            case employee
            case total
            case externalReferenceId
            case unpaidBalance
            case paymentState
            case title
            case note
            case orderType
            case taxRemoved
            case isVat
            case state
            case manualTransaction
            case groupLineItems
            case testMode
            case payType
            case createdTime
            case clientCreatedTime
            case modifiedTime
            case deletedTimestamp
            case serviceCharge
            case discounts
            case lineItems
            case taxRates
            case payments
            case refunds
            case credits
            case voids
            case preAuths
            case device
            case authorizations
            case merchant
            case onlineOrder
            case printGroups
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.currency = try rootContainer.decodeIfPresent(String.self, forKey: .currency)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerId = try rootContainer.decodeIfPresent(Int64.self, forKey: .customerId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerUuid = try rootContainer.decodeIfPresent(String.self, forKey: .customerUuid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderTypeId = try rootContainer.decodeIfPresent(Int64.self, forKey: .orderTypeId)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.customers)) {
                do {
                    let customersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .customers)
                    self.customers = try customersContainer.decodeIfPresent([CLVModels.Customers.Customer].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.employee = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .employee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.total = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .total)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unpaidBalance = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unpaidBalance)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentState = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .paymentState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.title = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .title)
            } catch {
                decodeError.append(error)
            }
            do {
                self.note = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderType = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .orderType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxRemoved = try rootContainer.decodeIfPresent(Bool.self, forKey: .taxRemoved)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isVat = try rootContainer.decodeIfPresent(Bool.self, forKey: .isVat)
            } catch {
                decodeError.append(error)
            }
            do {
                self.state = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.manualTransaction = try rootContainer.decodeIfPresent(Bool.self, forKey: .manualTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.groupLineItems = try rootContainer.decodeIfPresent(Bool.self, forKey: .groupLineItems)
            } catch {
                decodeError.append(error)
            }
            do {
                self.testMode = try rootContainer.decodeIfPresent(Bool.self, forKey: .testMode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.payType = try rootContainer.decodeIfPresent(CLVModels.Order.PayType.self, forKey: .payType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientCreatedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .clientCreatedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deletedTimestamp = try rootContainer.decodeIfPresent(Date.self, forKey: .deletedTimestamp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceCharge = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .serviceCharge)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.discounts)) {
                do {
                    let discountsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .discounts)
                    self.discounts = try discountsContainer.decodeIfPresent([CLVModels.Order.Discount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.lineItems)) {
                do {
                    let lineItemsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .lineItems)
                    self.lineItems = try lineItemsContainer.decodeIfPresent([CLVModels.Order.LineItem].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent([CLVModels.Order.OrderTaxRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.payments)) {
                do {
                    let paymentsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .payments)
                    self.payments = try paymentsContainer.decodeIfPresent([CLVModels.Payments.Payment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.refunds)) {
                do {
                    let refundsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .refunds)
                    self.refunds = try refundsContainer.decodeIfPresent([CLVModels.Payments.Refund].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.credits)) {
                do {
                    let creditsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .credits)
                    self.credits = try creditsContainer.decodeIfPresent([CLVModels.Payments.Credit].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.voids)) {
                do {
                    let voidsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .voids)
                    self.voids = try voidsContainer.decodeIfPresent([CLVModels.Payments.Payment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.preAuths)) {
                do {
                    let preAuthsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .preAuths)
                    self.preAuths = try preAuthsContainer.decodeIfPresent([CLVModels.Payments.Payment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.device = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .device)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.authorizations)) {
                do {
                    let authorizationsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .authorizations)
                    self.authorizations = try authorizationsContainer.decodeIfPresent([CLVModels.Payments.Authorization].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.onlineOrder = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .onlineOrder)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.printGroups)) {
                do {
                    let printGroupsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .printGroups)
                    self.printGroups = try printGroupsContainer.decodeIfPresent([CLVModels.Order.PrintGroup].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (currency != nil) { try container.encode(currency, forKey: .currency) }
            if (customerId != nil) { try container.encode(customerId, forKey: .customerId) }
            if (customerUuid != nil) { try container.encode(customerUuid, forKey: .customerUuid) }
            if (orderTypeId != nil) { try container.encode(orderTypeId, forKey: .orderTypeId) }
            if (customers != nil) { try container.encode(customers, forKey: .customers) }
            if (employee != nil) { try container.encode(employee, forKey: .employee) }
            if (total != nil) { try container.encode(total, forKey: .total) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
            if (unpaidBalance != nil) { try container.encode(unpaidBalance, forKey: .unpaidBalance) }
            if (paymentState != nil) { try container.encode(paymentState, forKey: .paymentState) }
            if (title != nil) { try container.encode(title, forKey: .title) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (orderType != nil) { try container.encode(orderType, forKey: .orderType) }
            if (taxRemoved != nil) { try container.encode(taxRemoved, forKey: .taxRemoved) }
            if (isVat != nil) { try container.encode(isVat, forKey: .isVat) }
            if (state != nil) { try container.encode(state, forKey: .state) }
            if (manualTransaction != nil) { try container.encode(manualTransaction, forKey: .manualTransaction) }
            if (groupLineItems != nil) { try container.encode(groupLineItems, forKey: .groupLineItems) }
            if (testMode != nil) { try container.encode(testMode, forKey: .testMode) }
            if (payType != nil) { try container.encode(payType, forKey: .payType) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (clientCreatedTime != nil) { try container.encode(clientCreatedTime, forKey: .clientCreatedTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (deletedTimestamp != nil) { try container.encode(deletedTimestamp, forKey: .deletedTimestamp) }
            if (serviceCharge != nil) { try container.encode(serviceCharge, forKey: .serviceCharge) }
            if (discounts != nil) { try container.encode(discounts, forKey: .discounts) }
            if (lineItems != nil) { try container.encode(lineItems, forKey: .lineItems) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (payments != nil) { try container.encode(payments, forKey: .payments) }
            if (refunds != nil) { try container.encode(refunds, forKey: .refunds) }
            if (credits != nil) { try container.encode(credits, forKey: .credits) }
            if (voids != nil) { try container.encode(voids, forKey: .voids) }
            if (preAuths != nil) { try container.encode(preAuths, forKey: .preAuths) }
            if (device != nil) { try container.encode(device, forKey: .device) }
            if (authorizations != nil) { try container.encode(authorizations, forKey: .authorizations) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (onlineOrder != nil) { try container.encode(onlineOrder, forKey: .onlineOrder) }
            if (printGroups != nil) { try container.encode(printGroups, forKey: .printGroups) }
        }
    }

}