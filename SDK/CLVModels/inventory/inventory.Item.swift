/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Inventory {

    public class Item: Codable {

        /// Unique identifier
        public var id: String?
        /// True if this item is hidden from Clover Register App
        public var hidden: CLVModels.Variant?
        /// Reference to an item group
        public var itemGroup: CLVModels.Variant?
        /// List of options pertaining to this item's attribute variation
        public var options: CLVModels.Variant?
        /// Name of the item
        public var name: String?
        /// Alternate name of the item
        public var alternateName: CLVModels.Variant?
        /// Product code, e.g. UPC or EAN
        public var code: CLVModels.Variant?
        /// SKU of the item
        public var sku: CLVModels.Variant?
        /// Price of the item, typically in cents; use priceType and merchant currency to determine actual item price. For non-VAT merchants, this field is exclusive of tax. For VAT merchants, this field is inclusive of tax.
        public var price: Int64?
        public var priceType: CLVModels.Inventory.PriceType?
        /// Flag to indicate whether or not to use default tax rates
        public var defaultTaxRates: CLVModels.Variant?
        /// Unit name, e.g. oz, lb
        public var unitName: CLVModels.Variant?
        /// Cost of the item to merchant, as opposed to customer price
        public var cost: CLVModels.Variant?
        /// True if this item should be counted as revenue, for example gift cards and donations would not
        public var isRevenue: CLVModels.Variant?
        /// Deprecated, use itemStock instead.
        public var stockCount: CLVModels.Variant?
        public var taxRates: CLVModels.Variant?
        public var modifierGroups: CLVModels.Variant?
        /// Categories associated with this item
        public var categories: CLVModels.Variant?
        /// Tags associated with this item
        public var tags: CLVModels.Variant?
        /// Reference to canonical items
        public var canonical: CLVModels.Variant?
        /// Item stock attribute that can be expanded to show stock quantity
        public var itemStock: CLVModels.Variant?
        /// Menu Item attribute that can be expanded to menu specific attributes
        public var menuItem: CLVModels.Variant?
        public var modifiedTime: Date?
        /// Timestamp when item was last deleted
        public var deletedTime: Date?
        /// The price without value-added tax (VAT). For non-VAT merchants, this field is ignored. For VAT merchants, this field is the base price of an item.
        public var priceWithoutVat: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case hidden
            case itemGroup
            case options
            case name
            case alternateName
            case code
            case sku
            case price
            case priceType
            case defaultTaxRates
            case unitName
            case cost
            case isRevenue
            case stockCount
            case taxRates
            case modifierGroups
            case categories
            case tags
            case canonical
            case itemStock
            case menuItem
            case modifiedTime
            case deletedTime
            case priceWithoutVat
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hidden = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .hidden)
            } catch {
                decodeError.append(error)
            }
            do {
                self.itemGroup = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .itemGroup)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.options)) {
                do {
                    let optionsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .options)
                    self.options = try optionsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.alternateName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .alternateName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.code = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .code)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sku = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .sku)
            } catch {
                decodeError.append(error)
            }
            do {
                self.price = try rootContainer.decodeIfPresent(Int64.self, forKey: .price)
            } catch {
                decodeError.append(error)
            }
            do {
                self.priceType = try rootContainer.decodeIfPresent(CLVModels.Inventory.PriceType.self, forKey: .priceType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.defaultTaxRates = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .defaultTaxRates)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unitName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unitName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cost = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cost)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isRevenue = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .isRevenue)
            } catch {
                decodeError.append(error)
            }
            do {
                self.stockCount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .stockCount)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.modifierGroups)) {
                do {
                    let modifierGroupsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .modifierGroups)
                    self.modifierGroups = try modifierGroupsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.categories)) {
                do {
                    let categoriesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .categories)
                    self.categories = try categoriesContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.tags)) {
                do {
                    let tagsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tags)
                    self.tags = try tagsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.canonical = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .canonical)
            } catch {
                decodeError.append(error)
            }
            do {
                self.itemStock = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .itemStock)
            } catch {
                decodeError.append(error)
            }
            do {
                self.menuItem = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .menuItem)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deletedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .deletedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.priceWithoutVat = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .priceWithoutVat)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (hidden != nil) { try container.encode(hidden, forKey: .hidden) }
            if (itemGroup != nil) { try container.encode(itemGroup, forKey: .itemGroup) }
            if (options != nil) { try container.encode(options, forKey: .options) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (alternateName != nil) { try container.encode(alternateName, forKey: .alternateName) }
            if (code != nil) { try container.encode(code, forKey: .code) }
            if (sku != nil) { try container.encode(sku, forKey: .sku) }
            if (price != nil) { try container.encode(price, forKey: .price) }
            if (priceType != nil) { try container.encode(priceType, forKey: .priceType) }
            if (defaultTaxRates != nil) { try container.encode(defaultTaxRates, forKey: .defaultTaxRates) }
            if (unitName != nil) { try container.encode(unitName, forKey: .unitName) }
            if (cost != nil) { try container.encode(cost, forKey: .cost) }
            if (isRevenue != nil) { try container.encode(isRevenue, forKey: .isRevenue) }
            if (stockCount != nil) { try container.encode(stockCount, forKey: .stockCount) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (modifierGroups != nil) { try container.encode(modifierGroups, forKey: .modifierGroups) }
            if (categories != nil) { try container.encode(categories, forKey: .categories) }
            if (tags != nil) { try container.encode(tags, forKey: .tags) }
            if (canonical != nil) { try container.encode(canonical, forKey: .canonical) }
            if (itemStock != nil) { try container.encode(itemStock, forKey: .itemStock) }
            if (menuItem != nil) { try container.encode(menuItem, forKey: .menuItem) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (deletedTime != nil) { try container.encode(deletedTime, forKey: .deletedTime) }
            if (priceWithoutVat != nil) { try container.encode(priceWithoutVat, forKey: .priceWithoutVat) }
        }
    }

}