/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Developer {

    public class Developer: Codable {

        /// Unique identifier
        public var id: String?
        /// Developer's name.  Could be a company name.  Whatever is to be shown as who made the app in App Marketplace, e.g. NoshList, Pioneer Works Inc., Seven Spaces, etc.  Also used as (optional) Business DBA (Doing Business Name) name when sending to Braintree for app billing background check.
        public var name: String?
        /// Developer's individual first name.
        public var firstName: String?
        /// Developer's individual last name.
        public var lastName: String?
        /// Developer's email.
        public var email: String?
        /// Developer's phone.
        public var phone: String?
        /// Developer's date of birth.
        public var dob: String?
        /// Developer's SSN; won't be stored in the clear in the DB; will be stored encrypted in sensitiveInfo.
        public var ssn: String?
        /// Developer's address.
        public var address: String?
        /// Developer's city.
        public var city: String?
        /// Developer's county.
        public var county: String?
        /// Developer's state.
        public var state: String?
        /// Developer's country.
        public var country: String?
        /// Developer's postal code.
        public var postalCode: String?
        /// Developer's bank account number; won't be stored in the clear in the DB; will be stored encrypted in sensitiveInfo.
        public var bankAccountNumber: String?
        /// Developer's bank info that allows persisting last four and billing modified times.
        public var bankInfo: CLVModels.Base.Reference?
        /// Developer's bank routing number.
        public var bankRoutingNumber: String?
        /// Developer's business legal name.
        public var businessLegalName: String?
        /// Developer's Tax ID or Employer Identification Number
        public var tin: String?
        /// If Developer has Tax ID or Employer Identification Number persisted (for response only)
        public var hasTin: Bool?
        /// Developer's VAT Register Number.
        public var vatRegisterNumber: String?
        /// Sensitive data encrypted.
        public var sensitiveData: String?
        /// Developer's business address.
        public var businessAddress: String?
        /// Developer's business city.
        public var businessCity: String?
        /// Developer's business state.
        public var businessState: String?
        /// Developer's business country.
        public var businessCountry: String?
        /// Developer's business postal code.
        public var businessPostalCode: String?
        /// Developer's billing status.
        public var billingStatus: CLVModels.Developer.DeveloperBillingStatus?
        /// Developer's billing status message.
        public var billingStatusMessage: String?
        public var approvalStatus: CLVModels.Base.ApprovalStatus?
        /// Timestamp indicating the time the approval status last changed
        public var approvalStatusModifiedTime: Date?
        /// If the user has accepted the developer agreement.
        public var acceptedAgreement: Bool?
        /// Name of public relations contact.
        public var prName: String?
        /// Email of public relations contact.
        public var prEmail: String?
        /// Phone of public relations contact.
        public var prPhone: String?
        /// Developer's business website.
        public var website: String?
        /// Timestamp indicating the time the developer was created.
        public var createdTime: Date?
        /// Timestamp indicating the time the developer information was first submitted.
        public var firstSubmittedTime: Date?
        /// Timestamp indicating the time the developer was first approved.
        public var firstApprovalTime: Date?
        /// Timestamp indicating the last time the developer was modified.
        public var modifiedTime: Date?
        /// The user account that owns this developer account.
        public var owner: CLVModels.Base.Reference?
        /// Temporary while we are switching US billing systems.
        public var appBillingSystem: String?
        /// The Infolease vendor code.  This is generated when the developer is on-boarded in the Infolease system.
        public var infoleaseVendorCode: String?
        /// The Infolease GL (General Ledger) code.  Only for specific apps.  Will usually be null.
        public var infoleaseGlCode: String?
        /// Revenue share due the developer.
        public var revShare: Int32?
        /// Revenue share is a flat rate / amount not percentage.
        public var isRevShareFlatRate: Bool?
        /// Timestamp indicating when the revenue share is effective.
        public var revShareEffectiveTime: Date?
        /// Signor name for developer referral program.
        public var signorName: String?
        /// Signor title for developer referral program.
        public var signorTitle: String?
        /// Timestamp indicating when the developer referral form was submitted.
        public var referralSubmissionTime: Date?
        /// Optional email field used by Clover support for high priority communications.
        public var emergencyEmail: String?
        /// Developer's status concerning the ability to create private app collections.
        public var collectionApprovalStatus: CLVModels.Developer.CollectionApprovalStatus?
        /// This is true if the developer has a partner app.
        public var isIsv: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case firstName
            case lastName
            case email
            case phone
            case dob
            case ssn
            case address
            case city
            case county
            case state
            case country
            case postalCode
            case bankAccountNumber
            case bankInfo
            case bankRoutingNumber
            case businessLegalName
            case tin
            case hasTin
            case vatRegisterNumber
            case sensitiveData
            case businessAddress
            case businessCity
            case businessState
            case businessCountry
            case businessPostalCode
            case billingStatus
            case billingStatusMessage
            case approvalStatus
            case approvalStatusModifiedTime
            case acceptedAgreement
            case prName
            case prEmail
            case prPhone
            case website
            case createdTime
            case firstSubmittedTime
            case firstApprovalTime
            case modifiedTime
            case owner
            case appBillingSystem
            case infoleaseVendorCode
            case infoleaseGlCode
            case revShare
            case isRevShareFlatRate
            case revShareEffectiveTime
            case signorName
            case signorTitle
            case referralSubmissionTime
            case emergencyEmail
            case collectionApprovalStatus
            case isIsv
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.firstName = try rootContainer.decodeIfPresent(String.self, forKey: .firstName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.lastName = try rootContainer.decodeIfPresent(String.self, forKey: .lastName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.email = try rootContainer.decodeIfPresent(String.self, forKey: .email)
            } catch {
                decodeError.append(error)
            }
            do {
                self.phone = try rootContainer.decodeIfPresent(String.self, forKey: .phone)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dob = try rootContainer.decodeIfPresent(String.self, forKey: .dob)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ssn = try rootContainer.decodeIfPresent(String.self, forKey: .ssn)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address = try rootContainer.decodeIfPresent(String.self, forKey: .address)
            } catch {
                decodeError.append(error)
            }
            do {
                self.city = try rootContainer.decodeIfPresent(String.self, forKey: .city)
            } catch {
                decodeError.append(error)
            }
            do {
                self.county = try rootContainer.decodeIfPresent(String.self, forKey: .county)
            } catch {
                decodeError.append(error)
            }
            do {
                self.state = try rootContainer.decodeIfPresent(String.self, forKey: .state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.country = try rootContainer.decodeIfPresent(String.self, forKey: .country)
            } catch {
                decodeError.append(error)
            }
            do {
                self.postalCode = try rootContainer.decodeIfPresent(String.self, forKey: .postalCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bankAccountNumber = try rootContainer.decodeIfPresent(String.self, forKey: .bankAccountNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bankInfo = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .bankInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bankRoutingNumber = try rootContainer.decodeIfPresent(String.self, forKey: .bankRoutingNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessLegalName = try rootContainer.decodeIfPresent(String.self, forKey: .businessLegalName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tin = try rootContainer.decodeIfPresent(String.self, forKey: .tin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hasTin = try rootContainer.decodeIfPresent(Bool.self, forKey: .hasTin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.vatRegisterNumber = try rootContainer.decodeIfPresent(String.self, forKey: .vatRegisterNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sensitiveData = try rootContainer.decodeIfPresent(String.self, forKey: .sensitiveData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessAddress = try rootContainer.decodeIfPresent(String.self, forKey: .businessAddress)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessCity = try rootContainer.decodeIfPresent(String.self, forKey: .businessCity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessState = try rootContainer.decodeIfPresent(String.self, forKey: .businessState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessCountry = try rootContainer.decodeIfPresent(String.self, forKey: .businessCountry)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessPostalCode = try rootContainer.decodeIfPresent(String.self, forKey: .businessPostalCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billingStatus = try rootContainer.decodeIfPresent(CLVModels.Developer.DeveloperBillingStatus.self, forKey: .billingStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billingStatusMessage = try rootContainer.decodeIfPresent(String.self, forKey: .billingStatusMessage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.approvalStatus = try rootContainer.decodeIfPresent(CLVModels.Base.ApprovalStatus.self, forKey: .approvalStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.approvalStatusModifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .approvalStatusModifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.acceptedAgreement = try rootContainer.decodeIfPresent(Bool.self, forKey: .acceptedAgreement)
            } catch {
                decodeError.append(error)
            }
            do {
                self.prName = try rootContainer.decodeIfPresent(String.self, forKey: .prName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.prEmail = try rootContainer.decodeIfPresent(String.self, forKey: .prEmail)
            } catch {
                decodeError.append(error)
            }
            do {
                self.prPhone = try rootContainer.decodeIfPresent(String.self, forKey: .prPhone)
            } catch {
                decodeError.append(error)
            }
            do {
                self.website = try rootContainer.decodeIfPresent(String.self, forKey: .website)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.firstSubmittedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .firstSubmittedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.firstApprovalTime = try rootContainer.decodeIfPresent(Date.self, forKey: .firstApprovalTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.owner = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .owner)
            } catch {
                decodeError.append(error)
            }
            do {
                self.appBillingSystem = try rootContainer.decodeIfPresent(String.self, forKey: .appBillingSystem)
            } catch {
                decodeError.append(error)
            }
            do {
                self.infoleaseVendorCode = try rootContainer.decodeIfPresent(String.self, forKey: .infoleaseVendorCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.infoleaseGlCode = try rootContainer.decodeIfPresent(String.self, forKey: .infoleaseGlCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.revShare = try rootContainer.decodeIfPresent(Int32.self, forKey: .revShare)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isRevShareFlatRate = try rootContainer.decodeIfPresent(Bool.self, forKey: .isRevShareFlatRate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.revShareEffectiveTime = try rootContainer.decodeIfPresent(Date.self, forKey: .revShareEffectiveTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signorName = try rootContainer.decodeIfPresent(String.self, forKey: .signorName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signorTitle = try rootContainer.decodeIfPresent(String.self, forKey: .signorTitle)
            } catch {
                decodeError.append(error)
            }
            do {
                self.referralSubmissionTime = try rootContainer.decodeIfPresent(Date.self, forKey: .referralSubmissionTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.emergencyEmail = try rootContainer.decodeIfPresent(String.self, forKey: .emergencyEmail)
            } catch {
                decodeError.append(error)
            }
            do {
                self.collectionApprovalStatus = try rootContainer.decodeIfPresent(CLVModels.Developer.CollectionApprovalStatus.self, forKey: .collectionApprovalStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isIsv = try rootContainer.decodeIfPresent(Bool.self, forKey: .isIsv)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (firstName != nil) { try container.encode(firstName, forKey: .firstName) }
            if (lastName != nil) { try container.encode(lastName, forKey: .lastName) }
            if (email != nil) { try container.encode(email, forKey: .email) }
            if (phone != nil) { try container.encode(phone, forKey: .phone) }
            if (dob != nil) { try container.encode(dob, forKey: .dob) }
            if (ssn != nil) { try container.encode(ssn, forKey: .ssn) }
            if (address != nil) { try container.encode(address, forKey: .address) }
            if (city != nil) { try container.encode(city, forKey: .city) }
            if (county != nil) { try container.encode(county, forKey: .county) }
            if (state != nil) { try container.encode(state, forKey: .state) }
            if (country != nil) { try container.encode(country, forKey: .country) }
            if (postalCode != nil) { try container.encode(postalCode, forKey: .postalCode) }
            if (bankAccountNumber != nil) { try container.encode(bankAccountNumber, forKey: .bankAccountNumber) }
            if (bankInfo != nil) { try container.encode(bankInfo, forKey: .bankInfo) }
            if (bankRoutingNumber != nil) { try container.encode(bankRoutingNumber, forKey: .bankRoutingNumber) }
            if (businessLegalName != nil) { try container.encode(businessLegalName, forKey: .businessLegalName) }
            if (tin != nil) { try container.encode(tin, forKey: .tin) }
            if (hasTin != nil) { try container.encode(hasTin, forKey: .hasTin) }
            if (vatRegisterNumber != nil) { try container.encode(vatRegisterNumber, forKey: .vatRegisterNumber) }
            if (sensitiveData != nil) { try container.encode(sensitiveData, forKey: .sensitiveData) }
            if (businessAddress != nil) { try container.encode(businessAddress, forKey: .businessAddress) }
            if (businessCity != nil) { try container.encode(businessCity, forKey: .businessCity) }
            if (businessState != nil) { try container.encode(businessState, forKey: .businessState) }
            if (businessCountry != nil) { try container.encode(businessCountry, forKey: .businessCountry) }
            if (businessPostalCode != nil) { try container.encode(businessPostalCode, forKey: .businessPostalCode) }
            if (billingStatus != nil) { try container.encode(billingStatus, forKey: .billingStatus) }
            if (billingStatusMessage != nil) { try container.encode(billingStatusMessage, forKey: .billingStatusMessage) }
            if (approvalStatus != nil) { try container.encode(approvalStatus, forKey: .approvalStatus) }
            if (approvalStatusModifiedTime != nil) { try container.encode(approvalStatusModifiedTime, forKey: .approvalStatusModifiedTime) }
            if (acceptedAgreement != nil) { try container.encode(acceptedAgreement, forKey: .acceptedAgreement) }
            if (prName != nil) { try container.encode(prName, forKey: .prName) }
            if (prEmail != nil) { try container.encode(prEmail, forKey: .prEmail) }
            if (prPhone != nil) { try container.encode(prPhone, forKey: .prPhone) }
            if (website != nil) { try container.encode(website, forKey: .website) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (firstSubmittedTime != nil) { try container.encode(firstSubmittedTime, forKey: .firstSubmittedTime) }
            if (firstApprovalTime != nil) { try container.encode(firstApprovalTime, forKey: .firstApprovalTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (owner != nil) { try container.encode(owner, forKey: .owner) }
            if (appBillingSystem != nil) { try container.encode(appBillingSystem, forKey: .appBillingSystem) }
            if (infoleaseVendorCode != nil) { try container.encode(infoleaseVendorCode, forKey: .infoleaseVendorCode) }
            if (infoleaseGlCode != nil) { try container.encode(infoleaseGlCode, forKey: .infoleaseGlCode) }
            if (revShare != nil) { try container.encode(revShare, forKey: .revShare) }
            if (isRevShareFlatRate != nil) { try container.encode(isRevShareFlatRate, forKey: .isRevShareFlatRate) }
            if (revShareEffectiveTime != nil) { try container.encode(revShareEffectiveTime, forKey: .revShareEffectiveTime) }
            if (signorName != nil) { try container.encode(signorName, forKey: .signorName) }
            if (signorTitle != nil) { try container.encode(signorTitle, forKey: .signorTitle) }
            if (referralSubmissionTime != nil) { try container.encode(referralSubmissionTime, forKey: .referralSubmissionTime) }
            if (emergencyEmail != nil) { try container.encode(emergencyEmail, forKey: .emergencyEmail) }
            if (collectionApprovalStatus != nil) { try container.encode(collectionApprovalStatus, forKey: .collectionApprovalStatus) }
            if (isIsv != nil) { try container.encode(isIsv, forKey: .isIsv) }
        }
    }

}