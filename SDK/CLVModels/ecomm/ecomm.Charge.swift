/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Ecomm {

    public class Charge: Codable {

        /// Unique identifier for the object.
        public var id: String?
        /// A positive integer in the smallest currency unit (e.g., 100 cents to charge $1.00 or 100 to charge Â¥100, a zero-decimal currency) representing how much to charge. The minimum amount is $0.50 US or equivalent in charge currency.
        public var amount: Int64?
        /// Amount paid in tips
        public var tip_amount: CLVModels.Variant?
        /// Amount paid in taxes
        public var tax_amount: CLVModels.Variant?
        /// Amount paid in convenience fees
        public var convenience_fee: CLVModels.Variant?
        /// Amount in cents refunded (can be less than the amount attribute on the charge if a partial refund was issued).
        public var amount_refunded: Int64?
        public var billing_details: CLVModels.Ecomm.BillingDetails?
        /// Three-letter ISO currency code. Must be a supported currency.
        public var currency: CLVModels.Variant?
        public var created: Int64?
        /// An arbitrary string attached to the object. Often useful for displaying to users.
        public var description_: CLVModels.Variant?
        /// If the charge was created without capturing, this Boolean represents whether it is still uncaptured or has since been captured.
        public var captured: Bool?
        /// ID of the customer this charge is for if one exists.
        public var customer: CLVModels.Variant?
        /// Reference number for successful transaction
        public var ref_num: CLVModels.Variant?
        /// Authorization code for successful transaction
        public var auth_code: CLVModels.Variant?
        /// Error code explaining reason for charge failure if available (see the errors section for a list of codes).
        public var failure_code: CLVModels.Tokens.Error?
        /// Message to user further explaining reason for charge failure if available.
        public var failure_message: CLVModels.Variant?
        /// Warning message to user if available.
        public var warning_message: CLVModels.Variant?
        /// Has the value true if the object exists in live mode or the value false if the object exists in test mode.
        public var livemode: Bool?
        /// The account (if any) the charge was made on behalf of without triggering an automatic transfer
        public var on_behalf_of: CLVModels.Variant?
        /// ID of the order this charge is for if one exists.
        public var order: CLVModels.Variant?
        /// Details about whether the payment was accepted, and why.
        public var outcome: CLVModels.Ecomm.ChargeOutcome?
        /// true if the charge succeeded, or was successfully authorized for later capture.
        public var paid: Bool?
        /// Whether the charge has been fully refunded. If the charge is only partially refunded, this attribute will still be false.
        public var refunded: Bool?
        /// This is the email address that the receipt for this charge was sent to.
        public var receipt_email: CLVModels.Variant?
        public var status: CLVModels.Ecomm.status?
        /// Details about the source at the time of the transaction.
        public var source: CLVModels.Ecomm.Source?
        /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.
        public var metadata: [String:String]?
        /// Details about the stored credentials.
        public var stored_credentials: CLVModels.Ecomm.StoredCredentials?
        /// An id such as an Invoice PO number that can be passed to the merchant's gateway, and ultimately appear in settlement records.
        public var external_reference_id: String?
        /// This is an optional value. This field indicates whether it's ECOMM, MOTO or RECURRING transaction
        public var ecomind: CLVModels.Ecomm.EcommerceIndicator?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case amount
            case tip_amount
            case tax_amount
            case convenience_fee
            case amount_refunded
            case billing_details
            case currency
            case created
            case description
            case captured
            case customer
            case ref_num
            case auth_code
            case failure_code
            case failure_message
            case warning_message
            case livemode
            case on_behalf_of
            case order
            case outcome
            case paid
            case refunded
            case receipt_email
            case status
            case source
            case metadata
            case stored_credentials
            case external_reference_id
            case ecomind
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tip_amount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tip_amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tax_amount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tax_amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.convenience_fee = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .convenience_fee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount_refunded = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount_refunded)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billing_details = try rootContainer.decodeIfPresent(CLVModels.Ecomm.BillingDetails.self, forKey: .billing_details)
            } catch {
                decodeError.append(error)
            }
            do {
                self.currency = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .currency)
            } catch {
                decodeError.append(error)
            }
            do {
                self.created = try rootContainer.decodeIfPresent(Int64.self, forKey: .created)
            } catch {
                decodeError.append(error)
            }
            do {
                self.description_ = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .description)
            } catch {
                decodeError.append(error)
            }
            do {
                self.captured = try rootContainer.decodeIfPresent(Bool.self, forKey: .captured)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customer = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .customer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ref_num = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .ref_num)
            } catch {
                decodeError.append(error)
            }
            do {
                self.auth_code = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .auth_code)
            } catch {
                decodeError.append(error)
            }
            do {
                self.failure_code = try rootContainer.decodeIfPresent(CLVModels.Tokens.Error.self, forKey: .failure_code)
            } catch {
                decodeError.append(error)
            }
            do {
                self.failure_message = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .failure_message)
            } catch {
                decodeError.append(error)
            }
            do {
                self.warning_message = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .warning_message)
            } catch {
                decodeError.append(error)
            }
            do {
                self.livemode = try rootContainer.decodeIfPresent(Bool.self, forKey: .livemode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.on_behalf_of = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .on_behalf_of)
            } catch {
                decodeError.append(error)
            }
            do {
                self.order = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .order)
            } catch {
                decodeError.append(error)
            }
            do {
                self.outcome = try rootContainer.decodeIfPresent(CLVModels.Ecomm.ChargeOutcome.self, forKey: .outcome)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paid = try rootContainer.decodeIfPresent(Bool.self, forKey: .paid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refunded = try rootContainer.decodeIfPresent(Bool.self, forKey: .refunded)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receipt_email = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .receipt_email)
            } catch {
                decodeError.append(error)
            }
            do {
                self.status = try rootContainer.decodeIfPresent(CLVModels.Ecomm.status.self, forKey: .status)
            } catch {
                decodeError.append(error)
            }
            do {
                self.source = try rootContainer.decodeIfPresent(CLVModels.Ecomm.Source.self, forKey: .source)
            } catch {
                decodeError.append(error)
            }
            do {
                self.metadata = try rootContainer.decodeIfPresent([String:String].self, forKey: .metadata)
            } catch {
                decodeError.append(error)
            }
            do {
                self.stored_credentials = try rootContainer.decodeIfPresent(CLVModels.Ecomm.StoredCredentials.self, forKey: .stored_credentials)
            } catch {
                decodeError.append(error)
            }
            do {
                self.external_reference_id = try rootContainer.decodeIfPresent(String.self, forKey: .external_reference_id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ecomind = try rootContainer.decodeIfPresent(CLVModels.Ecomm.EcommerceIndicator.self, forKey: .ecomind)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (tip_amount != nil) { try container.encode(tip_amount, forKey: .tip_amount) }
            if (tax_amount != nil) { try container.encode(tax_amount, forKey: .tax_amount) }
            if (convenience_fee != nil) { try container.encode(convenience_fee, forKey: .convenience_fee) }
            if (amount_refunded != nil) { try container.encode(amount_refunded, forKey: .amount_refunded) }
            if (billing_details != nil) { try container.encode(billing_details, forKey: .billing_details) }
            if (currency != nil) { try container.encode(currency, forKey: .currency) }
            if (created != nil) { try container.encode(created, forKey: .created) }
            if (description_ != nil) { try container.encode(description_, forKey: .description) }
            if (captured != nil) { try container.encode(captured, forKey: .captured) }
            if (customer != nil) { try container.encode(customer, forKey: .customer) }
            if (ref_num != nil) { try container.encode(ref_num, forKey: .ref_num) }
            if (auth_code != nil) { try container.encode(auth_code, forKey: .auth_code) }
            if (failure_code != nil) { try container.encode(failure_code, forKey: .failure_code) }
            if (failure_message != nil) { try container.encode(failure_message, forKey: .failure_message) }
            if (warning_message != nil) { try container.encode(warning_message, forKey: .warning_message) }
            if (livemode != nil) { try container.encode(livemode, forKey: .livemode) }
            if (on_behalf_of != nil) { try container.encode(on_behalf_of, forKey: .on_behalf_of) }
            if (order != nil) { try container.encode(order, forKey: .order) }
            if (outcome != nil) { try container.encode(outcome, forKey: .outcome) }
            if (paid != nil) { try container.encode(paid, forKey: .paid) }
            if (refunded != nil) { try container.encode(refunded, forKey: .refunded) }
            if (receipt_email != nil) { try container.encode(receipt_email, forKey: .receipt_email) }
            if (status != nil) { try container.encode(status, forKey: .status) }
            if (source != nil) { try container.encode(source, forKey: .source) }
            if (metadata != nil) { try container.encode(metadata, forKey: .metadata) }
            if (stored_credentials != nil) { try container.encode(stored_credentials, forKey: .stored_credentials) }
            if (external_reference_id != nil) { try container.encode(external_reference_id, forKey: .external_reference_id) }
            if (ecomind != nil) { try container.encode(ecomind, forKey: .ecomind) }
        }
    }

}