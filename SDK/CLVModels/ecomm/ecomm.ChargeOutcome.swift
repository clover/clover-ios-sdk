/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Ecomm {

    public class ChargeOutcome: Codable {

        public var network_status: CLVModels.Ecomm.network_status?
        /// An enumerated value providing a more detailed explanation of the outcome’s type.
        public var reason: CLVModels.Variant?
        /// Clover’s evaluation of the riskiness of the payment. Possible values for evaluated payments are normal, elevated, highest. For non-card payments, and card-based payments predating the public assignment of risk levels, this field will have the value not_assessed. In the event of an error in the evaluation, this field will have the value unknown.
        public var risk_level: CLVModels.Ecomm.risk_level?
        /// Clover’s evaluation of the riskiness of the payment. Possible values for evaluated payments are between 0 and 100. For non-card payments, card-based payments predating the public assignment of risk scores, or in the event of an error during evaluation, this field will not be present. 
        public var risk_score: CLVModels.Variant?
        /// Id of the rule that matched the payment
        public var rule: CLVModels.Variant?
        /// A human-readable description of the outcome type and reason, designed for you (the recipient of the payment), not your customer.
        public var seller_message: CLVModels.Variant?
        public var type_: CLVModels.Ecomm.type_?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case network_status
            case reason
            case risk_level
            case risk_score
            case rule
            case seller_message
            case type
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.network_status = try rootContainer.decodeIfPresent(CLVModels.Ecomm.network_status.self, forKey: .network_status)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reason = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .reason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.risk_level = try rootContainer.decodeIfPresent(CLVModels.Ecomm.risk_level.self, forKey: .risk_level)
            } catch {
                decodeError.append(error)
            }
            do {
                self.risk_score = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .risk_score)
            } catch {
                decodeError.append(error)
            }
            do {
                self.rule = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .rule)
            } catch {
                decodeError.append(error)
            }
            do {
                self.seller_message = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .seller_message)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Ecomm.type_.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (network_status != nil) { try container.encode(network_status, forKey: .network_status) }
            if (reason != nil) { try container.encode(reason, forKey: .reason) }
            if (risk_level != nil) { try container.encode(risk_level, forKey: .risk_level) }
            if (risk_score != nil) { try container.encode(risk_score, forKey: .risk_score) }
            if (rule != nil) { try container.encode(rule, forKey: .rule) }
            if (seller_message != nil) { try container.encode(seller_message, forKey: .seller_message) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
        }
    }

}