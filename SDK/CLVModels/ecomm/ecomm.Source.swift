/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Ecomm {

    public class Source: Codable {

        /// Unique identifier for the object.
        public var id: String?
        /// Type of source e.g card, bank account etc
        public var object: String?
        /// City of the address.
        public var address_city: CLVModels.Variant?
        /// Country of the address.
        public var address_country: CLVModels.Variant?
        /// Address Line 1.
        public var address_line1: CLVModels.Variant?
        /// If a address line1 was provided, results of the check, one of pass, failed, unavailable or unchecked.
        public var address_line1_check: CLVModels.Variant?
        /// Address Line 2.
        public var address_line2: CLVModels.Variant?
        /// State of the address.
        public var address_state: CLVModels.Variant?
        /// Zip code of the address.
        public var address_zip: CLVModels.Variant?
        /// If a zip code was provided, results of the check, one of pass, failed, unavailable or unchecked.
        public var address_zip_check: CLVModels.Variant?
        /// Card brand. Can be amex, diners, discover, jcb, mastercard, unionpay, visa, or unknown.
        public var brand: CLVModels.Variant?
        /// Two-letter ISO code representing the country of the card. You could use this attribute to get a sense of the international breakdown of cards you’ve collected.
        public var country: CLVModels.Variant?
        /// If a CVC was provided, results of the check, one of pass, failed, unavailable or unchecked.
        public var cvc_check: CLVModels.Variant?
        /// Dynamic last 4 digit.
        public var dynamic_last4: CLVModels.Variant?
        /// Two-digit number representing the card's expiration month.
        public var exp_month: String?
        /// Four-digit number representing the card’s expiration year.
        public var exp_year: String?
        /// Uniquely identifies this particular card number. You can use this attribute to check whether two customers who’ve signed up with you are using the same card number, for example.
        public var fingerprint: String?
        /// Card funding type. Can be credit, debit, prepaid, or unknown.
        public var funding: String?
        /// first6 of number
        public var first6: String?
        /// The last four digits of the card.
        public var last4: String?
        /// Name of the card holder.
        public var name: String?
        /// Tokenization Method.
        public var tokenization_method: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case object
            case address_city
            case address_country
            case address_line1
            case address_line1_check
            case address_line2
            case address_state
            case address_zip
            case address_zip_check
            case brand
            case country
            case cvc_check
            case dynamic_last4
            case exp_month
            case exp_year
            case fingerprint
            case funding
            case first6
            case last4
            case name
            case tokenization_method
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.object = try rootContainer.decodeIfPresent(String.self, forKey: .object)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_city = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_city)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_country = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_country)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_line1 = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_line1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_line1_check = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_line1_check)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_line2 = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_line2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_state = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_zip = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_zip)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address_zip_check = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .address_zip_check)
            } catch {
                decodeError.append(error)
            }
            do {
                self.brand = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .brand)
            } catch {
                decodeError.append(error)
            }
            do {
                self.country = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .country)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cvc_check = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cvc_check)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dynamic_last4 = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .dynamic_last4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exp_month = try rootContainer.decodeIfPresent(String.self, forKey: .exp_month)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exp_year = try rootContainer.decodeIfPresent(String.self, forKey: .exp_year)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fingerprint = try rootContainer.decodeIfPresent(String.self, forKey: .fingerprint)
            } catch {
                decodeError.append(error)
            }
            do {
                self.funding = try rootContainer.decodeIfPresent(String.self, forKey: .funding)
            } catch {
                decodeError.append(error)
            }
            do {
                self.first6 = try rootContainer.decodeIfPresent(String.self, forKey: .first6)
            } catch {
                decodeError.append(error)
            }
            do {
                self.last4 = try rootContainer.decodeIfPresent(String.self, forKey: .last4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tokenization_method = try rootContainer.decodeIfPresent(String.self, forKey: .tokenization_method)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (object != nil) { try container.encode(object, forKey: .object) }
            if (address_city != nil) { try container.encode(address_city, forKey: .address_city) }
            if (address_country != nil) { try container.encode(address_country, forKey: .address_country) }
            if (address_line1 != nil) { try container.encode(address_line1, forKey: .address_line1) }
            if (address_line1_check != nil) { try container.encode(address_line1_check, forKey: .address_line1_check) }
            if (address_line2 != nil) { try container.encode(address_line2, forKey: .address_line2) }
            if (address_state != nil) { try container.encode(address_state, forKey: .address_state) }
            if (address_zip != nil) { try container.encode(address_zip, forKey: .address_zip) }
            if (address_zip_check != nil) { try container.encode(address_zip_check, forKey: .address_zip_check) }
            if (brand != nil) { try container.encode(brand, forKey: .brand) }
            if (country != nil) { try container.encode(country, forKey: .country) }
            if (cvc_check != nil) { try container.encode(cvc_check, forKey: .cvc_check) }
            if (dynamic_last4 != nil) { try container.encode(dynamic_last4, forKey: .dynamic_last4) }
            if (exp_month != nil) { try container.encode(exp_month, forKey: .exp_month) }
            if (exp_year != nil) { try container.encode(exp_year, forKey: .exp_year) }
            if (fingerprint != nil) { try container.encode(fingerprint, forKey: .fingerprint) }
            if (funding != nil) { try container.encode(funding, forKey: .funding) }
            if (first6 != nil) { try container.encode(first6, forKey: .first6) }
            if (last4 != nil) { try container.encode(last4, forKey: .last4) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (tokenization_method != nil) { try container.encode(tokenization_method, forKey: .tokenization_method) }
        }
    }

}