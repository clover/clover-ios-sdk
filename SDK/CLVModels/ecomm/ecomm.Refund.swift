/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Ecomm {

    public class Refund: Codable {

        /// Unique identifier for the object.
        public var id: String?
        /// String representing the objectâ€™s type. Objects of the same type share the same value.
        public var object: String?
        /// A positive integer in the smallest currency unit.
        public var amount: Int64?
        /// ID of the charge that was refunded.
        public var charge: String?
        /// Time at which the object was created. Measured in seconds since the Unix epoch.
        public var created: Int64?
        /// Three-letter ISO currency code. Must be a supported currency.
        public var currency: CLVModels.Variant?
        /// An arbitrary string attached to the object. Often useful for displaying to users. (Available on non-card refunds only)
        public var description_: CLVModels.Variant?
        /// If the refund failed, the reason for refund failure if known.
        public var failure_reason: CLVModels.Ecomm.failure_reason?
        /// Reason for the refund.
        public var reason: CLVModels.Ecomm.RefundReason?
        /// This is the transaction number that appears on email receipts sent for this refund.
        public var receipt_number: String?
        /// Status of the refund. For credit card refunds, this can be succeeded or failed. For other types of refunds, it can be pending, succeeded, failed, or canceled
        public var status: CLVModels.Ecomm.RefundStatus?
        /// You can specify up to 50 keys, with key names up to 40 characters long and values up to 500 characters long.
        public var metadata: [String:String]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case object
            case amount
            case charge
            case created
            case currency
            case description
            case failure_reason
            case reason
            case receipt_number
            case status
            case metadata
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.object = try rootContainer.decodeIfPresent(String.self, forKey: .object)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.charge = try rootContainer.decodeIfPresent(String.self, forKey: .charge)
            } catch {
                decodeError.append(error)
            }
            do {
                self.created = try rootContainer.decodeIfPresent(Int64.self, forKey: .created)
            } catch {
                decodeError.append(error)
            }
            do {
                self.currency = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .currency)
            } catch {
                decodeError.append(error)
            }
            do {
                self.description_ = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .description)
            } catch {
                decodeError.append(error)
            }
            do {
                self.failure_reason = try rootContainer.decodeIfPresent(CLVModels.Ecomm.failure_reason.self, forKey: .failure_reason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reason = try rootContainer.decodeIfPresent(CLVModels.Ecomm.RefundReason.self, forKey: .reason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receipt_number = try rootContainer.decodeIfPresent(String.self, forKey: .receipt_number)
            } catch {
                decodeError.append(error)
            }
            do {
                self.status = try rootContainer.decodeIfPresent(CLVModels.Ecomm.RefundStatus.self, forKey: .status)
            } catch {
                decodeError.append(error)
            }
            do {
                self.metadata = try rootContainer.decodeIfPresent([String:String].self, forKey: .metadata)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (object != nil) { try container.encode(object, forKey: .object) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (charge != nil) { try container.encode(charge, forKey: .charge) }
            if (created != nil) { try container.encode(created, forKey: .created) }
            if (currency != nil) { try container.encode(currency, forKey: .currency) }
            if (description_ != nil) { try container.encode(description_, forKey: .description) }
            if (failure_reason != nil) { try container.encode(failure_reason, forKey: .failure_reason) }
            if (reason != nil) { try container.encode(reason, forKey: .reason) }
            if (receipt_number != nil) { try container.encode(receipt_number, forKey: .receipt_number) }
            if (status != nil) { try container.encode(status, forKey: .status) }
            if (metadata != nil) { try container.encode(metadata, forKey: .metadata) }
        }
    }

}