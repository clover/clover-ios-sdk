/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Device {

    public class Device: Codable {

        /// Unique identifier
        public var id: String?
        /// Name of the device (if entered)
        public var name: String?
        public var model: String?
        public var merchant: CLVModels.Base.Reference?
        /// A prefix that will be applied to order numbers. This is useful if the merchant and/or customer needs to track which device an order came from.
        public var orderPrefix: String?
        /// The merchant device's terminal Id. FD-IPG sets the merchant_device terminal Id for LATAM devices
        public var terminalId: String?
        public var terminalPrefix: CLVModels.Variant?
        /// The device's serial number.
        public var serial: String?
        public var buildNumber: Int64?
        public var secureId: String?
        public var buildType: CLVModels.Device.BuildType?
        public var cpuId: String?
        /// The IMEI of the device
        public var imei: String?
        /// The IMSI of the SIM in the device (if present)
        public var imsi: String?
        /// The ICCID of the SIM in the device (if present)
        public var simIccid: String?
        public var deviceCertificate: String?
        public var pedCertificate: String?
        public var deviceTypeName: String?
        public var productName: String?
        /// Whether this device has PIN prompt disabled.
        public var pinDisabled: Bool?
        public var offlinePayments: Bool?
        public var offlinePaymentsAll: Bool?
        public var offlinePaymentsLimit: Int64?
        public var offlinePaymentsPromptThreshold: Int64?
        public var offlinePaymentsTotalPaymentsLimit: Int64?
        public var offlinePaymentsLimitDefault: Int64?
        public var offlinePaymentsPromptThresholdDefault: Int64?
        public var offlinePaymentsTotalPaymentsLimitDefault: Int64?
        public var offlinePaymentsMaxLimit: Int64?
        public var offlinePaymentsMaxTotalPaymentsLimit: Int64?
        public var showOfflinePayments: Bool?
        public var maxOfflineDays: Int64?
        public var allowStoreAndForward: Bool?
        public var secureReports: [CLVModels.Base.Reference]?
        public var bundleIndicator: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case model
            case merchant
            case orderPrefix
            case terminalId
            case terminalPrefix
            case serial
            case buildNumber
            case secureId
            case buildType
            case cpuId
            case imei
            case imsi
            case simIccid
            case deviceCertificate
            case pedCertificate
            case deviceTypeName
            case productName
            case pinDisabled
            case offlinePayments
            case offlinePaymentsAll
            case offlinePaymentsLimit
            case offlinePaymentsPromptThreshold
            case offlinePaymentsTotalPaymentsLimit
            case offlinePaymentsLimitDefault
            case offlinePaymentsPromptThresholdDefault
            case offlinePaymentsTotalPaymentsLimitDefault
            case offlinePaymentsMaxLimit
            case offlinePaymentsMaxTotalPaymentsLimit
            case showOfflinePayments
            case maxOfflineDays
            case allowStoreAndForward
            case secureReports
            case bundleIndicator
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.model = try rootContainer.decodeIfPresent(String.self, forKey: .model)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderPrefix = try rootContainer.decodeIfPresent(String.self, forKey: .orderPrefix)
            } catch {
                decodeError.append(error)
            }
            do {
                self.terminalId = try rootContainer.decodeIfPresent(String.self, forKey: .terminalId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.terminalPrefix = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .terminalPrefix)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serial = try rootContainer.decodeIfPresent(String.self, forKey: .serial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.buildNumber = try rootContainer.decodeIfPresent(Int64.self, forKey: .buildNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.secureId = try rootContainer.decodeIfPresent(String.self, forKey: .secureId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.buildType = try rootContainer.decodeIfPresent(CLVModels.Device.BuildType.self, forKey: .buildType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cpuId = try rootContainer.decodeIfPresent(String.self, forKey: .cpuId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.imei = try rootContainer.decodeIfPresent(String.self, forKey: .imei)
            } catch {
                decodeError.append(error)
            }
            do {
                self.imsi = try rootContainer.decodeIfPresent(String.self, forKey: .imsi)
            } catch {
                decodeError.append(error)
            }
            do {
                self.simIccid = try rootContainer.decodeIfPresent(String.self, forKey: .simIccid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deviceCertificate = try rootContainer.decodeIfPresent(String.self, forKey: .deviceCertificate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pedCertificate = try rootContainer.decodeIfPresent(String.self, forKey: .pedCertificate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deviceTypeName = try rootContainer.decodeIfPresent(String.self, forKey: .deviceTypeName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.productName = try rootContainer.decodeIfPresent(String.self, forKey: .productName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pinDisabled = try rootContainer.decodeIfPresent(Bool.self, forKey: .pinDisabled)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePayments = try rootContainer.decodeIfPresent(Bool.self, forKey: .offlinePayments)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsAll = try rootContainer.decodeIfPresent(Bool.self, forKey: .offlinePaymentsAll)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsLimit = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsPromptThreshold = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsPromptThreshold)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsTotalPaymentsLimit = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsTotalPaymentsLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsLimitDefault = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsLimitDefault)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsPromptThresholdDefault = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsPromptThresholdDefault)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsTotalPaymentsLimitDefault = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsTotalPaymentsLimitDefault)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsMaxLimit = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsMaxLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlinePaymentsMaxTotalPaymentsLimit = try rootContainer.decodeIfPresent(Int64.self, forKey: .offlinePaymentsMaxTotalPaymentsLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.showOfflinePayments = try rootContainer.decodeIfPresent(Bool.self, forKey: .showOfflinePayments)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maxOfflineDays = try rootContainer.decodeIfPresent(Int64.self, forKey: .maxOfflineDays)
            } catch {
                decodeError.append(error)
            }
            do {
                self.allowStoreAndForward = try rootContainer.decodeIfPresent(Bool.self, forKey: .allowStoreAndForward)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.secureReports)) {
                do {
                    let secureReportsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .secureReports)
                    self.secureReports = try secureReportsContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.bundleIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .bundleIndicator)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (model != nil) { try container.encode(model, forKey: .model) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (orderPrefix != nil) { try container.encode(orderPrefix, forKey: .orderPrefix) }
            if (terminalId != nil) { try container.encode(terminalId, forKey: .terminalId) }
            if (terminalPrefix != nil) { try container.encode(terminalPrefix, forKey: .terminalPrefix) }
            if (serial != nil) { try container.encode(serial, forKey: .serial) }
            if (buildNumber != nil) { try container.encode(buildNumber, forKey: .buildNumber) }
            if (secureId != nil) { try container.encode(secureId, forKey: .secureId) }
            if (buildType != nil) { try container.encode(buildType, forKey: .buildType) }
            if (cpuId != nil) { try container.encode(cpuId, forKey: .cpuId) }
            if (imei != nil) { try container.encode(imei, forKey: .imei) }
            if (imsi != nil) { try container.encode(imsi, forKey: .imsi) }
            if (simIccid != nil) { try container.encode(simIccid, forKey: .simIccid) }
            if (deviceCertificate != nil) { try container.encode(deviceCertificate, forKey: .deviceCertificate) }
            if (pedCertificate != nil) { try container.encode(pedCertificate, forKey: .pedCertificate) }
            if (deviceTypeName != nil) { try container.encode(deviceTypeName, forKey: .deviceTypeName) }
            if (productName != nil) { try container.encode(productName, forKey: .productName) }
            if (pinDisabled != nil) { try container.encode(pinDisabled, forKey: .pinDisabled) }
            if (offlinePayments != nil) { try container.encode(offlinePayments, forKey: .offlinePayments) }
            if (offlinePaymentsAll != nil) { try container.encode(offlinePaymentsAll, forKey: .offlinePaymentsAll) }
            if (offlinePaymentsLimit != nil) { try container.encode(offlinePaymentsLimit, forKey: .offlinePaymentsLimit) }
            if (offlinePaymentsPromptThreshold != nil) { try container.encode(offlinePaymentsPromptThreshold, forKey: .offlinePaymentsPromptThreshold) }
            if (offlinePaymentsTotalPaymentsLimit != nil) { try container.encode(offlinePaymentsTotalPaymentsLimit, forKey: .offlinePaymentsTotalPaymentsLimit) }
            if (offlinePaymentsLimitDefault != nil) { try container.encode(offlinePaymentsLimitDefault, forKey: .offlinePaymentsLimitDefault) }
            if (offlinePaymentsPromptThresholdDefault != nil) { try container.encode(offlinePaymentsPromptThresholdDefault, forKey: .offlinePaymentsPromptThresholdDefault) }
            if (offlinePaymentsTotalPaymentsLimitDefault != nil) { try container.encode(offlinePaymentsTotalPaymentsLimitDefault, forKey: .offlinePaymentsTotalPaymentsLimitDefault) }
            if (offlinePaymentsMaxLimit != nil) { try container.encode(offlinePaymentsMaxLimit, forKey: .offlinePaymentsMaxLimit) }
            if (offlinePaymentsMaxTotalPaymentsLimit != nil) { try container.encode(offlinePaymentsMaxTotalPaymentsLimit, forKey: .offlinePaymentsMaxTotalPaymentsLimit) }
            if (showOfflinePayments != nil) { try container.encode(showOfflinePayments, forKey: .showOfflinePayments) }
            if (maxOfflineDays != nil) { try container.encode(maxOfflineDays, forKey: .maxOfflineDays) }
            if (allowStoreAndForward != nil) { try container.encode(allowStoreAndForward, forKey: .allowStoreAndForward) }
            if (secureReports != nil) { try container.encode(secureReports, forKey: .secureReports) }
            if (bundleIndicator != nil) { try container.encode(bundleIndicator, forKey: .bundleIndicator) }
        }
    }

}