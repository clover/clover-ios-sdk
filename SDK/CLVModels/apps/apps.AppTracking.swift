/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    Used to track the origin of a distributed call.
*/

import Foundation

extension CLVModels.Apps {

    public class AppTracking: Codable {

        /// The uuid from the developer application.  This is typically populated and used only on the back end.
        public var developerAppId: String?
        /// The name of the developer application.
        public var applicationName: String?
        /// A string representing an application
        public var applicationID: String?
        /// A string representing a semanticversion.  See http://semver.org/
        public var applicationVersion: String?
        /// A string representing a SDK
        public var sourceSDK: String?
        /// A string representing a semanticversion.  See http://semver.org/
        public var sourceSDKVersion: String?
        /// The payment with which this app tracking info is associated
        public var paymentRef: CLVModels.Base.Reference?
        /// The credit with which this app tracking info is associated
        public var creditRef: CLVModels.Base.Reference?
        /// The refund with which this app tracking info is associated
        public var refundRef: CLVModels.Base.Reference?
        /// The credit refund with which this app tracking info is associated
        public var creditRefundRef: CLVModels.Base.Reference?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case developerAppId
            case applicationName
            case applicationID
            case applicationVersion
            case sourceSDK
            case sourceSDKVersion
            case paymentRef
            case creditRef
            case refundRef
            case creditRefundRef
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.developerAppId = try rootContainer.decodeIfPresent(String.self, forKey: .developerAppId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.applicationName = try rootContainer.decodeIfPresent(String.self, forKey: .applicationName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.applicationID = try rootContainer.decodeIfPresent(String.self, forKey: .applicationID)
            } catch {
                decodeError.append(error)
            }
            do {
                self.applicationVersion = try rootContainer.decodeIfPresent(String.self, forKey: .applicationVersion)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sourceSDK = try rootContainer.decodeIfPresent(String.self, forKey: .sourceSDK)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sourceSDKVersion = try rootContainer.decodeIfPresent(String.self, forKey: .sourceSDKVersion)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .paymentRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .refundRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRefundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRefundRef)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (developerAppId != nil) { try container.encode(developerAppId, forKey: .developerAppId) }
            if (applicationName != nil) { try container.encode(applicationName, forKey: .applicationName) }
            if (applicationID != nil) { try container.encode(applicationID, forKey: .applicationID) }
            if (applicationVersion != nil) { try container.encode(applicationVersion, forKey: .applicationVersion) }
            if (sourceSDK != nil) { try container.encode(sourceSDK, forKey: .sourceSDK) }
            if (sourceSDKVersion != nil) { try container.encode(sourceSDKVersion, forKey: .sourceSDKVersion) }
            if (paymentRef != nil) { try container.encode(paymentRef, forKey: .paymentRef) }
            if (creditRef != nil) { try container.encode(creditRef, forKey: .creditRef) }
            if (refundRef != nil) { try container.encode(refundRef, forKey: .refundRef) }
            if (creditRefundRef != nil) { try container.encode(creditRefundRef, forKey: .creditRefundRef) }
        }
    }

}