/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Remotepay {

    public class BaseTransactionRequest: Codable {

        /// The superClass
        public var _meta_superclass: CLVModels.Remotepay.BaseRequest?
        /// Identifier for the order to apply this to. The order must exist in the clover system.  **NOTE**  THIS FIELD IS ONLY USED BY THE PAYMENT CONNECTOR. It provides functionality currently available to the native PayIntent but not supported yet by the remote pay SDKs
        public var orderId: String?
        /// If true, then do not print using the clover printer.  Return print information.
        public var disablePrinting: CLVModels.Variant?
        /// Do not show the receipt options screen
        public var disableReceiptSelection: CLVModels.Variant?
        /// Do not do heuristic duplicate checking
        public var disableDuplicateChecking: CLVModels.Variant?
        /// If true then card not present is accepted
        public var cardNotPresent: CLVModels.Variant?
        /// If the transaction times out or fails because of decline, do not restart it
        public var disableRestartTransactionOnFail: CLVModels.Variant?
        /// Total amount paid
        public var amount: Int64?
        /// Allowed entry methods
        public var cardEntryMethods: CLVModels.Variant?
        /// A saved card
        public var vaultedCard: CLVModels.Variant?
        /// An id that will be persisted with transactions.
        public var externalId: String?
        /// The type of the transaction.
        public var type_: CLVModels.Remotepay.TransactionType?
        /// Do not show/send potential duplicate challenges
        public var autoAcceptPaymentConfirmations: CLVModels.Variant?
        /// Extra pass-through data used by external systems.
        public var extras: [String:String]?
        /// A map of values for regional specific data
        public var regionalExtras: [String:String]?
        /// An id that can be passed to the merchant's gateway, and ultimately appear in settlement records.
        public var externalReferenceId: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case _meta_superclass
            case orderId
            case disablePrinting
            case disableReceiptSelection
            case disableDuplicateChecking
            case cardNotPresent
            case disableRestartTransactionOnFail
            case amount
            case cardEntryMethods
            case vaultedCard
            case externalId
            case type
            case autoAcceptPaymentConfirmations
            case extras
            case regionalExtras
            case externalReferenceId
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self._meta_superclass = try rootContainer.decodeIfPresent(CLVModels.Remotepay.BaseRequest.self, forKey: ._meta_superclass)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderId = try rootContainer.decodeIfPresent(String.self, forKey: .orderId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disablePrinting = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .disablePrinting)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableReceiptSelection = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .disableReceiptSelection)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableDuplicateChecking = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .disableDuplicateChecking)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardNotPresent = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cardNotPresent)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableRestartTransactionOnFail = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .disableRestartTransactionOnFail)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardEntryMethods = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cardEntryMethods)
            } catch {
                decodeError.append(error)
            }
            do {
                self.vaultedCard = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .vaultedCard)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalId = try rootContainer.decodeIfPresent(String.self, forKey: .externalId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Remotepay.TransactionType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.autoAcceptPaymentConfirmations = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .autoAcceptPaymentConfirmations)
            } catch {
                decodeError.append(error)
            }
            do {
                self.extras = try rootContainer.decodeIfPresent([String:String].self, forKey: .extras)
            } catch {
                decodeError.append(error)
            }
            do {
                self.regionalExtras = try rootContainer.decodeIfPresent([String:String].self, forKey: .regionalExtras)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(String.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (_meta_superclass != nil) { try container.encode(_meta_superclass, forKey: ._meta_superclass) }
            if (orderId != nil) { try container.encode(orderId, forKey: .orderId) }
            if (disablePrinting != nil) { try container.encode(disablePrinting, forKey: .disablePrinting) }
            if (disableReceiptSelection != nil) { try container.encode(disableReceiptSelection, forKey: .disableReceiptSelection) }
            if (disableDuplicateChecking != nil) { try container.encode(disableDuplicateChecking, forKey: .disableDuplicateChecking) }
            if (cardNotPresent != nil) { try container.encode(cardNotPresent, forKey: .cardNotPresent) }
            if (disableRestartTransactionOnFail != nil) { try container.encode(disableRestartTransactionOnFail, forKey: .disableRestartTransactionOnFail) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (cardEntryMethods != nil) { try container.encode(cardEntryMethods, forKey: .cardEntryMethods) }
            if (vaultedCard != nil) { try container.encode(vaultedCard, forKey: .vaultedCard) }
            if (externalId != nil) { try container.encode(externalId, forKey: .externalId) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (autoAcceptPaymentConfirmations != nil) { try container.encode(autoAcceptPaymentConfirmations, forKey: .autoAcceptPaymentConfirmations) }
            if (extras != nil) { try container.encode(extras, forKey: .extras) }
            if (regionalExtras != nil) { try container.encode(regionalExtras, forKey: .regionalExtras) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
        }
    }

}