/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    Additional device data collected during merchant boarding.
*/

import Foundation

extension CLVModels.Merchant {

    public class MerchantDeviceBoarding: Codable {

        public var merchantRef: CLVModels.Base.Reference?
        /// Device product type
        public var productType: String?
        /// Equipment number
        public var equipmentNumber: String?
        /// Business type
        public var businessType: String?
        /// Device status
        public var status: String?
        /// TransArmor indicator
        public var transArmorIndicator: String?
        /// Force close time
        public var forceCloseTime: String?
        /// Date record created
        public var createdTime: Date?
        /// Date record updated
        public var modifiedTime: Date?
        public var serialNumber: String?
        public var bundleIndicator: String?
        /// Date device removed from merchant
        public var removalTime: Date?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case merchantRef
            case productType
            case equipmentNumber
            case businessType
            case status
            case transArmorIndicator
            case forceCloseTime
            case createdTime
            case modifiedTime
            case serialNumber
            case bundleIndicator
            case removalTime
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.merchantRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchantRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.productType = try rootContainer.decodeIfPresent(String.self, forKey: .productType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.equipmentNumber = try rootContainer.decodeIfPresent(String.self, forKey: .equipmentNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessType = try rootContainer.decodeIfPresent(String.self, forKey: .businessType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.status = try rootContainer.decodeIfPresent(String.self, forKey: .status)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.forceCloseTime = try rootContainer.decodeIfPresent(String.self, forKey: .forceCloseTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serialNumber = try rootContainer.decodeIfPresent(String.self, forKey: .serialNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bundleIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .bundleIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.removalTime = try rootContainer.decodeIfPresent(Date.self, forKey: .removalTime)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (merchantRef != nil) { try container.encode(merchantRef, forKey: .merchantRef) }
            if (productType != nil) { try container.encode(productType, forKey: .productType) }
            if (equipmentNumber != nil) { try container.encode(equipmentNumber, forKey: .equipmentNumber) }
            if (businessType != nil) { try container.encode(businessType, forKey: .businessType) }
            if (status != nil) { try container.encode(status, forKey: .status) }
            if (transArmorIndicator != nil) { try container.encode(transArmorIndicator, forKey: .transArmorIndicator) }
            if (forceCloseTime != nil) { try container.encode(forceCloseTime, forKey: .forceCloseTime) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (serialNumber != nil) { try container.encode(serialNumber, forKey: .serialNumber) }
            if (bundleIndicator != nil) { try container.encode(bundleIndicator, forKey: .bundleIndicator) }
            if (removalTime != nil) { try container.encode(removalTime, forKey: .removalTime) }
        }
    }

}