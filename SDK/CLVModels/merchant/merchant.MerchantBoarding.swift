/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    Additional supporting merchant data sent from FDPOS during merchant boarding.
*/

import Foundation

extension CLVModels.Merchant {

    public class MerchantBoarding: Codable {

        public var merchantRef: CLVModels.Base.Reference?
        /// The name to bill the merchant to
        public var billToName: String?
        /// ID of automated clearing house bank
        public var achBankId: String?
        /// Status code of the account as received from FDPOS
        public var accountStatus: String?
        /// Translated Merchant Billing Account Status based on the FDPOS account status code received
        public var translatedAccountStatus: CLVModels.Merchant.MerchantAccountStatus?
        /// Store identifier
        public var store: String?
        /// Indicator if daylight savings followed by merchant
        public var daylightSavings: Bool?
        /// True if merchant is a seasonal business
        public var seasonal: Bool?
        /// FD TransArmor public key
        public var transArmorKey: String?
        /// Credit limit
        public var creditLimit: Double?
        /// Authorization limit
        public var authLimit: Double?
        /// Sale limit
        public var saleLimit: Double?
        public var externalMerchant: Bool?
        /// True if allows dynamic Doing Business As (DBA)
        public var dynamicDba: Bool?
        /// Relationship manager
        public var relationshipManager: String?
        /// True if merchant is tax exempt
        public var taxExempt: Bool?
        /// Salesman
        public var salesman: String?
        /// True if merchant supports ValueLink
        public var valueLink: Bool?
        /// ValueLink MID
        public var valueLinkMid: String?
        /// Alternative ValueLink MID
        public var altValueLinkMid: String?
        /// Doing Business As (DBA) receipt
        public var receiptDba: String?
        /// Bank Number
        public var bankNumber: String?
        /// ID of merchant's parent
        public var parentMerchantId: String?
        /// Type of Multi-Merchant terminal
        public var multiMerchantType: String?
        /// Merchant data
        public var merchantData: String?
        /// Merchant fax number
        public var faxPhone: String?
        /// Type of merchant
        public var merchantType: String?
        /// Multi-currency indicator
        public var multiCurrencyIndicator: String?
        /// Preferred merchant flag
        public var preferredMerchant: String?
        /// 
        public var visaIram: String?
        /// TransArmor indicator
        public var transArmorIndicator: String?
        /// Signing key
        public var signingKey: String?
        /// Does merchant accept Visa debit
        public var visaDebitAccept: String?
        /// Does merchant accept MasterCard debit
        public var mastercardDebitAccept: String?
        /// Source indicator
        public var sourceIndicator: String?
        /// Indicates foreign or domestic merchant
        public var foreignDomesticIndicator: String?
        /// Account funding
        public var accountFunding: String?
        /// Direct marketing
        public var directMarketing: String?
        /// Participant relationship
        public var participantRelationship: String?
        /// Process settlement
        public var processSettlement: String?
        /// Recurring flag
        public var recurringFlag: String?
        /// Link from
        public var linkFrom: String?
        /// Link to
        public var linkTo: String?
        /// Is EMV chip allowed
        public var emvAllowed: String?
        /// Previous status of account
        public var previousAccountStatus: String?
        /// Lease company code
        public var leaseCompanyCode: String?
        /// Process mode
        public var processMode: String?
        /// Agent bank indicator
        public var agentBankIndicator: String?
        /// 
        public var nonMpaIndicator: String?
        /// Merchant internet indicator
        public var internetIndicator: String?
        /// Charge back retrieval address flag
        public var chargeBackRetrievalAddressFlag: String?
        /// VI relationship participant
        public var viRelationshipParticipant: String?
        /// Retail description
        public var retailDescription: String?
        /// Client representative
        public var clientRepresentative: String?
        /// Merchant authorization type
        public var merchantAuthType: String?
        /// Sys-Prin of reseller channel for this merchant
        public var sysPrin: String?
        /// tax id of this merchant
        public var taxId: String?
        /// business type of this merchant
        public var businessType: String?
        /// partner id of this merchant
        public var partnerId: String?
        /// When record created
        public var createdTime: Date?
        /// When record updated
        public var modifiedTime: Date?
        public var creationSource: CLVModels.Merchant.MerchantCreationSource?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case merchantRef
            case billToName
            case achBankId
            case accountStatus
            case translatedAccountStatus
            case store
            case daylightSavings
            case seasonal
            case transArmorKey
            case creditLimit
            case authLimit
            case saleLimit
            case externalMerchant
            case dynamicDba
            case relationshipManager
            case taxExempt
            case salesman
            case valueLink
            case valueLinkMid
            case altValueLinkMid
            case receiptDba
            case bankNumber
            case parentMerchantId
            case multiMerchantType
            case merchantData
            case faxPhone
            case merchantType
            case multiCurrencyIndicator
            case preferredMerchant
            case visaIram
            case transArmorIndicator
            case signingKey
            case visaDebitAccept
            case mastercardDebitAccept
            case sourceIndicator
            case foreignDomesticIndicator
            case accountFunding
            case directMarketing
            case participantRelationship
            case processSettlement
            case recurringFlag
            case linkFrom
            case linkTo
            case emvAllowed
            case previousAccountStatus
            case leaseCompanyCode
            case processMode
            case agentBankIndicator
            case nonMpaIndicator
            case internetIndicator
            case chargeBackRetrievalAddressFlag
            case viRelationshipParticipant
            case retailDescription
            case clientRepresentative
            case merchantAuthType
            case sysPrin
            case taxId
            case businessType
            case partnerId
            case createdTime
            case modifiedTime
            case creationSource
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.merchantRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchantRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billToName = try rootContainer.decodeIfPresent(String.self, forKey: .billToName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.achBankId = try rootContainer.decodeIfPresent(String.self, forKey: .achBankId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountStatus = try rootContainer.decodeIfPresent(String.self, forKey: .accountStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.translatedAccountStatus = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantAccountStatus.self, forKey: .translatedAccountStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.store = try rootContainer.decodeIfPresent(String.self, forKey: .store)
            } catch {
                decodeError.append(error)
            }
            do {
                self.daylightSavings = try rootContainer.decodeIfPresent(Bool.self, forKey: .daylightSavings)
            } catch {
                decodeError.append(error)
            }
            do {
                self.seasonal = try rootContainer.decodeIfPresent(Bool.self, forKey: .seasonal)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorKey = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorKey)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditLimit = try rootContainer.decodeIfPresent(Double.self, forKey: .creditLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authLimit = try rootContainer.decodeIfPresent(Double.self, forKey: .authLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.saleLimit = try rootContainer.decodeIfPresent(Double.self, forKey: .saleLimit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalMerchant = try rootContainer.decodeIfPresent(Bool.self, forKey: .externalMerchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dynamicDba = try rootContainer.decodeIfPresent(Bool.self, forKey: .dynamicDba)
            } catch {
                decodeError.append(error)
            }
            do {
                self.relationshipManager = try rootContainer.decodeIfPresent(String.self, forKey: .relationshipManager)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxExempt = try rootContainer.decodeIfPresent(Bool.self, forKey: .taxExempt)
            } catch {
                decodeError.append(error)
            }
            do {
                self.salesman = try rootContainer.decodeIfPresent(String.self, forKey: .salesman)
            } catch {
                decodeError.append(error)
            }
            do {
                self.valueLink = try rootContainer.decodeIfPresent(Bool.self, forKey: .valueLink)
            } catch {
                decodeError.append(error)
            }
            do {
                self.valueLinkMid = try rootContainer.decodeIfPresent(String.self, forKey: .valueLinkMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.altValueLinkMid = try rootContainer.decodeIfPresent(String.self, forKey: .altValueLinkMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receiptDba = try rootContainer.decodeIfPresent(String.self, forKey: .receiptDba)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bankNumber = try rootContainer.decodeIfPresent(String.self, forKey: .bankNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.parentMerchantId = try rootContainer.decodeIfPresent(String.self, forKey: .parentMerchantId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.multiMerchantType = try rootContainer.decodeIfPresent(String.self, forKey: .multiMerchantType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantData = try rootContainer.decodeIfPresent(String.self, forKey: .merchantData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.faxPhone = try rootContainer.decodeIfPresent(String.self, forKey: .faxPhone)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantType = try rootContainer.decodeIfPresent(String.self, forKey: .merchantType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.multiCurrencyIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .multiCurrencyIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.preferredMerchant = try rootContainer.decodeIfPresent(String.self, forKey: .preferredMerchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.visaIram = try rootContainer.decodeIfPresent(String.self, forKey: .visaIram)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signingKey = try rootContainer.decodeIfPresent(String.self, forKey: .signingKey)
            } catch {
                decodeError.append(error)
            }
            do {
                self.visaDebitAccept = try rootContainer.decodeIfPresent(String.self, forKey: .visaDebitAccept)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mastercardDebitAccept = try rootContainer.decodeIfPresent(String.self, forKey: .mastercardDebitAccept)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sourceIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .sourceIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.foreignDomesticIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .foreignDomesticIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountFunding = try rootContainer.decodeIfPresent(String.self, forKey: .accountFunding)
            } catch {
                decodeError.append(error)
            }
            do {
                self.directMarketing = try rootContainer.decodeIfPresent(String.self, forKey: .directMarketing)
            } catch {
                decodeError.append(error)
            }
            do {
                self.participantRelationship = try rootContainer.decodeIfPresent(String.self, forKey: .participantRelationship)
            } catch {
                decodeError.append(error)
            }
            do {
                self.processSettlement = try rootContainer.decodeIfPresent(String.self, forKey: .processSettlement)
            } catch {
                decodeError.append(error)
            }
            do {
                self.recurringFlag = try rootContainer.decodeIfPresent(String.self, forKey: .recurringFlag)
            } catch {
                decodeError.append(error)
            }
            do {
                self.linkFrom = try rootContainer.decodeIfPresent(String.self, forKey: .linkFrom)
            } catch {
                decodeError.append(error)
            }
            do {
                self.linkTo = try rootContainer.decodeIfPresent(String.self, forKey: .linkTo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.emvAllowed = try rootContainer.decodeIfPresent(String.self, forKey: .emvAllowed)
            } catch {
                decodeError.append(error)
            }
            do {
                self.previousAccountStatus = try rootContainer.decodeIfPresent(String.self, forKey: .previousAccountStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.leaseCompanyCode = try rootContainer.decodeIfPresent(String.self, forKey: .leaseCompanyCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.processMode = try rootContainer.decodeIfPresent(String.self, forKey: .processMode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.agentBankIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .agentBankIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.nonMpaIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .nonMpaIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.internetIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .internetIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.chargeBackRetrievalAddressFlag = try rootContainer.decodeIfPresent(String.self, forKey: .chargeBackRetrievalAddressFlag)
            } catch {
                decodeError.append(error)
            }
            do {
                self.viRelationshipParticipant = try rootContainer.decodeIfPresent(String.self, forKey: .viRelationshipParticipant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.retailDescription = try rootContainer.decodeIfPresent(String.self, forKey: .retailDescription)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientRepresentative = try rootContainer.decodeIfPresent(String.self, forKey: .clientRepresentative)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantAuthType = try rootContainer.decodeIfPresent(String.self, forKey: .merchantAuthType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sysPrin = try rootContainer.decodeIfPresent(String.self, forKey: .sysPrin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxId = try rootContainer.decodeIfPresent(String.self, forKey: .taxId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.businessType = try rootContainer.decodeIfPresent(String.self, forKey: .businessType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.partnerId = try rootContainer.decodeIfPresent(String.self, forKey: .partnerId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creationSource = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantCreationSource.self, forKey: .creationSource)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (merchantRef != nil) { try container.encode(merchantRef, forKey: .merchantRef) }
            if (billToName != nil) { try container.encode(billToName, forKey: .billToName) }
            if (achBankId != nil) { try container.encode(achBankId, forKey: .achBankId) }
            if (accountStatus != nil) { try container.encode(accountStatus, forKey: .accountStatus) }
            if (translatedAccountStatus != nil) { try container.encode(translatedAccountStatus, forKey: .translatedAccountStatus) }
            if (store != nil) { try container.encode(store, forKey: .store) }
            if (daylightSavings != nil) { try container.encode(daylightSavings, forKey: .daylightSavings) }
            if (seasonal != nil) { try container.encode(seasonal, forKey: .seasonal) }
            if (transArmorKey != nil) { try container.encode(transArmorKey, forKey: .transArmorKey) }
            if (creditLimit != nil) { try container.encode(creditLimit, forKey: .creditLimit) }
            if (authLimit != nil) { try container.encode(authLimit, forKey: .authLimit) }
            if (saleLimit != nil) { try container.encode(saleLimit, forKey: .saleLimit) }
            if (externalMerchant != nil) { try container.encode(externalMerchant, forKey: .externalMerchant) }
            if (dynamicDba != nil) { try container.encode(dynamicDba, forKey: .dynamicDba) }
            if (relationshipManager != nil) { try container.encode(relationshipManager, forKey: .relationshipManager) }
            if (taxExempt != nil) { try container.encode(taxExempt, forKey: .taxExempt) }
            if (salesman != nil) { try container.encode(salesman, forKey: .salesman) }
            if (valueLink != nil) { try container.encode(valueLink, forKey: .valueLink) }
            if (valueLinkMid != nil) { try container.encode(valueLinkMid, forKey: .valueLinkMid) }
            if (altValueLinkMid != nil) { try container.encode(altValueLinkMid, forKey: .altValueLinkMid) }
            if (receiptDba != nil) { try container.encode(receiptDba, forKey: .receiptDba) }
            if (bankNumber != nil) { try container.encode(bankNumber, forKey: .bankNumber) }
            if (parentMerchantId != nil) { try container.encode(parentMerchantId, forKey: .parentMerchantId) }
            if (multiMerchantType != nil) { try container.encode(multiMerchantType, forKey: .multiMerchantType) }
            if (merchantData != nil) { try container.encode(merchantData, forKey: .merchantData) }
            if (faxPhone != nil) { try container.encode(faxPhone, forKey: .faxPhone) }
            if (merchantType != nil) { try container.encode(merchantType, forKey: .merchantType) }
            if (multiCurrencyIndicator != nil) { try container.encode(multiCurrencyIndicator, forKey: .multiCurrencyIndicator) }
            if (preferredMerchant != nil) { try container.encode(preferredMerchant, forKey: .preferredMerchant) }
            if (visaIram != nil) { try container.encode(visaIram, forKey: .visaIram) }
            if (transArmorIndicator != nil) { try container.encode(transArmorIndicator, forKey: .transArmorIndicator) }
            if (signingKey != nil) { try container.encode(signingKey, forKey: .signingKey) }
            if (visaDebitAccept != nil) { try container.encode(visaDebitAccept, forKey: .visaDebitAccept) }
            if (mastercardDebitAccept != nil) { try container.encode(mastercardDebitAccept, forKey: .mastercardDebitAccept) }
            if (sourceIndicator != nil) { try container.encode(sourceIndicator, forKey: .sourceIndicator) }
            if (foreignDomesticIndicator != nil) { try container.encode(foreignDomesticIndicator, forKey: .foreignDomesticIndicator) }
            if (accountFunding != nil) { try container.encode(accountFunding, forKey: .accountFunding) }
            if (directMarketing != nil) { try container.encode(directMarketing, forKey: .directMarketing) }
            if (participantRelationship != nil) { try container.encode(participantRelationship, forKey: .participantRelationship) }
            if (processSettlement != nil) { try container.encode(processSettlement, forKey: .processSettlement) }
            if (recurringFlag != nil) { try container.encode(recurringFlag, forKey: .recurringFlag) }
            if (linkFrom != nil) { try container.encode(linkFrom, forKey: .linkFrom) }
            if (linkTo != nil) { try container.encode(linkTo, forKey: .linkTo) }
            if (emvAllowed != nil) { try container.encode(emvAllowed, forKey: .emvAllowed) }
            if (previousAccountStatus != nil) { try container.encode(previousAccountStatus, forKey: .previousAccountStatus) }
            if (leaseCompanyCode != nil) { try container.encode(leaseCompanyCode, forKey: .leaseCompanyCode) }
            if (processMode != nil) { try container.encode(processMode, forKey: .processMode) }
            if (agentBankIndicator != nil) { try container.encode(agentBankIndicator, forKey: .agentBankIndicator) }
            if (nonMpaIndicator != nil) { try container.encode(nonMpaIndicator, forKey: .nonMpaIndicator) }
            if (internetIndicator != nil) { try container.encode(internetIndicator, forKey: .internetIndicator) }
            if (chargeBackRetrievalAddressFlag != nil) { try container.encode(chargeBackRetrievalAddressFlag, forKey: .chargeBackRetrievalAddressFlag) }
            if (viRelationshipParticipant != nil) { try container.encode(viRelationshipParticipant, forKey: .viRelationshipParticipant) }
            if (retailDescription != nil) { try container.encode(retailDescription, forKey: .retailDescription) }
            if (clientRepresentative != nil) { try container.encode(clientRepresentative, forKey: .clientRepresentative) }
            if (merchantAuthType != nil) { try container.encode(merchantAuthType, forKey: .merchantAuthType) }
            if (sysPrin != nil) { try container.encode(sysPrin, forKey: .sysPrin) }
            if (taxId != nil) { try container.encode(taxId, forKey: .taxId) }
            if (businessType != nil) { try container.encode(businessType, forKey: .businessType) }
            if (partnerId != nil) { try container.encode(partnerId, forKey: .partnerId) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (creationSource != nil) { try container.encode(creationSource, forKey: .creationSource) }
        }
    }

}