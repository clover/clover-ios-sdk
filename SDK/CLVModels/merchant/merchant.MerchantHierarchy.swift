/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */

/*
    Chain/corporate references and legal/billing/banking information for a merchant. Can also represent corporations/franchise organizations without Clover devices.
*/

import Foundation

extension CLVModels.Merchant {

    public class MerchantHierarchy: Codable {

        /// Merchant ID
        public var mid: String?
        /// Chain bank
        public var chain: String?
        /// Corporate ID
        public var corporate: String?
        /// Agent ID
        public var agent: String?
        /// Bank ID
        public var bank: String?
        /// Business ID
        public var business: String?
        /// MAPS ID
        public var maps: String?
        /// Association Number
        public var association: String?
        /// Customer ID
        public var customer: String?
        /// Bill to name
        public var billName: String?
        /// DBA name
        public var dbaName: String?
        /// DBA attention name
        public var dbaAttention: String?
        /// Legal name
        public var legalName: String?
        /// Bill To attention
        public var billToAttention: String?
        /// Email
        public var email: String?
        /// ABA account number
        public var abaAccountNumber: String?
        /// DDA account number
        public var ddaAccountNumber: String?
        /// DBA address
        public var dbaAddress: String?
        /// DBA city
        public var dbaCity: String?
        /// DBA state
        public var dbaState: String?
        /// DBA zip
        public var dbaZip: String?
        /// DBA phone number
        public var dbaPhoneNumber: String?
        /// Bill To city
        public var billCity: String?
        /// Bill To state
        public var billState: String?
        /// Bill To ZIP
        public var billZip: String?
        /// Bill To phone number
        public var billPhoneNumber: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case mid
            case chain
            case corporate
            case agent
            case bank
            case business
            case maps
            case association
            case customer
            case billName
            case dbaName
            case dbaAttention
            case legalName
            case billToAttention
            case email
            case abaAccountNumber
            case ddaAccountNumber
            case dbaAddress
            case dbaCity
            case dbaState
            case dbaZip
            case dbaPhoneNumber
            case billCity
            case billState
            case billZip
            case billPhoneNumber
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.mid = try rootContainer.decodeIfPresent(String.self, forKey: .mid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.chain = try rootContainer.decodeIfPresent(String.self, forKey: .chain)
            } catch {
                decodeError.append(error)
            }
            do {
                self.corporate = try rootContainer.decodeIfPresent(String.self, forKey: .corporate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.agent = try rootContainer.decodeIfPresent(String.self, forKey: .agent)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bank = try rootContainer.decodeIfPresent(String.self, forKey: .bank)
            } catch {
                decodeError.append(error)
            }
            do {
                self.business = try rootContainer.decodeIfPresent(String.self, forKey: .business)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maps = try rootContainer.decodeIfPresent(String.self, forKey: .maps)
            } catch {
                decodeError.append(error)
            }
            do {
                self.association = try rootContainer.decodeIfPresent(String.self, forKey: .association)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customer = try rootContainer.decodeIfPresent(String.self, forKey: .customer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billName = try rootContainer.decodeIfPresent(String.self, forKey: .billName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaName = try rootContainer.decodeIfPresent(String.self, forKey: .dbaName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaAttention = try rootContainer.decodeIfPresent(String.self, forKey: .dbaAttention)
            } catch {
                decodeError.append(error)
            }
            do {
                self.legalName = try rootContainer.decodeIfPresent(String.self, forKey: .legalName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billToAttention = try rootContainer.decodeIfPresent(String.self, forKey: .billToAttention)
            } catch {
                decodeError.append(error)
            }
            do {
                self.email = try rootContainer.decodeIfPresent(String.self, forKey: .email)
            } catch {
                decodeError.append(error)
            }
            do {
                self.abaAccountNumber = try rootContainer.decodeIfPresent(String.self, forKey: .abaAccountNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ddaAccountNumber = try rootContainer.decodeIfPresent(String.self, forKey: .ddaAccountNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaAddress = try rootContainer.decodeIfPresent(String.self, forKey: .dbaAddress)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaCity = try rootContainer.decodeIfPresent(String.self, forKey: .dbaCity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaState = try rootContainer.decodeIfPresent(String.self, forKey: .dbaState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaZip = try rootContainer.decodeIfPresent(String.self, forKey: .dbaZip)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dbaPhoneNumber = try rootContainer.decodeIfPresent(String.self, forKey: .dbaPhoneNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billCity = try rootContainer.decodeIfPresent(String.self, forKey: .billCity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billState = try rootContainer.decodeIfPresent(String.self, forKey: .billState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billZip = try rootContainer.decodeIfPresent(String.self, forKey: .billZip)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billPhoneNumber = try rootContainer.decodeIfPresent(String.self, forKey: .billPhoneNumber)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (mid != nil) { try container.encode(mid, forKey: .mid) }
            if (chain != nil) { try container.encode(chain, forKey: .chain) }
            if (corporate != nil) { try container.encode(corporate, forKey: .corporate) }
            if (agent != nil) { try container.encode(agent, forKey: .agent) }
            if (bank != nil) { try container.encode(bank, forKey: .bank) }
            if (business != nil) { try container.encode(business, forKey: .business) }
            if (maps != nil) { try container.encode(maps, forKey: .maps) }
            if (association != nil) { try container.encode(association, forKey: .association) }
            if (customer != nil) { try container.encode(customer, forKey: .customer) }
            if (billName != nil) { try container.encode(billName, forKey: .billName) }
            if (dbaName != nil) { try container.encode(dbaName, forKey: .dbaName) }
            if (dbaAttention != nil) { try container.encode(dbaAttention, forKey: .dbaAttention) }
            if (legalName != nil) { try container.encode(legalName, forKey: .legalName) }
            if (billToAttention != nil) { try container.encode(billToAttention, forKey: .billToAttention) }
            if (email != nil) { try container.encode(email, forKey: .email) }
            if (abaAccountNumber != nil) { try container.encode(abaAccountNumber, forKey: .abaAccountNumber) }
            if (ddaAccountNumber != nil) { try container.encode(ddaAccountNumber, forKey: .ddaAccountNumber) }
            if (dbaAddress != nil) { try container.encode(dbaAddress, forKey: .dbaAddress) }
            if (dbaCity != nil) { try container.encode(dbaCity, forKey: .dbaCity) }
            if (dbaState != nil) { try container.encode(dbaState, forKey: .dbaState) }
            if (dbaZip != nil) { try container.encode(dbaZip, forKey: .dbaZip) }
            if (dbaPhoneNumber != nil) { try container.encode(dbaPhoneNumber, forKey: .dbaPhoneNumber) }
            if (billCity != nil) { try container.encode(billCity, forKey: .billCity) }
            if (billState != nil) { try container.encode(billState, forKey: .billState) }
            if (billZip != nil) { try container.encode(billZip, forKey: .billZip) }
            if (billPhoneNumber != nil) { try container.encode(billPhoneNumber, forKey: .billPhoneNumber) }
        }
    }

}