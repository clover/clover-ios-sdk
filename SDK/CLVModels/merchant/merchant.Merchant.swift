/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Merchant {

    public class Merchant: Codable {

        /// Unique identifier
        public var id: String?
        /// Name of the merchant
        public var name: String?
        /// The account that owns this merchant
        public var owner: CLVModels.Employees.Employee?
        /// The address of the merchant.
        public var address: CLVModels.Base.Address?
        public var merchantPlan: CLVModels.Variant?
        public var defaultCurrency: String?
        /// DEPRECATED: Use phoneNumber field in address instead. This field may contain an incorrect value and should neither be read nor written.
        public var phoneNumber: String?
        public var website: String?
        /// Email address for customers to contact merchant through
        public var customerContactEmail: String?
        public var logos: [CLVModels.Merchant.Logo]?
        public var createdTime: Date?
        public var properties: CLVModels.Merchant.MerchantProperties?
        public var gateway: CLVModels.Merchant.Gateway?
        public var tipSuggestions: [CLVModels.Merchant.TipSuggestion]?
        /// This merchant's employees
        public var employees: [CLVModels.Employees.Employee]?
        /// This merchant's inventory items
        public var items: [CLVModels.Inventory.Item]?
        /// This merchant's inventory tags
        public var tags: [CLVModels.Inventory.Tag]?
        /// This merchant's supported tenders
        public var tenders: [CLVModels.Base.Tender]?
        /// This merchant's employees' shifts
        public var shifts: [CLVModels.Employees.Shift]?
        /// This merchant's orders
        public var orders: [CLVModels.Order.Order]?
        /// This merchant's order payments
        public var payments: [CLVModels.Payments.Payment]?
        public var taxRates: [CLVModels.Inventory.TaxRate]?
        public var printers: [CLVModels.Printer.Printer]?
        public var modifierGroups: [CLVModels.Inventory.ModifierGroup]?
        public var orderTypes: [CLVModels.Order.OrderType]?
        /// The merchant's reseller
        public var reseller: CLVModels.Base.Reference?
        /// This merchant's opening hours
        public var opening_hours: [CLVModels.Hours.HoursSet]?
        /// The business type of the merchant
        public var businessTypeCode: CLVModels.Base.BusinessTypeCode?
        /// Billing information for the merchant in context.
        public var billingInfo: CLVModels.Merchant.MerchantBillingInfo?
        /// Deprecated (use billingInfo instead): Returns true when the merchant is billable.
        public var isBillable: Bool?
        /// A list of devices a merchant owns, 128-bit UUIDs, not a normal base-13 Clover IDs.
        public var devices: [CLVModels.Base.Reference]?
        /// A list of merchant groups a merchant belongs to
        public var merchantGroups: [CLVModels.Base.Reference]?
        /// The partner app/solution with which this merchant is primarily associated
        public var partnerApp: CLVModels.Base.Reference?
        /// The account type for the merchant. Used for reference merchants. See enterprise.ReferenceType
        public var accountType: String?
        /// Bank processing data for this merchant
        public var bankProcessing: CLVModels.Merchant.MerchantBankProcessing?
        /// Additional data collected during boarding
        public var merchantBoarding: CLVModels.Merchant.MerchantBoarding?
        /// Business hierarchy data for merchant.
        public var hierarchy: CLVModels.Merchant.MerchantHierarchy?
        /// A list of external merchants for this merchant
        public var externalMerchants: [CLVModels.Merchant.ExternalMerchant]?
        /// A list of program expresses for this merchant
        public var programExpresses: [CLVModels.Merchant.MerchantProgramExpress]?
        /// A list of additional device boarding data for this merchant
        public var deviceBoardings: [CLVModels.Merchant.MerchantDeviceBoarding]?
        /// The boarding application submitted by the merchant
        public var selfBoardingApplication: CLVModels.Base.Reference?
        /// The bundles and the state of that bundle that is associated with the merchant.
        public var deviceBundleStates: [CLVModels.Merchant.DeviceBundleState]?
        /// The equipment associated with the merchant. This is a combination of boarded equipment and provisioned devices.
        public var equipment: [CLVModels.Boarding.Equipment]?
        public var enterprises: CLVModels.Variant?
        /// Compliance details for the merchant.
        public var compliances: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case owner
            case address
            case merchantPlan
            case defaultCurrency
            case phoneNumber
            case website
            case customerContactEmail
            case logos
            case createdTime
            case properties
            case gateway
            case tipSuggestions
            case employees
            case items
            case tags
            case tenders
            case shifts
            case orders
            case payments
            case taxRates
            case printers
            case modifierGroups
            case orderTypes
            case reseller
            case opening_hours
            case businessTypeCode
            case billingInfo
            case isBillable
            case devices
            case merchantGroups
            case partnerApp
            case accountType
            case bankProcessing
            case merchantBoarding
            case hierarchy
            case externalMerchants
            case programExpresses
            case deviceBoardings
            case selfBoardingApplication
            case deviceBundleStates
            case equipment
            case enterprises
            case compliances
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.owner = try rootContainer.decodeIfPresent(CLVModels.Employees.Employee.self, forKey: .owner)
            } catch {
                decodeError.append(error)
            }
            do {
                self.address = try rootContainer.decodeIfPresent(CLVModels.Base.Address.self, forKey: .address)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantPlan = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .merchantPlan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.defaultCurrency = try rootContainer.decodeIfPresent(String.self, forKey: .defaultCurrency)
            } catch {
                decodeError.append(error)
            }
            do {
                self.phoneNumber = try rootContainer.decodeIfPresent(String.self, forKey: .phoneNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.website = try rootContainer.decodeIfPresent(String.self, forKey: .website)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerContactEmail = try rootContainer.decodeIfPresent(String.self, forKey: .customerContactEmail)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.logos)) {
                do {
                    let logosContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .logos)
                    self.logos = try logosContainer.decodeIfPresent([CLVModels.Merchant.Logo].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.properties = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantProperties.self, forKey: .properties)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gateway = try rootContainer.decodeIfPresent(CLVModels.Merchant.Gateway.self, forKey: .gateway)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.tipSuggestions)) {
                do {
                    let tipSuggestionsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tipSuggestions)
                    self.tipSuggestions = try tipSuggestionsContainer.decodeIfPresent([CLVModels.Merchant.TipSuggestion].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.employees)) {
                do {
                    let employeesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .employees)
                    self.employees = try employeesContainer.decodeIfPresent([CLVModels.Employees.Employee].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.items)) {
                do {
                    let itemsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .items)
                    self.items = try itemsContainer.decodeIfPresent([CLVModels.Inventory.Item].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.tags)) {
                do {
                    let tagsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tags)
                    self.tags = try tagsContainer.decodeIfPresent([CLVModels.Inventory.Tag].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.tenders)) {
                do {
                    let tendersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tenders)
                    self.tenders = try tendersContainer.decodeIfPresent([CLVModels.Base.Tender].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.shifts)) {
                do {
                    let shiftsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .shifts)
                    self.shifts = try shiftsContainer.decodeIfPresent([CLVModels.Employees.Shift].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.orders)) {
                do {
                    let ordersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .orders)
                    self.orders = try ordersContainer.decodeIfPresent([CLVModels.Order.Order].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.payments)) {
                do {
                    let paymentsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .payments)
                    self.payments = try paymentsContainer.decodeIfPresent([CLVModels.Payments.Payment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent([CLVModels.Inventory.TaxRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.printers)) {
                do {
                    let printersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .printers)
                    self.printers = try printersContainer.decodeIfPresent([CLVModels.Printer.Printer].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.modifierGroups)) {
                do {
                    let modifierGroupsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .modifierGroups)
                    self.modifierGroups = try modifierGroupsContainer.decodeIfPresent([CLVModels.Inventory.ModifierGroup].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.orderTypes)) {
                do {
                    let orderTypesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .orderTypes)
                    self.orderTypes = try orderTypesContainer.decodeIfPresent([CLVModels.Order.OrderType].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.reseller = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .reseller)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.opening_hours)) {
                do {
                    let opening_hoursContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .opening_hours)
                    self.opening_hours = try opening_hoursContainer.decodeIfPresent([CLVModels.Hours.HoursSet].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.businessTypeCode = try rootContainer.decodeIfPresent(CLVModels.Base.BusinessTypeCode.self, forKey: .businessTypeCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.billingInfo = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantBillingInfo.self, forKey: .billingInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isBillable = try rootContainer.decodeIfPresent(Bool.self, forKey: .isBillable)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.devices)) {
                do {
                    let devicesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .devices)
                    self.devices = try devicesContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.merchantGroups)) {
                do {
                    let merchantGroupsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .merchantGroups)
                    self.merchantGroups = try merchantGroupsContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.partnerApp = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .partnerApp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountType = try rootContainer.decodeIfPresent(String.self, forKey: .accountType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bankProcessing = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantBankProcessing.self, forKey: .bankProcessing)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantBoarding = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantBoarding.self, forKey: .merchantBoarding)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hierarchy = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantHierarchy.self, forKey: .hierarchy)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.externalMerchants)) {
                do {
                    let externalMerchantsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .externalMerchants)
                    self.externalMerchants = try externalMerchantsContainer.decodeIfPresent([CLVModels.Merchant.ExternalMerchant].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.programExpresses)) {
                do {
                    let programExpressesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .programExpresses)
                    self.programExpresses = try programExpressesContainer.decodeIfPresent([CLVModels.Merchant.MerchantProgramExpress].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.deviceBoardings)) {
                do {
                    let deviceBoardingsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .deviceBoardings)
                    self.deviceBoardings = try deviceBoardingsContainer.decodeIfPresent([CLVModels.Merchant.MerchantDeviceBoarding].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.selfBoardingApplication = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .selfBoardingApplication)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.deviceBundleStates)) {
                do {
                    let deviceBundleStatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .deviceBundleStates)
                    self.deviceBundleStates = try deviceBundleStatesContainer.decodeIfPresent([CLVModels.Merchant.DeviceBundleState].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.equipment)) {
                do {
                    let equipmentContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .equipment)
                    self.equipment = try equipmentContainer.decodeIfPresent([CLVModels.Boarding.Equipment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.enterprises)) {
                do {
                    let enterprisesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .enterprises)
                    self.enterprises = try enterprisesContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.compliances)) {
                do {
                    let compliancesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .compliances)
                    self.compliances = try compliancesContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (owner != nil) { try container.encode(owner, forKey: .owner) }
            if (address != nil) { try container.encode(address, forKey: .address) }
            if (merchantPlan != nil) { try container.encode(merchantPlan, forKey: .merchantPlan) }
            if (defaultCurrency != nil) { try container.encode(defaultCurrency, forKey: .defaultCurrency) }
            if (phoneNumber != nil) { try container.encode(phoneNumber, forKey: .phoneNumber) }
            if (website != nil) { try container.encode(website, forKey: .website) }
            if (customerContactEmail != nil) { try container.encode(customerContactEmail, forKey: .customerContactEmail) }
            if (logos != nil) { try container.encode(logos, forKey: .logos) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (properties != nil) { try container.encode(properties, forKey: .properties) }
            if (gateway != nil) { try container.encode(gateway, forKey: .gateway) }
            if (tipSuggestions != nil) { try container.encode(tipSuggestions, forKey: .tipSuggestions) }
            if (employees != nil) { try container.encode(employees, forKey: .employees) }
            if (items != nil) { try container.encode(items, forKey: .items) }
            if (tags != nil) { try container.encode(tags, forKey: .tags) }
            if (tenders != nil) { try container.encode(tenders, forKey: .tenders) }
            if (shifts != nil) { try container.encode(shifts, forKey: .shifts) }
            if (orders != nil) { try container.encode(orders, forKey: .orders) }
            if (payments != nil) { try container.encode(payments, forKey: .payments) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (printers != nil) { try container.encode(printers, forKey: .printers) }
            if (modifierGroups != nil) { try container.encode(modifierGroups, forKey: .modifierGroups) }
            if (orderTypes != nil) { try container.encode(orderTypes, forKey: .orderTypes) }
            if (reseller != nil) { try container.encode(reseller, forKey: .reseller) }
            if (opening_hours != nil) { try container.encode(opening_hours, forKey: .opening_hours) }
            if (businessTypeCode != nil) { try container.encode(businessTypeCode, forKey: .businessTypeCode) }
            if (billingInfo != nil) { try container.encode(billingInfo, forKey: .billingInfo) }
            if (isBillable != nil) { try container.encode(isBillable, forKey: .isBillable) }
            if (devices != nil) { try container.encode(devices, forKey: .devices) }
            if (merchantGroups != nil) { try container.encode(merchantGroups, forKey: .merchantGroups) }
            if (partnerApp != nil) { try container.encode(partnerApp, forKey: .partnerApp) }
            if (accountType != nil) { try container.encode(accountType, forKey: .accountType) }
            if (bankProcessing != nil) { try container.encode(bankProcessing, forKey: .bankProcessing) }
            if (merchantBoarding != nil) { try container.encode(merchantBoarding, forKey: .merchantBoarding) }
            if (hierarchy != nil) { try container.encode(hierarchy, forKey: .hierarchy) }
            if (externalMerchants != nil) { try container.encode(externalMerchants, forKey: .externalMerchants) }
            if (programExpresses != nil) { try container.encode(programExpresses, forKey: .programExpresses) }
            if (deviceBoardings != nil) { try container.encode(deviceBoardings, forKey: .deviceBoardings) }
            if (selfBoardingApplication != nil) { try container.encode(selfBoardingApplication, forKey: .selfBoardingApplication) }
            if (deviceBundleStates != nil) { try container.encode(deviceBundleStates, forKey: .deviceBundleStates) }
            if (equipment != nil) { try container.encode(equipment, forKey: .equipment) }
            if (enterprises != nil) { try container.encode(enterprises, forKey: .enterprises) }
            if (compliances != nil) { try container.encode(compliances, forKey: .compliances) }
        }
    }

}