/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Merchant {

    public class MerchantPlan: Codable {

        /// Unique identifier
        public var id: String?
        /// The name of the merchant plan
        public var name: String?
        /// Description of the plan
        public var description_: String?
        public var price: Int64?
        /// Transient field, the free trial period, as defined in this plan's group.
        public var trialDays: Int64?
        /// Date/time this plan's trial will expire for the merchant with this plan. This is a transient value only applicable to the merchant assigned to this plan.
        public var trialExpirationTime: Date?
        public var modules: [CLVModels.Merchant.Module]?
        public var appBundle: CLVModels.Apps.AppBundle?
        /// If true and multiple plans of this code then treat as default plan for reseller. Cannot use word default.
        public var defaultPlan: Bool?
        /// True if plan metadata indicates this plan should be recommended in OOBE plan selection.
        public var recommended: Bool?
        /// Pricing model for plan.
        public var pricingModel: CLVModels.Merchant.MerchantPlanPricingModel?
        /// If true then plan offers by one device get one free.
        public var bogo: Bool?
        /// Represents the importance or value the planCode has. Helpful for determining when a merchant is downgrading or upgrading their plan
        public var weight: Int64?
        /// List of feature keys this plans supports. Used by plan selection/summary pages.
        public var features: [String]?
        /// If true then billing will charge monthly fee regardless of device status or count.
        public var billToMid: Bool?
        /// Type of plan
        public var type_: CLVModels.Merchant.MerchantPlanType?
        /// First data plan code
        public var planCode: String?
        /// Date/time when this plan becomes active. If null then active now.
        public var activationTime: Date?
        /// Date/time when this plan becomes inactive. If null then no end of life.
        public var deactivationTime: Date?
        public var reseller: CLVModels.Resellers.Reseller?
        /// Plan Group of this Plan as associated with merchant in context
        public var merchantPlanGroup: CLVModels.Base.Reference?
        /// All Plan Groups this Plan is linked to
        public var merchantPlanGroups: [CLVModels.Merchant.MerchantPlanGroup]?
        /// If true and merchant is assigned this plan then merchant cannot self-serve change from the plan.
        public var enforced: Bool?
        /// If true and a merchant in same plan group is not assigned this plan then merchant cannot see this plan.
        public var hidden: Bool?
        /// Date/time this plan was created.
        public var createdTime: Date?
        /// Date/time this plan was last modified.
        public var modifiedTime: Date?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case description
            case price
            case trialDays
            case trialExpirationTime
            case modules
            case appBundle
            case defaultPlan
            case recommended
            case pricingModel
            case bogo
            case weight
            case features
            case billToMid
            case type
            case planCode
            case activationTime
            case deactivationTime
            case reseller
            case merchantPlanGroup
            case merchantPlanGroups
            case enforced
            case hidden
            case createdTime
            case modifiedTime
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.description_ = try rootContainer.decodeIfPresent(String.self, forKey: .description)
            } catch {
                decodeError.append(error)
            }
            do {
                self.price = try rootContainer.decodeIfPresent(Int64.self, forKey: .price)
            } catch {
                decodeError.append(error)
            }
            do {
                self.trialDays = try rootContainer.decodeIfPresent(Int64.self, forKey: .trialDays)
            } catch {
                decodeError.append(error)
            }
            do {
                self.trialExpirationTime = try rootContainer.decodeIfPresent(Date.self, forKey: .trialExpirationTime)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.modules)) {
                do {
                    let modulesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .modules)
                    self.modules = try modulesContainer.decodeIfPresent([CLVModels.Merchant.Module].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.appBundle = try rootContainer.decodeIfPresent(CLVModels.Apps.AppBundle.self, forKey: .appBundle)
            } catch {
                decodeError.append(error)
            }
            do {
                self.defaultPlan = try rootContainer.decodeIfPresent(Bool.self, forKey: .defaultPlan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.recommended = try rootContainer.decodeIfPresent(Bool.self, forKey: .recommended)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pricingModel = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantPlanPricingModel.self, forKey: .pricingModel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.bogo = try rootContainer.decodeIfPresent(Bool.self, forKey: .bogo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.weight = try rootContainer.decodeIfPresent(Int64.self, forKey: .weight)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.features)) {
                do {
                    let featuresContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .features)
                    self.features = try featuresContainer.decodeIfPresent([String].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.billToMid = try rootContainer.decodeIfPresent(Bool.self, forKey: .billToMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Merchant.MerchantPlanType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.planCode = try rootContainer.decodeIfPresent(String.self, forKey: .planCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.activationTime = try rootContainer.decodeIfPresent(Date.self, forKey: .activationTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deactivationTime = try rootContainer.decodeIfPresent(Date.self, forKey: .deactivationTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reseller = try rootContainer.decodeIfPresent(CLVModels.Resellers.Reseller.self, forKey: .reseller)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantPlanGroup = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchantPlanGroup)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.merchantPlanGroups)) {
                do {
                    let merchantPlanGroupsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .merchantPlanGroups)
                    self.merchantPlanGroups = try merchantPlanGroupsContainer.decodeIfPresent([CLVModels.Merchant.MerchantPlanGroup].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.enforced = try rootContainer.decodeIfPresent(Bool.self, forKey: .enforced)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hidden = try rootContainer.decodeIfPresent(Bool.self, forKey: .hidden)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (description_ != nil) { try container.encode(description_, forKey: .description) }
            if (price != nil) { try container.encode(price, forKey: .price) }
            if (trialDays != nil) { try container.encode(trialDays, forKey: .trialDays) }
            if (trialExpirationTime != nil) { try container.encode(trialExpirationTime, forKey: .trialExpirationTime) }
            if (modules != nil) { try container.encode(modules, forKey: .modules) }
            if (appBundle != nil) { try container.encode(appBundle, forKey: .appBundle) }
            if (defaultPlan != nil) { try container.encode(defaultPlan, forKey: .defaultPlan) }
            if (recommended != nil) { try container.encode(recommended, forKey: .recommended) }
            if (pricingModel != nil) { try container.encode(pricingModel, forKey: .pricingModel) }
            if (bogo != nil) { try container.encode(bogo, forKey: .bogo) }
            if (weight != nil) { try container.encode(weight, forKey: .weight) }
            if (features != nil) { try container.encode(features, forKey: .features) }
            if (billToMid != nil) { try container.encode(billToMid, forKey: .billToMid) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (planCode != nil) { try container.encode(planCode, forKey: .planCode) }
            if (activationTime != nil) { try container.encode(activationTime, forKey: .activationTime) }
            if (deactivationTime != nil) { try container.encode(deactivationTime, forKey: .deactivationTime) }
            if (reseller != nil) { try container.encode(reseller, forKey: .reseller) }
            if (merchantPlanGroup != nil) { try container.encode(merchantPlanGroup, forKey: .merchantPlanGroup) }
            if (merchantPlanGroups != nil) { try container.encode(merchantPlanGroups, forKey: .merchantPlanGroups) }
            if (enforced != nil) { try container.encode(enforced, forKey: .enforced) }
            if (hidden != nil) { try container.encode(hidden, forKey: .hidden) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
        }
    }

}