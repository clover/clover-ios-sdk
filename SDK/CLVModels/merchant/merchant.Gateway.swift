/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Merchant {

    public class Gateway: Codable {

        public var paymentProcessorName: String?
        public var authorizationFrontEnd: String?
        public var acquiringBackEnd: String?
        public var paymentGatewayApi: String?
        public var accountName: String?
        public var altMid: String?
        public var mid: String?
        public var fns: String?
        public var tid: String?
        public var storeId: String?
        public var supportsTipping: Bool?
        public var frontendMid: String?
        public var backendMid: String?
        /// Merchant Category Code
        public var mcc: String?
        public var tokenType: String?
        public var groupId: String?
        public var debitKeyCode: String?
        public var sredCode: String?
        public var supportsTipAdjust: Bool?
        public var supportsNakedCredit: Bool?
        public var supportsMultiPayToken: Bool?
        /// If true the gateway will allow an amount greater than the preauth amount to be captured.
        public var supportsPreauthOverage: Bool?
        public var keyPrefix: String?
        public var keyInfo: [String:String]?
        public var closingTime: String?
        public var newBatchCloseEnabled: Bool?
        /// Field to identify whether the payment processor is real or demo. 'true' is returned for real payment processsor. 'false' is returned for demo payment processor.
        public var production: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case paymentProcessorName
            case authorizationFrontEnd
            case acquiringBackEnd
            case paymentGatewayApi
            case accountName
            case altMid
            case mid
            case fns
            case tid
            case storeId
            case supportsTipping
            case frontendMid
            case backendMid
            case mcc
            case tokenType
            case groupId
            case debitKeyCode
            case sredCode
            case supportsTipAdjust
            case supportsNakedCredit
            case supportsMultiPayToken
            case supportsPreauthOverage
            case keyPrefix
            case keyInfo
            case closingTime
            case newBatchCloseEnabled
            case production
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.paymentProcessorName = try rootContainer.decodeIfPresent(String.self, forKey: .paymentProcessorName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authorizationFrontEnd = try rootContainer.decodeIfPresent(String.self, forKey: .authorizationFrontEnd)
            } catch {
                decodeError.append(error)
            }
            do {
                self.acquiringBackEnd = try rootContainer.decodeIfPresent(String.self, forKey: .acquiringBackEnd)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentGatewayApi = try rootContainer.decodeIfPresent(String.self, forKey: .paymentGatewayApi)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountName = try rootContainer.decodeIfPresent(String.self, forKey: .accountName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.altMid = try rootContainer.decodeIfPresent(String.self, forKey: .altMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mid = try rootContainer.decodeIfPresent(String.self, forKey: .mid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fns = try rootContainer.decodeIfPresent(String.self, forKey: .fns)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tid = try rootContainer.decodeIfPresent(String.self, forKey: .tid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.storeId = try rootContainer.decodeIfPresent(String.self, forKey: .storeId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsTipping = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsTipping)
            } catch {
                decodeError.append(error)
            }
            do {
                self.frontendMid = try rootContainer.decodeIfPresent(String.self, forKey: .frontendMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.backendMid = try rootContainer.decodeIfPresent(String.self, forKey: .backendMid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mcc = try rootContainer.decodeIfPresent(String.self, forKey: .mcc)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tokenType = try rootContainer.decodeIfPresent(String.self, forKey: .tokenType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.groupId = try rootContainer.decodeIfPresent(String.self, forKey: .groupId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debitKeyCode = try rootContainer.decodeIfPresent(String.self, forKey: .debitKeyCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sredCode = try rootContainer.decodeIfPresent(String.self, forKey: .sredCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsTipAdjust = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsTipAdjust)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsNakedCredit = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsNakedCredit)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsMultiPayToken = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsMultiPayToken)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsPreauthOverage = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsPreauthOverage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.keyPrefix = try rootContainer.decodeIfPresent(String.self, forKey: .keyPrefix)
            } catch {
                decodeError.append(error)
            }
            do {
                self.keyInfo = try rootContainer.decodeIfPresent([String:String].self, forKey: .keyInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.closingTime = try rootContainer.decodeIfPresent(String.self, forKey: .closingTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.newBatchCloseEnabled = try rootContainer.decodeIfPresent(Bool.self, forKey: .newBatchCloseEnabled)
            } catch {
                decodeError.append(error)
            }
            do {
                self.production = try rootContainer.decodeIfPresent(Bool.self, forKey: .production)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (paymentProcessorName != nil) { try container.encode(paymentProcessorName, forKey: .paymentProcessorName) }
            if (authorizationFrontEnd != nil) { try container.encode(authorizationFrontEnd, forKey: .authorizationFrontEnd) }
            if (acquiringBackEnd != nil) { try container.encode(acquiringBackEnd, forKey: .acquiringBackEnd) }
            if (paymentGatewayApi != nil) { try container.encode(paymentGatewayApi, forKey: .paymentGatewayApi) }
            if (accountName != nil) { try container.encode(accountName, forKey: .accountName) }
            if (altMid != nil) { try container.encode(altMid, forKey: .altMid) }
            if (mid != nil) { try container.encode(mid, forKey: .mid) }
            if (fns != nil) { try container.encode(fns, forKey: .fns) }
            if (tid != nil) { try container.encode(tid, forKey: .tid) }
            if (storeId != nil) { try container.encode(storeId, forKey: .storeId) }
            if (supportsTipping != nil) { try container.encode(supportsTipping, forKey: .supportsTipping) }
            if (frontendMid != nil) { try container.encode(frontendMid, forKey: .frontendMid) }
            if (backendMid != nil) { try container.encode(backendMid, forKey: .backendMid) }
            if (mcc != nil) { try container.encode(mcc, forKey: .mcc) }
            if (tokenType != nil) { try container.encode(tokenType, forKey: .tokenType) }
            if (groupId != nil) { try container.encode(groupId, forKey: .groupId) }
            if (debitKeyCode != nil) { try container.encode(debitKeyCode, forKey: .debitKeyCode) }
            if (sredCode != nil) { try container.encode(sredCode, forKey: .sredCode) }
            if (supportsTipAdjust != nil) { try container.encode(supportsTipAdjust, forKey: .supportsTipAdjust) }
            if (supportsNakedCredit != nil) { try container.encode(supportsNakedCredit, forKey: .supportsNakedCredit) }
            if (supportsMultiPayToken != nil) { try container.encode(supportsMultiPayToken, forKey: .supportsMultiPayToken) }
            if (supportsPreauthOverage != nil) { try container.encode(supportsPreauthOverage, forKey: .supportsPreauthOverage) }
            if (keyPrefix != nil) { try container.encode(keyPrefix, forKey: .keyPrefix) }
            if (keyInfo != nil) { try container.encode(keyInfo, forKey: .keyInfo) }
            if (closingTime != nil) { try container.encode(closingTime, forKey: .closingTime) }
            if (newBatchCloseEnabled != nil) { try container.encode(newBatchCloseEnabled, forKey: .newBatchCloseEnabled) }
            if (production != nil) { try container.encode(production, forKey: .production) }
        }
    }

}