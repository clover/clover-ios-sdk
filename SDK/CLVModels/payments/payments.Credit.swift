/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class Credit: Codable {

        /// Unique identifier
        public var id: String?
        /// The order with which the credit is associated
        public var orderRef: CLVModels.Base.Reference?
        /// Device which processed this credit, a 128-bit UUID, not a normal base-13 Clover ID.
        public var device: CLVModels.Variant?
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var tender: CLVModels.Base.Tender?
        /// The employee who processed the payment
        public var employee: CLVModels.Base.Reference?
        /// Customer who received the credit/refund
        public var customers: CLVModels.Customers.Customer?
        /// Amount paid
        public var amount: Int64?
        /// Amount paid in tax
        public var taxAmount: CLVModels.Variant?
        public var taxRates: [CLVModels.Payments.TaxableAmountRate]?
        /// Time payment was recorded on server
        public var createdTime: Date?
        public var clientCreatedTime: Date?
        /// Information about the card used for credit/debit card payments
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        public var voided: Bool?
        public var voidReason: String?
        /// Dynamic Currency Conversion information
        public var dccInfo: CLVModels.Variant?
        /// Per transaction settings for the payment
        public var transactionSettings: CLVModels.Payments.TransactionSettings?
        public var creditRefunds: [CLVModels.Payments.CreditRefund]?
        /// German region-specific information
        public var germanInfo: CLVModels.Variant?
        /// Tracking information for the app that created this credit.
        public var appTracking: CLVModels.Variant?
        public var result: CLVModels.Payments.Result?
        /// Transaction information
        public var transactionInfo: CLVModels.Variant?
        public var merchant: CLVModels.Base.Reference?
        /// The external reference id if associated with the credit
        public var externalReferenceId: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderRef
            case device
            case tender
            case employee
            case customers
            case amount
            case taxAmount
            case taxRates
            case createdTime
            case clientCreatedTime
            case cardTransaction
            case voided
            case voidReason
            case dccInfo
            case transactionSettings
            case creditRefunds
            case germanInfo
            case appTracking
            case result
            case transactionInfo
            case merchant
            case externalReferenceId
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .orderRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.device = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .device)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tender = try rootContainer.decodeIfPresent(CLVModels.Base.Tender.self, forKey: .tender)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employee = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .employee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customers = try rootContainer.decodeIfPresent(CLVModels.Customers.Customer.self, forKey: .customers)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .taxAmount)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent([CLVModels.Payments.TaxableAmountRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientCreatedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .clientCreatedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardTransaction = try rootContainer.decodeIfPresent(CLVModels.Payments.CardTransaction.self, forKey: .cardTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voided = try rootContainer.decodeIfPresent(Bool.self, forKey: .voided)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voidReason = try rootContainer.decodeIfPresent(String.self, forKey: .voidReason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dccInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .dccInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionSettings = try rootContainer.decodeIfPresent(CLVModels.Payments.TransactionSettings.self, forKey: .transactionSettings)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.creditRefunds)) {
                do {
                    let creditRefundsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .creditRefunds)
                    self.creditRefunds = try creditRefundsContainer.decodeIfPresent([CLVModels.Payments.CreditRefund].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.germanInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .germanInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.appTracking = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .appTracking)
            } catch {
                decodeError.append(error)
            }
            do {
                self.result = try rootContainer.decodeIfPresent(CLVModels.Payments.Result.self, forKey: .result)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .transactionInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderRef != nil) { try container.encode(orderRef, forKey: .orderRef) }
            if (device != nil) { try container.encode(device, forKey: .device) }
            if (tender != nil) { try container.encode(tender, forKey: .tender) }
            if (employee != nil) { try container.encode(employee, forKey: .employee) }
            if (customers != nil) { try container.encode(customers, forKey: .customers) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (taxAmount != nil) { try container.encode(taxAmount, forKey: .taxAmount) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (clientCreatedTime != nil) { try container.encode(clientCreatedTime, forKey: .clientCreatedTime) }
            if (cardTransaction != nil) { try container.encode(cardTransaction, forKey: .cardTransaction) }
            if (voided != nil) { try container.encode(voided, forKey: .voided) }
            if (voidReason != nil) { try container.encode(voidReason, forKey: .voidReason) }
            if (dccInfo != nil) { try container.encode(dccInfo, forKey: .dccInfo) }
            if (transactionSettings != nil) { try container.encode(transactionSettings, forKey: .transactionSettings) }
            if (creditRefunds != nil) { try container.encode(creditRefunds, forKey: .creditRefunds) }
            if (germanInfo != nil) { try container.encode(germanInfo, forKey: .germanInfo) }
            if (appTracking != nil) { try container.encode(appTracking, forKey: .appTracking) }
            if (result != nil) { try container.encode(result, forKey: .result) }
            if (transactionInfo != nil) { try container.encode(transactionInfo, forKey: .transactionInfo) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
        }
    }

}