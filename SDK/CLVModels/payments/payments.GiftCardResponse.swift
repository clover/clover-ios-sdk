/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class GiftCardResponse: Codable {

        public var txType: CLVModels.Payments.TxType?
        public var state: CLVModels.Payments.GiftCardState?
        /// Transaction Amount
        public var requestAmount: Int64?
        public var payment: CLVModels.Payments.Payment?
        public var responseMessage: String?
        public var requestSuccessful: Bool?
        public var accountNumber: String?
        public var scv: String?
        public var giftCardTxUuid: String?
        public var transactionId: String?
        public var referenceUuid: String?
        public var authCode: String?
        public var begBal: CLVModels.Variant?
        public var endBal: CLVModels.Variant?
        public var holdBal: CLVModels.Variant?
        public var syncPaymentObject: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case txType
            case state
            case requestAmount
            case payment
            case responseMessage
            case requestSuccessful
            case accountNumber
            case scv
            case giftCardTxUuid
            case transactionId
            case referenceUuid
            case authCode
            case begBal
            case endBal
            case holdBal
            case syncPaymentObject
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.txType = try rootContainer.decodeIfPresent(CLVModels.Payments.TxType.self, forKey: .txType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.state = try rootContainer.decodeIfPresent(CLVModels.Payments.GiftCardState.self, forKey: .state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.requestAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .requestAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.payment = try rootContainer.decodeIfPresent(CLVModels.Payments.Payment.self, forKey: .payment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.responseMessage = try rootContainer.decodeIfPresent(String.self, forKey: .responseMessage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.requestSuccessful = try rootContainer.decodeIfPresent(Bool.self, forKey: .requestSuccessful)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountNumber = try rootContainer.decodeIfPresent(String.self, forKey: .accountNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.scv = try rootContainer.decodeIfPresent(String.self, forKey: .scv)
            } catch {
                decodeError.append(error)
            }
            do {
                self.giftCardTxUuid = try rootContainer.decodeIfPresent(String.self, forKey: .giftCardTxUuid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionId = try rootContainer.decodeIfPresent(String.self, forKey: .transactionId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.referenceUuid = try rootContainer.decodeIfPresent(String.self, forKey: .referenceUuid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authCode = try rootContainer.decodeIfPresent(String.self, forKey: .authCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.begBal = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .begBal)
            } catch {
                decodeError.append(error)
            }
            do {
                self.endBal = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .endBal)
            } catch {
                decodeError.append(error)
            }
            do {
                self.holdBal = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .holdBal)
            } catch {
                decodeError.append(error)
            }
            do {
                self.syncPaymentObject = try rootContainer.decodeIfPresent(Bool.self, forKey: .syncPaymentObject)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (txType != nil) { try container.encode(txType, forKey: .txType) }
            if (state != nil) { try container.encode(state, forKey: .state) }
            if (requestAmount != nil) { try container.encode(requestAmount, forKey: .requestAmount) }
            if (payment != nil) { try container.encode(payment, forKey: .payment) }
            if (responseMessage != nil) { try container.encode(responseMessage, forKey: .responseMessage) }
            if (requestSuccessful != nil) { try container.encode(requestSuccessful, forKey: .requestSuccessful) }
            if (accountNumber != nil) { try container.encode(accountNumber, forKey: .accountNumber) }
            if (scv != nil) { try container.encode(scv, forKey: .scv) }
            if (giftCardTxUuid != nil) { try container.encode(giftCardTxUuid, forKey: .giftCardTxUuid) }
            if (transactionId != nil) { try container.encode(transactionId, forKey: .transactionId) }
            if (referenceUuid != nil) { try container.encode(referenceUuid, forKey: .referenceUuid) }
            if (authCode != nil) { try container.encode(authCode, forKey: .authCode) }
            if (begBal != nil) { try container.encode(begBal, forKey: .begBal) }
            if (endBal != nil) { try container.encode(endBal, forKey: .endBal) }
            if (holdBal != nil) { try container.encode(holdBal, forKey: .holdBal) }
            if (syncPaymentObject != nil) { try container.encode(syncPaymentObject, forKey: .syncPaymentObject) }
        }
    }

}