/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class TransactionInfo: Codable {

        /// 2 character language used for the transaction. Deprecated in factor of transactionLocale.
        public var languageIndicator: String?
        /// Locale for the transaction (e.g. en-CA)
        public var transactionLocale: String?
        public var accountSelection: CLVModels.Payments.AccountType?
        /// The payment with which this extra is associated
        public var paymentRef: CLVModels.Base.Reference?
        /// The credit with which this extra is associated
        public var creditRef: CLVModels.Base.Reference?
        /// The refund with which this extra is associated
        public var refundRef: CLVModels.Base.Reference?
        /// The credit refund with which this extra is associated
        public var creditRefundRef: CLVModels.Base.Reference?
        /// Consists of 4 digits prefix + 8 digits
        public var fiscalInvoiceNumber: String?
        /// AR Installments: number of installments
        public var installmentsQuantity: Int32?
        /// AR Installments: plan alphanum code
        public var installmentsPlanCode: String?
        /// AR Installments: selected plan id
        public var installmentsPlanId: String?
        /// AR Installments: selected plan desc
        public var installmentsPlanDesc: String?
        /// Card type label
        public var cardTypeLabel: String?
        /// Card Symbol for identify in payment_card_config table
        public var cardSymbol: String?
        /// STAN(System Audit Trace Number)
        public var stan: Int32?
        /// Customers identification number and type
        public var identityDocument: CLVModels.Variant?
        /// Transaction Batch Number
        public var batchNumber: String?
        /// Transaction Receipt Number
        public var receiptNumber: String?
        /// Reversal STAN Ref Num
        public var reversalStanRefNum: String?
        /// STAN for reversal
        public var reversalStan: Int32?
        /// MAC for reversal
        public var reversalMac: String?
        /// MAC KSN for reversal
        public var reversalMacKsn: String?
        /// Designates the unique location of a terminal at a merchant
        public var terminalIdentification: String?
        /// Main internal identifier of terminal which should be the same across all Fiservâ€™s components
        public var externalTerminalId: String?
        /// When concatenated with the Acquirer Identifier, uniquely identifies a given merchant
        public var merchantIdentifier: String?
        /// Indicates the name and location of the merchant
        public var merchantNameLocation: String?
        /// Masked track2 data
        public var maskedTrack2: String?
        /// Extra data for receipt
        public var receiptExtraData: String?
        /// Defines the Financial Service selected for the transaction
        public var selectedService: CLVModels.Payments.SelectedService?
        /// Result of the transaction
        public var transactionResult: CLVModels.Payments.TransactionResult?
        /// Contains a hex string with needed TLV tags for certification
        public var transactionTags: String?
        /// Contains the information how the data inside transactionTags should be coded - initially we cause default and nexo as formats
        public var txFormat: CLVModels.Payments.TxFormat?
        /// Contains the information how the PAN should masked.
        public var panMask: String?
        /// Counter maintained by the terminal that is incremented for each transaction at the beginning of the Perform Service function.
        public var transactionSequenceCounter: String?
        /// Identifies and differentiates cards with the same PAN.
        public var applicationPanSequenceNumber: String?
        /// Contains the reason why the transaction should be reversed in the host. It has to be mapped in server with the expected value by the corresponding gateway
        public var reversalReason: CLVModels.Payments.ReversalReason?
        /// Boolean to determine if the transaction done using a vaulted card is a token based transaction
        public var isTokenBasedTx: Bool?
        /// For reversal and capture transactions, this contains the reference (transactionSequenceCounter) to the originating transaction.
        public var origTransactionSequenceCounter: String?
        /// This field is populated when the TSC of a terminal is out of sync and is provided with an update.
        public var transactionSequenceCounterUpdate: String?
        /// Boolean value defining if the corresponding TX was performed in NEXO emergency mode according NEXO IS Spec chapter 10.2
        public var emergencyFlag: Bool?
        /// This field contains the entry type of a transaction.
        public var entryType: CLVModels.Payments.CardEntryType?
        public var promotionalMessage: CLVModels.Payments.PromotionalMessage?
        public var eCommTransactionInfo: CLVModels.Payments.ECommTransactionInfo?
        public var sepaElvTransactionInfo: CLVModels.Payments.SepaElvTransactionInfo?
        /// Client card type should be used only limited purpose only and should not be confused with cardType in other objects.
        /// This is a read only field and must not to be overwritten on server or client once set on client. 
        /// This is set on client only for MSR tx for now as the AIDs are not identified for MSR. 
        /// For few MSR tx, the card type was identified incorrectly on client side, and also on server side based on the bin match. 
        /// In order to get the correct card types, this client card type will be sent to the server
        public var clientCardType: CLVModels.Payments.CardType?
        /// The app explicitly selected by the customer via the choice button.
        public var explicitlySelectedApp: String?
        /// Defines if the corresponding TX was performed as SEPA ELV TX.
        public var isSepaElv: Bool?
        public var printMessages: [CLVModels.Payments.DisplayAndPrintMessage]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case languageIndicator
            case transactionLocale
            case accountSelection
            case paymentRef
            case creditRef
            case refundRef
            case creditRefundRef
            case fiscalInvoiceNumber
            case installmentsQuantity
            case installmentsPlanCode
            case installmentsPlanId
            case installmentsPlanDesc
            case cardTypeLabel
            case cardSymbol
            case stan
            case identityDocument
            case batchNumber
            case receiptNumber
            case reversalStanRefNum
            case reversalStan
            case reversalMac
            case reversalMacKsn
            case terminalIdentification
            case externalTerminalId
            case merchantIdentifier
            case merchantNameLocation
            case maskedTrack2
            case receiptExtraData
            case selectedService
            case transactionResult
            case transactionTags
            case txFormat
            case panMask
            case transactionSequenceCounter
            case applicationPanSequenceNumber
            case reversalReason
            case isTokenBasedTx
            case origTransactionSequenceCounter
            case transactionSequenceCounterUpdate
            case emergencyFlag
            case entryType
            case promotionalMessage
            case eCommTransactionInfo
            case sepaElvTransactionInfo
            case clientCardType
            case explicitlySelectedApp
            case isSepaElv
            case printMessages
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.languageIndicator = try rootContainer.decodeIfPresent(String.self, forKey: .languageIndicator)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionLocale = try rootContainer.decodeIfPresent(String.self, forKey: .transactionLocale)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountSelection = try rootContainer.decodeIfPresent(CLVModels.Payments.AccountType.self, forKey: .accountSelection)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .paymentRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .refundRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRefundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRefundRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fiscalInvoiceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .fiscalInvoiceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.installmentsQuantity = try rootContainer.decodeIfPresent(Int32.self, forKey: .installmentsQuantity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.installmentsPlanCode = try rootContainer.decodeIfPresent(String.self, forKey: .installmentsPlanCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.installmentsPlanId = try rootContainer.decodeIfPresent(String.self, forKey: .installmentsPlanId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.installmentsPlanDesc = try rootContainer.decodeIfPresent(String.self, forKey: .installmentsPlanDesc)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardTypeLabel = try rootContainer.decodeIfPresent(String.self, forKey: .cardTypeLabel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardSymbol = try rootContainer.decodeIfPresent(String.self, forKey: .cardSymbol)
            } catch {
                decodeError.append(error)
            }
            do {
                self.stan = try rootContainer.decodeIfPresent(Int32.self, forKey: .stan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.identityDocument = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .identityDocument)
            } catch {
                decodeError.append(error)
            }
            do {
                self.batchNumber = try rootContainer.decodeIfPresent(String.self, forKey: .batchNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receiptNumber = try rootContainer.decodeIfPresent(String.self, forKey: .receiptNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reversalStanRefNum = try rootContainer.decodeIfPresent(String.self, forKey: .reversalStanRefNum)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reversalStan = try rootContainer.decodeIfPresent(Int32.self, forKey: .reversalStan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reversalMac = try rootContainer.decodeIfPresent(String.self, forKey: .reversalMac)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reversalMacKsn = try rootContainer.decodeIfPresent(String.self, forKey: .reversalMacKsn)
            } catch {
                decodeError.append(error)
            }
            do {
                self.terminalIdentification = try rootContainer.decodeIfPresent(String.self, forKey: .terminalIdentification)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalTerminalId = try rootContainer.decodeIfPresent(String.self, forKey: .externalTerminalId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantIdentifier = try rootContainer.decodeIfPresent(String.self, forKey: .merchantIdentifier)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantNameLocation = try rootContainer.decodeIfPresent(String.self, forKey: .merchantNameLocation)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .maskedTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receiptExtraData = try rootContainer.decodeIfPresent(String.self, forKey: .receiptExtraData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.selectedService = try rootContainer.decodeIfPresent(CLVModels.Payments.SelectedService.self, forKey: .selectedService)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionResult = try rootContainer.decodeIfPresent(CLVModels.Payments.TransactionResult.self, forKey: .transactionResult)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionTags = try rootContainer.decodeIfPresent(String.self, forKey: .transactionTags)
            } catch {
                decodeError.append(error)
            }
            do {
                self.txFormat = try rootContainer.decodeIfPresent(CLVModels.Payments.TxFormat.self, forKey: .txFormat)
            } catch {
                decodeError.append(error)
            }
            do {
                self.panMask = try rootContainer.decodeIfPresent(String.self, forKey: .panMask)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionSequenceCounter = try rootContainer.decodeIfPresent(String.self, forKey: .transactionSequenceCounter)
            } catch {
                decodeError.append(error)
            }
            do {
                self.applicationPanSequenceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .applicationPanSequenceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reversalReason = try rootContainer.decodeIfPresent(CLVModels.Payments.ReversalReason.self, forKey: .reversalReason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isTokenBasedTx = try rootContainer.decodeIfPresent(Bool.self, forKey: .isTokenBasedTx)
            } catch {
                decodeError.append(error)
            }
            do {
                self.origTransactionSequenceCounter = try rootContainer.decodeIfPresent(String.self, forKey: .origTransactionSequenceCounter)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionSequenceCounterUpdate = try rootContainer.decodeIfPresent(String.self, forKey: .transactionSequenceCounterUpdate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.emergencyFlag = try rootContainer.decodeIfPresent(Bool.self, forKey: .emergencyFlag)
            } catch {
                decodeError.append(error)
            }
            do {
                self.entryType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardEntryType.self, forKey: .entryType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.promotionalMessage = try rootContainer.decodeIfPresent(CLVModels.Payments.PromotionalMessage.self, forKey: .promotionalMessage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.eCommTransactionInfo = try rootContainer.decodeIfPresent(CLVModels.Payments.ECommTransactionInfo.self, forKey: .eCommTransactionInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvTransactionInfo = try rootContainer.decodeIfPresent(CLVModels.Payments.SepaElvTransactionInfo.self, forKey: .sepaElvTransactionInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientCardType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardType.self, forKey: .clientCardType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.explicitlySelectedApp = try rootContainer.decodeIfPresent(String.self, forKey: .explicitlySelectedApp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isSepaElv = try rootContainer.decodeIfPresent(Bool.self, forKey: .isSepaElv)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.printMessages)) {
                do {
                    let printMessagesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .printMessages)
                    self.printMessages = try printMessagesContainer.decodeIfPresent([CLVModels.Payments.DisplayAndPrintMessage].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (languageIndicator != nil) { try container.encode(languageIndicator, forKey: .languageIndicator) }
            if (transactionLocale != nil) { try container.encode(transactionLocale, forKey: .transactionLocale) }
            if (accountSelection != nil) { try container.encode(accountSelection, forKey: .accountSelection) }
            if (paymentRef != nil) { try container.encode(paymentRef, forKey: .paymentRef) }
            if (creditRef != nil) { try container.encode(creditRef, forKey: .creditRef) }
            if (refundRef != nil) { try container.encode(refundRef, forKey: .refundRef) }
            if (creditRefundRef != nil) { try container.encode(creditRefundRef, forKey: .creditRefundRef) }
            if (fiscalInvoiceNumber != nil) { try container.encode(fiscalInvoiceNumber, forKey: .fiscalInvoiceNumber) }
            if (installmentsQuantity != nil) { try container.encode(installmentsQuantity, forKey: .installmentsQuantity) }
            if (installmentsPlanCode != nil) { try container.encode(installmentsPlanCode, forKey: .installmentsPlanCode) }
            if (installmentsPlanId != nil) { try container.encode(installmentsPlanId, forKey: .installmentsPlanId) }
            if (installmentsPlanDesc != nil) { try container.encode(installmentsPlanDesc, forKey: .installmentsPlanDesc) }
            if (cardTypeLabel != nil) { try container.encode(cardTypeLabel, forKey: .cardTypeLabel) }
            if (cardSymbol != nil) { try container.encode(cardSymbol, forKey: .cardSymbol) }
            if (stan != nil) { try container.encode(stan, forKey: .stan) }
            if (identityDocument != nil) { try container.encode(identityDocument, forKey: .identityDocument) }
            if (batchNumber != nil) { try container.encode(batchNumber, forKey: .batchNumber) }
            if (receiptNumber != nil) { try container.encode(receiptNumber, forKey: .receiptNumber) }
            if (reversalStanRefNum != nil) { try container.encode(reversalStanRefNum, forKey: .reversalStanRefNum) }
            if (reversalStan != nil) { try container.encode(reversalStan, forKey: .reversalStan) }
            if (reversalMac != nil) { try container.encode(reversalMac, forKey: .reversalMac) }
            if (reversalMacKsn != nil) { try container.encode(reversalMacKsn, forKey: .reversalMacKsn) }
            if (terminalIdentification != nil) { try container.encode(terminalIdentification, forKey: .terminalIdentification) }
            if (externalTerminalId != nil) { try container.encode(externalTerminalId, forKey: .externalTerminalId) }
            if (merchantIdentifier != nil) { try container.encode(merchantIdentifier, forKey: .merchantIdentifier) }
            if (merchantNameLocation != nil) { try container.encode(merchantNameLocation, forKey: .merchantNameLocation) }
            if (maskedTrack2 != nil) { try container.encode(maskedTrack2, forKey: .maskedTrack2) }
            if (receiptExtraData != nil) { try container.encode(receiptExtraData, forKey: .receiptExtraData) }
            if (selectedService != nil) { try container.encode(selectedService, forKey: .selectedService) }
            if (transactionResult != nil) { try container.encode(transactionResult, forKey: .transactionResult) }
            if (transactionTags != nil) { try container.encode(transactionTags, forKey: .transactionTags) }
            if (txFormat != nil) { try container.encode(txFormat, forKey: .txFormat) }
            if (panMask != nil) { try container.encode(panMask, forKey: .panMask) }
            if (transactionSequenceCounter != nil) { try container.encode(transactionSequenceCounter, forKey: .transactionSequenceCounter) }
            if (applicationPanSequenceNumber != nil) { try container.encode(applicationPanSequenceNumber, forKey: .applicationPanSequenceNumber) }
            if (reversalReason != nil) { try container.encode(reversalReason, forKey: .reversalReason) }
            if (isTokenBasedTx != nil) { try container.encode(isTokenBasedTx, forKey: .isTokenBasedTx) }
            if (origTransactionSequenceCounter != nil) { try container.encode(origTransactionSequenceCounter, forKey: .origTransactionSequenceCounter) }
            if (transactionSequenceCounterUpdate != nil) { try container.encode(transactionSequenceCounterUpdate, forKey: .transactionSequenceCounterUpdate) }
            if (emergencyFlag != nil) { try container.encode(emergencyFlag, forKey: .emergencyFlag) }
            if (entryType != nil) { try container.encode(entryType, forKey: .entryType) }
            if (promotionalMessage != nil) { try container.encode(promotionalMessage, forKey: .promotionalMessage) }
            if (eCommTransactionInfo != nil) { try container.encode(eCommTransactionInfo, forKey: .eCommTransactionInfo) }
            if (sepaElvTransactionInfo != nil) { try container.encode(sepaElvTransactionInfo, forKey: .sepaElvTransactionInfo) }
            if (clientCardType != nil) { try container.encode(clientCardType, forKey: .clientCardType) }
            if (explicitlySelectedApp != nil) { try container.encode(explicitlySelectedApp, forKey: .explicitlySelectedApp) }
            if (isSepaElv != nil) { try container.encode(isSepaElv, forKey: .isSepaElv) }
            if (printMessages != nil) { try container.encode(printMessages, forKey: .printMessages) }
        }
    }

}