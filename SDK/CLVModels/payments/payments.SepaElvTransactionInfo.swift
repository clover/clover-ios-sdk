/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class SepaElvTransactionInfo: Codable {

        /// Value of tag E1.DF8206 from NEXO config.
        public var receiptFormat: String?
        /// Value of tag E6.DF8211 or E6.DF8212 (Online or Offline TX printout).
        public var extAppLabel: String?
        /// Value of tag E6.DF8214 info form NEXO config.
        public var preNotification: String?
        /// Value of tag E6.DF8215 info from NEXO config.
        public var mandate: String?
        /// Value of tag E6.DF8216 info from NEXO config.
        public var creditorId: String?
        /// Generated by SPA according to ELV â€“ TBD: use Trace number instead of receipt number.
        public var mandateId: String?
        /// Received in ICC related data from IPG (tag 5F53).
        public var iban: String?
        /// Defines if the corresponding SEPA ELV TX was forced by the merchant (override defined limit)
        public var isMerchantForced: Bool?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case receiptFormat
            case extAppLabel
            case preNotification
            case mandate
            case creditorId
            case mandateId
            case iban
            case isMerchantForced
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.receiptFormat = try rootContainer.decodeIfPresent(String.self, forKey: .receiptFormat)
            } catch {
                decodeError.append(error)
            }
            do {
                self.extAppLabel = try rootContainer.decodeIfPresent(String.self, forKey: .extAppLabel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.preNotification = try rootContainer.decodeIfPresent(String.self, forKey: .preNotification)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mandate = try rootContainer.decodeIfPresent(String.self, forKey: .mandate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditorId = try rootContainer.decodeIfPresent(String.self, forKey: .creditorId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mandateId = try rootContainer.decodeIfPresent(String.self, forKey: .mandateId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iban = try rootContainer.decodeIfPresent(String.self, forKey: .iban)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isMerchantForced = try rootContainer.decodeIfPresent(Bool.self, forKey: .isMerchantForced)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (receiptFormat != nil) { try container.encode(receiptFormat, forKey: .receiptFormat) }
            if (extAppLabel != nil) { try container.encode(extAppLabel, forKey: .extAppLabel) }
            if (preNotification != nil) { try container.encode(preNotification, forKey: .preNotification) }
            if (mandate != nil) { try container.encode(mandate, forKey: .mandate) }
            if (creditorId != nil) { try container.encode(creditorId, forKey: .creditorId) }
            if (mandateId != nil) { try container.encode(mandateId, forKey: .mandateId) }
            if (iban != nil) { try container.encode(iban, forKey: .iban) }
            if (isMerchantForced != nil) { try container.encode(isMerchantForced, forKey: .isMerchantForced) }
        }
    }

}