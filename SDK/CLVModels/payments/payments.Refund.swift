/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class Refund: Codable {

        /// Unique identifier
        public var id: String?
        /// The order with which the refund is associated
        public var orderRef: CLVModels.Base.Reference?
        /// Device which processed the transaction for this refund, a 128-bit UUID, not a normal base-13 Clover ID.
        public var device: CLVModels.Variant?
        /// Total amount refunded, including tax and tip
        public var amount: Int64?
        /// Tax amount refunded
        public var taxAmount: CLVModels.Variant?
        /// Tip amount refunded
        public var tipAmount: CLVModels.Variant?
        /// The time when the refund was recorded on the server
        public var createdTime: Date?
        /// The time when the refund was recorded on the client
        public var clientCreatedTime: Date?
        /// The payment with which the refund is associated
        public var payment: CLVModels.Base.Reference?
        public var employee: CLVModels.Base.Reference?
        public var lineItems: [CLVModels.Base.Reference]?
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var overrideMerchantTender: CLVModels.Base.Tender?
        public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
        public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
        public var additionalCharges: [CLVModels.Payments.AdditionalChargeAmount]?
        /// German region-specific information
        public var germanInfo: CLVModels.Variant?
        /// Tracking information for the app that created this refund.
        public var appTracking: CLVModels.Variant?
        public var voided: Bool?
        public var voidReason: String?
        /// Information about the card used for credit or debit card refunds
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        /// Transaction information
        public var transactionInfo: CLVModels.Variant?
        public var merchant: CLVModels.Base.Reference?
        /// The external reference id if associated with the refund
        public var externalReferenceId: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderRef
            case device
            case amount
            case taxAmount
            case tipAmount
            case createdTime
            case clientCreatedTime
            case payment
            case employee
            case lineItems
            case overrideMerchantTender
            case taxableAmountRates
            case serviceChargeAmount
            case additionalCharges
            case germanInfo
            case appTracking
            case voided
            case voidReason
            case cardTransaction
            case transactionInfo
            case merchant
            case externalReferenceId
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .orderRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.device = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .device)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .taxAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tipAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientCreatedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .clientCreatedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.payment = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .payment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employee = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .employee)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.lineItems)) {
                do {
                    let lineItemsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .lineItems)
                    self.lineItems = try lineItemsContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.overrideMerchantTender = try rootContainer.decodeIfPresent(CLVModels.Base.Tender.self, forKey: .overrideMerchantTender)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.taxableAmountRates)) {
                do {
                    let taxableAmountRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxableAmountRates)
                    self.taxableAmountRates = try taxableAmountRatesContainer.decodeIfPresent([CLVModels.Payments.TaxableAmountRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.serviceChargeAmount = try rootContainer.decodeIfPresent(CLVModels.Payments.ServiceChargeAmount.self, forKey: .serviceChargeAmount)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.additionalCharges)) {
                do {
                    let additionalChargesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .additionalCharges)
                    self.additionalCharges = try additionalChargesContainer.decodeIfPresent([CLVModels.Payments.AdditionalChargeAmount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.germanInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .germanInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.appTracking = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .appTracking)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voided = try rootContainer.decodeIfPresent(Bool.self, forKey: .voided)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voidReason = try rootContainer.decodeIfPresent(String.self, forKey: .voidReason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardTransaction = try rootContainer.decodeIfPresent(CLVModels.Payments.CardTransaction.self, forKey: .cardTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .transactionInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderRef != nil) { try container.encode(orderRef, forKey: .orderRef) }
            if (device != nil) { try container.encode(device, forKey: .device) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (taxAmount != nil) { try container.encode(taxAmount, forKey: .taxAmount) }
            if (tipAmount != nil) { try container.encode(tipAmount, forKey: .tipAmount) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (clientCreatedTime != nil) { try container.encode(clientCreatedTime, forKey: .clientCreatedTime) }
            if (payment != nil) { try container.encode(payment, forKey: .payment) }
            if (employee != nil) { try container.encode(employee, forKey: .employee) }
            if (lineItems != nil) { try container.encode(lineItems, forKey: .lineItems) }
            if (overrideMerchantTender != nil) { try container.encode(overrideMerchantTender, forKey: .overrideMerchantTender) }
            if (taxableAmountRates != nil) { try container.encode(taxableAmountRates, forKey: .taxableAmountRates) }
            if (serviceChargeAmount != nil) { try container.encode(serviceChargeAmount, forKey: .serviceChargeAmount) }
            if (additionalCharges != nil) { try container.encode(additionalCharges, forKey: .additionalCharges) }
            if (germanInfo != nil) { try container.encode(germanInfo, forKey: .germanInfo) }
            if (appTracking != nil) { try container.encode(appTracking, forKey: .appTracking) }
            if (voided != nil) { try container.encode(voided, forKey: .voided) }
            if (voidReason != nil) { try container.encode(voidReason, forKey: .voidReason) }
            if (cardTransaction != nil) { try container.encode(cardTransaction, forKey: .cardTransaction) }
            if (transactionInfo != nil) { try container.encode(transactionInfo, forKey: .transactionInfo) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
        }
    }

}