/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class CashAdvanceCustomerIdentification: Codable {

        public var idType: CLVModels.Payments.IdType?
        /// Identification serial number
        public var serialNumber: String?
        /// Masked identification serial number
        public var maskedSerialNumber: String?
        /// Encrypted identification serial number
        public var encryptedSerialNumber: String?
        /// Expiration date in format MMDDYYYY
        public var expirationDate: String?
        /// State in which identification was issued
        public var issuingState: String?
        /// Country in which identification was issued
        public var issuingCountry: String?
        /// Full customer name
        public var customerName: String?
        public var addressStreet1: String?
        public var addressStreet2: String?
        public var addressCity: String?
        public var addressState: String?
        public var addressZipCode: String?
        public var addressCountry: String?
        /// Employee id
        public var tellerID: Int32?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case idType
            case serialNumber
            case maskedSerialNumber
            case encryptedSerialNumber
            case expirationDate
            case issuingState
            case issuingCountry
            case customerName
            case addressStreet1
            case addressStreet2
            case addressCity
            case addressState
            case addressZipCode
            case addressCountry
            case tellerID
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.idType = try rootContainer.decodeIfPresent(CLVModels.Payments.IdType.self, forKey: .idType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serialNumber = try rootContainer.decodeIfPresent(String.self, forKey: .serialNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedSerialNumber = try rootContainer.decodeIfPresent(String.self, forKey: .maskedSerialNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.encryptedSerialNumber = try rootContainer.decodeIfPresent(String.self, forKey: .encryptedSerialNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.expirationDate = try rootContainer.decodeIfPresent(String.self, forKey: .expirationDate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.issuingState = try rootContainer.decodeIfPresent(String.self, forKey: .issuingState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.issuingCountry = try rootContainer.decodeIfPresent(String.self, forKey: .issuingCountry)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerName = try rootContainer.decodeIfPresent(String.self, forKey: .customerName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressStreet1 = try rootContainer.decodeIfPresent(String.self, forKey: .addressStreet1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressStreet2 = try rootContainer.decodeIfPresent(String.self, forKey: .addressStreet2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressCity = try rootContainer.decodeIfPresent(String.self, forKey: .addressCity)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressState = try rootContainer.decodeIfPresent(String.self, forKey: .addressState)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressZipCode = try rootContainer.decodeIfPresent(String.self, forKey: .addressZipCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.addressCountry = try rootContainer.decodeIfPresent(String.self, forKey: .addressCountry)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tellerID = try rootContainer.decodeIfPresent(Int32.self, forKey: .tellerID)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (idType != nil) { try container.encode(idType, forKey: .idType) }
            if (serialNumber != nil) { try container.encode(serialNumber, forKey: .serialNumber) }
            if (maskedSerialNumber != nil) { try container.encode(maskedSerialNumber, forKey: .maskedSerialNumber) }
            if (encryptedSerialNumber != nil) { try container.encode(encryptedSerialNumber, forKey: .encryptedSerialNumber) }
            if (expirationDate != nil) { try container.encode(expirationDate, forKey: .expirationDate) }
            if (issuingState != nil) { try container.encode(issuingState, forKey: .issuingState) }
            if (issuingCountry != nil) { try container.encode(issuingCountry, forKey: .issuingCountry) }
            if (customerName != nil) { try container.encode(customerName, forKey: .customerName) }
            if (addressStreet1 != nil) { try container.encode(addressStreet1, forKey: .addressStreet1) }
            if (addressStreet2 != nil) { try container.encode(addressStreet2, forKey: .addressStreet2) }
            if (addressCity != nil) { try container.encode(addressCity, forKey: .addressCity) }
            if (addressState != nil) { try container.encode(addressState, forKey: .addressState) }
            if (addressZipCode != nil) { try container.encode(addressZipCode, forKey: .addressZipCode) }
            if (addressCountry != nil) { try container.encode(addressCountry, forKey: .addressCountry) }
            if (tellerID != nil) { try container.encode(tellerID, forKey: .tellerID) }
        }
    }

}