/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class TokenRequest: Codable {

        /// Unique identifier
        public var id: String?
        /// Type of request
        public var type_: CLVModels.Payments.TokenRequestType?
        /// The employee who processed the token request
        public var employee: CLVModels.Base.Reference?
        /// The device that processed the token request, a 128-bit UUID, not a normal base-13 Clover ID.
        public var device: CLVModels.Base.Reference?
        /// The merchant associate with this token request
        public var merchant: CLVModels.Base.Reference?
        /// The tender associated with this token request
        public var tender: CLVModels.Base.Tender?
        /// GatewayTx id
        public var gatewayTxId: Int64?
        /// The customer associated with this token request
        public var customer: CLVModels.Customers.Customer?
        /// Merchant-specified reference number
        public var externalReferenceId: String?
        /// Information about the card used for the token request
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        /// Note input by the merchant
        public var note: String?
        /// Result of this token request
        public var result: CLVModels.Payments.Result?
        /// Time that the token request was recorded on the server
        public var createdTime: Date?
        /// Time that the token request was initiated on the device
        public var modifiedTime: Date?
        /// Time that the token request was deleted
        public var deletedTime: Date?
        /// Information over transaction information
        public var transactionInfo: CLVModels.Payments.TransactionInfo?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case type
            case employee
            case device
            case merchant
            case tender
            case gatewayTxId
            case customer
            case externalReferenceId
            case cardTransaction
            case note
            case result
            case createdTime
            case modifiedTime
            case deletedTime
            case transactionInfo
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Payments.TokenRequestType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employee = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .employee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.device = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .device)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tender = try rootContainer.decodeIfPresent(CLVModels.Base.Tender.self, forKey: .tender)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gatewayTxId = try rootContainer.decodeIfPresent(Int64.self, forKey: .gatewayTxId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customer = try rootContainer.decodeIfPresent(CLVModels.Customers.Customer.self, forKey: .customer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(String.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardTransaction = try rootContainer.decodeIfPresent(CLVModels.Payments.CardTransaction.self, forKey: .cardTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.note = try rootContainer.decodeIfPresent(String.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            do {
                self.result = try rootContainer.decodeIfPresent(CLVModels.Payments.Result.self, forKey: .result)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deletedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .deletedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionInfo = try rootContainer.decodeIfPresent(CLVModels.Payments.TransactionInfo.self, forKey: .transactionInfo)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (employee != nil) { try container.encode(employee, forKey: .employee) }
            if (device != nil) { try container.encode(device, forKey: .device) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (tender != nil) { try container.encode(tender, forKey: .tender) }
            if (gatewayTxId != nil) { try container.encode(gatewayTxId, forKey: .gatewayTxId) }
            if (customer != nil) { try container.encode(customer, forKey: .customer) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
            if (cardTransaction != nil) { try container.encode(cardTransaction, forKey: .cardTransaction) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (result != nil) { try container.encode(result, forKey: .result) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (deletedTime != nil) { try container.encode(deletedTime, forKey: .deletedTime) }
            if (transactionInfo != nil) { try container.encode(transactionInfo, forKey: .transactionInfo) }
        }
    }

}