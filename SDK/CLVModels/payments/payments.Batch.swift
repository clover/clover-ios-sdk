/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class Batch: Codable {

        public var id: String?
        public var merchantRef: CLVModels.Base.Reference?
        public var firstGatewayTxId: Int64?
        public var lastGatewayTxId: Int64?
        /// The id of employee who executed batch
        public var accountId: Int64?
        /// URL pointing to rapid deposit i.e. clover.com/help/rapid-deposit.
        public var rapidDepositUrl: String?
        /// The number of transactions being batched
        public var txCount: Int64?
        /// Total amount closed
        public var totalBatchAmount: Int64?
        /// List of devices in batch
        public var devices: String?
        public var state: CLVModels.Payments.BatchState?
        public var batchType: CLVModels.Payments.BatchType?
        /// Created time of batch
        public var createdTime: Date?
        /// Modified time of batch
        public var modifiedTime: Date?
        /// Time difference in minutes between expected and actual closeout
        public var closeoutTimeDifference: Int64?
        /// Details split based on card / employees
        public var batchDetails: CLVModels.Payments.BatchDetail?
        /// List of payments, refunds, and gift card transaction reference objects in the batch
        public var batchTransactions: CLVModels.Payments.BatchTransactions?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case merchantRef
            case firstGatewayTxId
            case lastGatewayTxId
            case accountId
            case rapidDepositUrl
            case txCount
            case totalBatchAmount
            case devices
            case state
            case batchType
            case createdTime
            case modifiedTime
            case closeoutTimeDifference
            case batchDetails
            case batchTransactions
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchantRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.firstGatewayTxId = try rootContainer.decodeIfPresent(Int64.self, forKey: .firstGatewayTxId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.lastGatewayTxId = try rootContainer.decodeIfPresent(Int64.self, forKey: .lastGatewayTxId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.accountId = try rootContainer.decodeIfPresent(Int64.self, forKey: .accountId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.rapidDepositUrl = try rootContainer.decodeIfPresent(String.self, forKey: .rapidDepositUrl)
            } catch {
                decodeError.append(error)
            }
            do {
                self.txCount = try rootContainer.decodeIfPresent(Int64.self, forKey: .txCount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.totalBatchAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .totalBatchAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.devices = try rootContainer.decodeIfPresent(String.self, forKey: .devices)
            } catch {
                decodeError.append(error)
            }
            do {
                self.state = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchState.self, forKey: .state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.batchType = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchType.self, forKey: .batchType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.closeoutTimeDifference = try rootContainer.decodeIfPresent(Int64.self, forKey: .closeoutTimeDifference)
            } catch {
                decodeError.append(error)
            }
            do {
                self.batchDetails = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchDetail.self, forKey: .batchDetails)
            } catch {
                decodeError.append(error)
            }
            do {
                self.batchTransactions = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTransactions.self, forKey: .batchTransactions)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (merchantRef != nil) { try container.encode(merchantRef, forKey: .merchantRef) }
            if (firstGatewayTxId != nil) { try container.encode(firstGatewayTxId, forKey: .firstGatewayTxId) }
            if (lastGatewayTxId != nil) { try container.encode(lastGatewayTxId, forKey: .lastGatewayTxId) }
            if (accountId != nil) { try container.encode(accountId, forKey: .accountId) }
            if (rapidDepositUrl != nil) { try container.encode(rapidDepositUrl, forKey: .rapidDepositUrl) }
            if (txCount != nil) { try container.encode(txCount, forKey: .txCount) }
            if (totalBatchAmount != nil) { try container.encode(totalBatchAmount, forKey: .totalBatchAmount) }
            if (devices != nil) { try container.encode(devices, forKey: .devices) }
            if (state != nil) { try container.encode(state, forKey: .state) }
            if (batchType != nil) { try container.encode(batchType, forKey: .batchType) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (closeoutTimeDifference != nil) { try container.encode(closeoutTimeDifference, forKey: .closeoutTimeDifference) }
            if (batchDetails != nil) { try container.encode(batchDetails, forKey: .batchDetails) }
            if (batchTransactions != nil) { try container.encode(batchTransactions, forKey: .batchTransactions) }
        }
    }

}