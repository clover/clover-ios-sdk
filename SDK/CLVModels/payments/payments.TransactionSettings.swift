/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class TransactionSettings: Codable {

        public var cardEntryMethods: Int32?
        public var disableCashBack: Bool?
        public var cloverShouldHandleReceipts: Bool?
        public var forcePinEntryOnSwipe: Bool?
        public var disableRestartTransactionOnFailure: Bool?
        public var allowOfflinePayment: Bool?
        public var approveOfflinePaymentWithoutPrompt: Bool?
        public var forceOfflinePayment: Bool?
        public var signatureThreshold: Int64?
        public var signatureEntryLocation: CLVModels.Payments.DataEntryLocation?
        public var tipMode: CLVModels.Payments.TipMode?
        public var tippableAmount: Int64?
        public var disableReceiptSelection: Bool?
        public var disableDuplicateCheck: Bool?
        /// If set to true, confirmation requests triggered by a challenge at the payment gateway are automatically accepted, and confirmation requests are not transmitted back to the calling program. Be sure you are willing to accept the risk associated with accepting offline or duplicate payment challenges. See https://docs.clover.com/build/working-with-challenges for more information.
        public var autoAcceptPaymentConfirmations: Bool?
        public var autoAcceptSignature: Bool?
        public var returnResultOnTransactionComplete: Bool?
        public var tipSuggestions: [CLVModels.Merchant.TipSuggestion]?
        public var regionalExtras: [String:String]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case cardEntryMethods
            case disableCashBack
            case cloverShouldHandleReceipts
            case forcePinEntryOnSwipe
            case disableRestartTransactionOnFailure
            case allowOfflinePayment
            case approveOfflinePaymentWithoutPrompt
            case forceOfflinePayment
            case signatureThreshold
            case signatureEntryLocation
            case tipMode
            case tippableAmount
            case disableReceiptSelection
            case disableDuplicateCheck
            case autoAcceptPaymentConfirmations
            case autoAcceptSignature
            case returnResultOnTransactionComplete
            case tipSuggestions
            case regionalExtras
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.cardEntryMethods = try rootContainer.decodeIfPresent(Int32.self, forKey: .cardEntryMethods)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableCashBack = try rootContainer.decodeIfPresent(Bool.self, forKey: .disableCashBack)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cloverShouldHandleReceipts = try rootContainer.decodeIfPresent(Bool.self, forKey: .cloverShouldHandleReceipts)
            } catch {
                decodeError.append(error)
            }
            do {
                self.forcePinEntryOnSwipe = try rootContainer.decodeIfPresent(Bool.self, forKey: .forcePinEntryOnSwipe)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableRestartTransactionOnFailure = try rootContainer.decodeIfPresent(Bool.self, forKey: .disableRestartTransactionOnFailure)
            } catch {
                decodeError.append(error)
            }
            do {
                self.allowOfflinePayment = try rootContainer.decodeIfPresent(Bool.self, forKey: .allowOfflinePayment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.approveOfflinePaymentWithoutPrompt = try rootContainer.decodeIfPresent(Bool.self, forKey: .approveOfflinePaymentWithoutPrompt)
            } catch {
                decodeError.append(error)
            }
            do {
                self.forceOfflinePayment = try rootContainer.decodeIfPresent(Bool.self, forKey: .forceOfflinePayment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signatureThreshold = try rootContainer.decodeIfPresent(Int64.self, forKey: .signatureThreshold)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signatureEntryLocation = try rootContainer.decodeIfPresent(CLVModels.Payments.DataEntryLocation.self, forKey: .signatureEntryLocation)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipMode = try rootContainer.decodeIfPresent(CLVModels.Payments.TipMode.self, forKey: .tipMode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tippableAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .tippableAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableReceiptSelection = try rootContainer.decodeIfPresent(Bool.self, forKey: .disableReceiptSelection)
            } catch {
                decodeError.append(error)
            }
            do {
                self.disableDuplicateCheck = try rootContainer.decodeIfPresent(Bool.self, forKey: .disableDuplicateCheck)
            } catch {
                decodeError.append(error)
            }
            do {
                self.autoAcceptPaymentConfirmations = try rootContainer.decodeIfPresent(Bool.self, forKey: .autoAcceptPaymentConfirmations)
            } catch {
                decodeError.append(error)
            }
            do {
                self.autoAcceptSignature = try rootContainer.decodeIfPresent(Bool.self, forKey: .autoAcceptSignature)
            } catch {
                decodeError.append(error)
            }
            do {
                self.returnResultOnTransactionComplete = try rootContainer.decodeIfPresent(Bool.self, forKey: .returnResultOnTransactionComplete)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.tipSuggestions)) {
                do {
                    let tipSuggestionsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .tipSuggestions)
                    self.tipSuggestions = try tipSuggestionsContainer.decodeIfPresent([CLVModels.Merchant.TipSuggestion].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.regionalExtras = try rootContainer.decodeIfPresent([String:String].self, forKey: .regionalExtras)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (cardEntryMethods != nil) { try container.encode(cardEntryMethods, forKey: .cardEntryMethods) }
            if (disableCashBack != nil) { try container.encode(disableCashBack, forKey: .disableCashBack) }
            if (cloverShouldHandleReceipts != nil) { try container.encode(cloverShouldHandleReceipts, forKey: .cloverShouldHandleReceipts) }
            if (forcePinEntryOnSwipe != nil) { try container.encode(forcePinEntryOnSwipe, forKey: .forcePinEntryOnSwipe) }
            if (disableRestartTransactionOnFailure != nil) { try container.encode(disableRestartTransactionOnFailure, forKey: .disableRestartTransactionOnFailure) }
            if (allowOfflinePayment != nil) { try container.encode(allowOfflinePayment, forKey: .allowOfflinePayment) }
            if (approveOfflinePaymentWithoutPrompt != nil) { try container.encode(approveOfflinePaymentWithoutPrompt, forKey: .approveOfflinePaymentWithoutPrompt) }
            if (forceOfflinePayment != nil) { try container.encode(forceOfflinePayment, forKey: .forceOfflinePayment) }
            if (signatureThreshold != nil) { try container.encode(signatureThreshold, forKey: .signatureThreshold) }
            if (signatureEntryLocation != nil) { try container.encode(signatureEntryLocation, forKey: .signatureEntryLocation) }
            if (tipMode != nil) { try container.encode(tipMode, forKey: .tipMode) }
            if (tippableAmount != nil) { try container.encode(tippableAmount, forKey: .tippableAmount) }
            if (disableReceiptSelection != nil) { try container.encode(disableReceiptSelection, forKey: .disableReceiptSelection) }
            if (disableDuplicateCheck != nil) { try container.encode(disableDuplicateCheck, forKey: .disableDuplicateCheck) }
            if (autoAcceptPaymentConfirmations != nil) { try container.encode(autoAcceptPaymentConfirmations, forKey: .autoAcceptPaymentConfirmations) }
            if (autoAcceptSignature != nil) { try container.encode(autoAcceptSignature, forKey: .autoAcceptSignature) }
            if (returnResultOnTransactionComplete != nil) { try container.encode(returnResultOnTransactionComplete, forKey: .returnResultOnTransactionComplete) }
            if (tipSuggestions != nil) { try container.encode(tipSuggestions, forKey: .tipSuggestions) }
            if (regionalExtras != nil) { try container.encode(regionalExtras, forKey: .regionalExtras) }
        }
    }

}