/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class GatewayTxs: Codable {

        public var merchantGatewayId: Int64?
        public var clientId: String?
        public var amount: Int64?
        public var adjustAmount: Int64?
        public var taxAmount: Int64?
        public var tipAmount: Int64?
        public var refundTaxAmount: Int64?
        public var currency: CLVModels.Payments.Currency?
        public var state: CLVModels.Payments.GatewayTxState?
        public var retries: Int64?
        public var type_: CLVModels.Payments.GatewayTxType?
        public var entryType: CLVModels.Payments.CardEntryType?
        public var responseCode: String?
        public var responseMessage: String?
        public var first4: String?
        public var last4: String?
        public var cardType: CLVModels.Payments.CardType?
        public var refnum: String?
        public var token: String?
        public var authcode: String?
        public var employeeId: String?
        public var extra: String?
        public var captured: CLVModels.Variant?
        public var swiperSerial: String?
        public var ksnPrefix: String?
        public var createdTime: Date?
        public var modifiedTime: Date?
        public var refundId: CLVModels.Variant?
        public var paymentRefundId: CLVModels.Variant?
        public var extraGatewayInfo: [String:String]?
        public var refundDeviceId: CLVModels.Variant?
        public var paymentDeviceId: CLVModels.Variant?
        public var paymentUuid: String?
        public var refundUuid: String?
        public var creditUuid: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case merchantGatewayId
            case clientId
            case amount
            case adjustAmount
            case taxAmount
            case tipAmount
            case refundTaxAmount
            case currency
            case state
            case retries
            case type
            case entryType
            case responseCode
            case responseMessage
            case first4
            case last4
            case cardType
            case refnum
            case token
            case authcode
            case employeeId
            case extra
            case captured
            case swiperSerial
            case ksnPrefix
            case createdTime
            case modifiedTime
            case refundId
            case paymentRefundId
            case extraGatewayInfo
            case refundDeviceId
            case paymentDeviceId
            case paymentUuid
            case refundUuid
            case creditUuid
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.merchantGatewayId = try rootContainer.decodeIfPresent(Int64.self, forKey: .merchantGatewayId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientId = try rootContainer.decodeIfPresent(String.self, forKey: .clientId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.adjustAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .adjustAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .taxAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .tipAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundTaxAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .refundTaxAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.currency = try rootContainer.decodeIfPresent(CLVModels.Payments.Currency.self, forKey: .currency)
            } catch {
                decodeError.append(error)
            }
            do {
                self.state = try rootContainer.decodeIfPresent(CLVModels.Payments.GatewayTxState.self, forKey: .state)
            } catch {
                decodeError.append(error)
            }
            do {
                self.retries = try rootContainer.decodeIfPresent(Int64.self, forKey: .retries)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Payments.GatewayTxType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.entryType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardEntryType.self, forKey: .entryType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.responseCode = try rootContainer.decodeIfPresent(String.self, forKey: .responseCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.responseMessage = try rootContainer.decodeIfPresent(String.self, forKey: .responseMessage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.first4 = try rootContainer.decodeIfPresent(String.self, forKey: .first4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.last4 = try rootContainer.decodeIfPresent(String.self, forKey: .last4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardType.self, forKey: .cardType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refnum = try rootContainer.decodeIfPresent(String.self, forKey: .refnum)
            } catch {
                decodeError.append(error)
            }
            do {
                self.token = try rootContainer.decodeIfPresent(String.self, forKey: .token)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authcode = try rootContainer.decodeIfPresent(String.self, forKey: .authcode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employeeId = try rootContainer.decodeIfPresent(String.self, forKey: .employeeId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.extra = try rootContainer.decodeIfPresent(String.self, forKey: .extra)
            } catch {
                decodeError.append(error)
            }
            do {
                self.captured = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .captured)
            } catch {
                decodeError.append(error)
            }
            do {
                self.swiperSerial = try rootContainer.decodeIfPresent(String.self, forKey: .swiperSerial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ksnPrefix = try rootContainer.decodeIfPresent(String.self, forKey: .ksnPrefix)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .refundId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentRefundId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .paymentRefundId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.extraGatewayInfo = try rootContainer.decodeIfPresent([String:String].self, forKey: .extraGatewayInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundDeviceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .refundDeviceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentDeviceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .paymentDeviceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentUuid = try rootContainer.decodeIfPresent(String.self, forKey: .paymentUuid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundUuid = try rootContainer.decodeIfPresent(String.self, forKey: .refundUuid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditUuid = try rootContainer.decodeIfPresent(String.self, forKey: .creditUuid)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (merchantGatewayId != nil) { try container.encode(merchantGatewayId, forKey: .merchantGatewayId) }
            if (clientId != nil) { try container.encode(clientId, forKey: .clientId) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (adjustAmount != nil) { try container.encode(adjustAmount, forKey: .adjustAmount) }
            if (taxAmount != nil) { try container.encode(taxAmount, forKey: .taxAmount) }
            if (tipAmount != nil) { try container.encode(tipAmount, forKey: .tipAmount) }
            if (refundTaxAmount != nil) { try container.encode(refundTaxAmount, forKey: .refundTaxAmount) }
            if (currency != nil) { try container.encode(currency, forKey: .currency) }
            if (state != nil) { try container.encode(state, forKey: .state) }
            if (retries != nil) { try container.encode(retries, forKey: .retries) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (entryType != nil) { try container.encode(entryType, forKey: .entryType) }
            if (responseCode != nil) { try container.encode(responseCode, forKey: .responseCode) }
            if (responseMessage != nil) { try container.encode(responseMessage, forKey: .responseMessage) }
            if (first4 != nil) { try container.encode(first4, forKey: .first4) }
            if (last4 != nil) { try container.encode(last4, forKey: .last4) }
            if (cardType != nil) { try container.encode(cardType, forKey: .cardType) }
            if (refnum != nil) { try container.encode(refnum, forKey: .refnum) }
            if (token != nil) { try container.encode(token, forKey: .token) }
            if (authcode != nil) { try container.encode(authcode, forKey: .authcode) }
            if (employeeId != nil) { try container.encode(employeeId, forKey: .employeeId) }
            if (extra != nil) { try container.encode(extra, forKey: .extra) }
            if (captured != nil) { try container.encode(captured, forKey: .captured) }
            if (swiperSerial != nil) { try container.encode(swiperSerial, forKey: .swiperSerial) }
            if (ksnPrefix != nil) { try container.encode(ksnPrefix, forKey: .ksnPrefix) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (refundId != nil) { try container.encode(refundId, forKey: .refundId) }
            if (paymentRefundId != nil) { try container.encode(paymentRefundId, forKey: .paymentRefundId) }
            if (extraGatewayInfo != nil) { try container.encode(extraGatewayInfo, forKey: .extraGatewayInfo) }
            if (refundDeviceId != nil) { try container.encode(refundDeviceId, forKey: .refundDeviceId) }
            if (paymentDeviceId != nil) { try container.encode(paymentDeviceId, forKey: .paymentDeviceId) }
            if (paymentUuid != nil) { try container.encode(paymentUuid, forKey: .paymentUuid) }
            if (refundUuid != nil) { try container.encode(refundUuid, forKey: .refundUuid) }
            if (creditUuid != nil) { try container.encode(creditUuid, forKey: .creditUuid) }
        }
    }

}