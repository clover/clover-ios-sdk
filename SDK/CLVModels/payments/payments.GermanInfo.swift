/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class GermanInfo: Codable {

        public var cardTrack2: String?
        public var cardSequenceNumber: String?
        public var transactionCaseGermany: String?
        public var transactionTypeGermany: String?
        public var terminalID: String?
        public var traceNumber: String?
        public var oldTraceNumber: String?
        public var receiptNumber: String?
        public var transactionAID: String?
        public var transactionMSApp: String?
        public var transactionScriptResults: String?
        public var receiptType: String?
        public var customerTransactionDOLValues: String?
        public var merchantTransactionDOLValues: String?
        public var merchantJournalDOL: String?
        public var merchantJournalDOLValues: String?
        public var configMerchantId: String?
        public var configProductLabel: String?
        public var hostResponseAidParBMP53: String?
        public var hostResponsePrintDataBM60: String?
        public var sepaElvReceiptFormat: String?
        public var sepaElvExtAppLabel: String?
        public var sepaElvPreNotification: String?
        public var sepaElvMandate: String?
        public var sepaElvCreditorId: String?
        public var sepaElvMandateId: String?
        public var sepaElvIban: String?
        /// The payment with which this German info is associated
        public var paymentRef: CLVModels.Base.Reference?
        /// The credit with which this German info is associated
        public var creditRef: CLVModels.Base.Reference?
        /// The refund with which this German info is associated
        public var refundRef: CLVModels.Base.Reference?
        /// The credit refund with which this German info is associated
        public var creditRefundRef: CLVModels.Base.Reference?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case cardTrack2
            case cardSequenceNumber
            case transactionCaseGermany
            case transactionTypeGermany
            case terminalID
            case traceNumber
            case oldTraceNumber
            case receiptNumber
            case transactionAID
            case transactionMSApp
            case transactionScriptResults
            case receiptType
            case customerTransactionDOLValues
            case merchantTransactionDOLValues
            case merchantJournalDOL
            case merchantJournalDOLValues
            case configMerchantId
            case configProductLabel
            case hostResponseAidParBMP53
            case hostResponsePrintDataBM60
            case sepaElvReceiptFormat
            case sepaElvExtAppLabel
            case sepaElvPreNotification
            case sepaElvMandate
            case sepaElvCreditorId
            case sepaElvMandateId
            case sepaElvIban
            case paymentRef
            case creditRef
            case refundRef
            case creditRefundRef
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.cardTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .cardTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardSequenceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .cardSequenceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionCaseGermany = try rootContainer.decodeIfPresent(String.self, forKey: .transactionCaseGermany)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionTypeGermany = try rootContainer.decodeIfPresent(String.self, forKey: .transactionTypeGermany)
            } catch {
                decodeError.append(error)
            }
            do {
                self.terminalID = try rootContainer.decodeIfPresent(String.self, forKey: .terminalID)
            } catch {
                decodeError.append(error)
            }
            do {
                self.traceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .traceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.oldTraceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .oldTraceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receiptNumber = try rootContainer.decodeIfPresent(String.self, forKey: .receiptNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionAID = try rootContainer.decodeIfPresent(String.self, forKey: .transactionAID)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionMSApp = try rootContainer.decodeIfPresent(String.self, forKey: .transactionMSApp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionScriptResults = try rootContainer.decodeIfPresent(String.self, forKey: .transactionScriptResults)
            } catch {
                decodeError.append(error)
            }
            do {
                self.receiptType = try rootContainer.decodeIfPresent(String.self, forKey: .receiptType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customerTransactionDOLValues = try rootContainer.decodeIfPresent(String.self, forKey: .customerTransactionDOLValues)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantTransactionDOLValues = try rootContainer.decodeIfPresent(String.self, forKey: .merchantTransactionDOLValues)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantJournalDOL = try rootContainer.decodeIfPresent(String.self, forKey: .merchantJournalDOL)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchantJournalDOLValues = try rootContainer.decodeIfPresent(String.self, forKey: .merchantJournalDOLValues)
            } catch {
                decodeError.append(error)
            }
            do {
                self.configMerchantId = try rootContainer.decodeIfPresent(String.self, forKey: .configMerchantId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.configProductLabel = try rootContainer.decodeIfPresent(String.self, forKey: .configProductLabel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hostResponseAidParBMP53 = try rootContainer.decodeIfPresent(String.self, forKey: .hostResponseAidParBMP53)
            } catch {
                decodeError.append(error)
            }
            do {
                self.hostResponsePrintDataBM60 = try rootContainer.decodeIfPresent(String.self, forKey: .hostResponsePrintDataBM60)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvReceiptFormat = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvReceiptFormat)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvExtAppLabel = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvExtAppLabel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvPreNotification = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvPreNotification)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvMandate = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvMandate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvCreditorId = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvCreditorId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvMandateId = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvMandateId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sepaElvIban = try rootContainer.decodeIfPresent(String.self, forKey: .sepaElvIban)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .paymentRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .refundRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRefundRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRefundRef)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (cardTrack2 != nil) { try container.encode(cardTrack2, forKey: .cardTrack2) }
            if (cardSequenceNumber != nil) { try container.encode(cardSequenceNumber, forKey: .cardSequenceNumber) }
            if (transactionCaseGermany != nil) { try container.encode(transactionCaseGermany, forKey: .transactionCaseGermany) }
            if (transactionTypeGermany != nil) { try container.encode(transactionTypeGermany, forKey: .transactionTypeGermany) }
            if (terminalID != nil) { try container.encode(terminalID, forKey: .terminalID) }
            if (traceNumber != nil) { try container.encode(traceNumber, forKey: .traceNumber) }
            if (oldTraceNumber != nil) { try container.encode(oldTraceNumber, forKey: .oldTraceNumber) }
            if (receiptNumber != nil) { try container.encode(receiptNumber, forKey: .receiptNumber) }
            if (transactionAID != nil) { try container.encode(transactionAID, forKey: .transactionAID) }
            if (transactionMSApp != nil) { try container.encode(transactionMSApp, forKey: .transactionMSApp) }
            if (transactionScriptResults != nil) { try container.encode(transactionScriptResults, forKey: .transactionScriptResults) }
            if (receiptType != nil) { try container.encode(receiptType, forKey: .receiptType) }
            if (customerTransactionDOLValues != nil) { try container.encode(customerTransactionDOLValues, forKey: .customerTransactionDOLValues) }
            if (merchantTransactionDOLValues != nil) { try container.encode(merchantTransactionDOLValues, forKey: .merchantTransactionDOLValues) }
            if (merchantJournalDOL != nil) { try container.encode(merchantJournalDOL, forKey: .merchantJournalDOL) }
            if (merchantJournalDOLValues != nil) { try container.encode(merchantJournalDOLValues, forKey: .merchantJournalDOLValues) }
            if (configMerchantId != nil) { try container.encode(configMerchantId, forKey: .configMerchantId) }
            if (configProductLabel != nil) { try container.encode(configProductLabel, forKey: .configProductLabel) }
            if (hostResponseAidParBMP53 != nil) { try container.encode(hostResponseAidParBMP53, forKey: .hostResponseAidParBMP53) }
            if (hostResponsePrintDataBM60 != nil) { try container.encode(hostResponsePrintDataBM60, forKey: .hostResponsePrintDataBM60) }
            if (sepaElvReceiptFormat != nil) { try container.encode(sepaElvReceiptFormat, forKey: .sepaElvReceiptFormat) }
            if (sepaElvExtAppLabel != nil) { try container.encode(sepaElvExtAppLabel, forKey: .sepaElvExtAppLabel) }
            if (sepaElvPreNotification != nil) { try container.encode(sepaElvPreNotification, forKey: .sepaElvPreNotification) }
            if (sepaElvMandate != nil) { try container.encode(sepaElvMandate, forKey: .sepaElvMandate) }
            if (sepaElvCreditorId != nil) { try container.encode(sepaElvCreditorId, forKey: .sepaElvCreditorId) }
            if (sepaElvMandateId != nil) { try container.encode(sepaElvMandateId, forKey: .sepaElvMandateId) }
            if (sepaElvIban != nil) { try container.encode(sepaElvIban, forKey: .sepaElvIban) }
            if (paymentRef != nil) { try container.encode(paymentRef, forKey: .paymentRef) }
            if (creditRef != nil) { try container.encode(creditRef, forKey: .creditRef) }
            if (refundRef != nil) { try container.encode(refundRef, forKey: .refundRef) }
            if (creditRefundRef != nil) { try container.encode(creditRefundRef, forKey: .creditRefundRef) }
        }
    }

}