/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class Authorization: Codable {

        /// Unique identifier
        public var id: String?
        /// Payment that the auth was opened with
        public var payment: CLVModels.Payments.Payment?
        /// Name of tab
        public var tabName: CLVModels.Variant?
        /// Amount authorized
        public var amount: Int64?
        /// Type of credit card used for authorization
        public var cardType: CLVModels.Payments.CardType?
        /// Last 4 digits of credit card used for authorization
        public var last4: String?
        /// Authorization code
        public var authcode: String?
        /// Token used for the authorization
        public var token: String?
        public var type_: CLVModels.Payments.Type_?
        public var note: CLVModels.Variant?
        /// The external reference id if associated with the payment
        public var externalReferenceId: CLVModels.Variant?
        /// Payment that the auth was closed with
        public var closingPayment: CLVModels.Payments.Payment?
        /// Time authorization was recorded on server
        public var createdTime: Date?
        /// Additional charges associated with the authorization. For incremental auth, it is the additional charge on total auth amount.
        public var additionalCharges: [CLVModels.Payments.AdditionalChargeAmount]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case payment
            case tabName
            case amount
            case cardType
            case last4
            case authcode
            case token
            case type
            case note
            case externalReferenceId
            case closingPayment
            case createdTime
            case additionalCharges
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.payment = try rootContainer.decodeIfPresent(CLVModels.Payments.Payment.self, forKey: .payment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tabName = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tabName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardType.self, forKey: .cardType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.last4 = try rootContainer.decodeIfPresent(String.self, forKey: .last4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authcode = try rootContainer.decodeIfPresent(String.self, forKey: .authcode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.token = try rootContainer.decodeIfPresent(String.self, forKey: .token)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Payments.Type_.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.note = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.closingPayment = try rootContainer.decodeIfPresent(CLVModels.Payments.Payment.self, forKey: .closingPayment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.additionalCharges)) {
                do {
                    let additionalChargesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .additionalCharges)
                    self.additionalCharges = try additionalChargesContainer.decodeIfPresent([CLVModels.Payments.AdditionalChargeAmount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (payment != nil) { try container.encode(payment, forKey: .payment) }
            if (tabName != nil) { try container.encode(tabName, forKey: .tabName) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (cardType != nil) { try container.encode(cardType, forKey: .cardType) }
            if (last4 != nil) { try container.encode(last4, forKey: .last4) }
            if (authcode != nil) { try container.encode(authcode, forKey: .authcode) }
            if (token != nil) { try container.encode(token, forKey: .token) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
            if (closingPayment != nil) { try container.encode(closingPayment, forKey: .closingPayment) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (additionalCharges != nil) { try container.encode(additionalCharges, forKey: .additionalCharges) }
        }
    }

}