/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class DCCInfo: Codable {

        /// Inquiry Rate ID (IPG)
        public var inquiryRateId: Int64?
        /// Flag indicating whether DCC was applied on this txn
        public var dccApplied: Bool?
        /// Foreign currency code
        public var foreignCurrencyCode: String?
        /// Foreign (transaction) amount
        public var foreignAmount: Int64?
        /// Exchange Rate
        public var exchangeRate: Double?
        /// Margin Rate Percentage
        public var marginRatePercentage: String?
        /// Exchange Rate Source Name
        public var exchangeRateSourceName: String?
        /// Exchange Rate Source Timestamp
        public var exchangeRateSourceTimeStamp: String?
        /// The payment with which this DCC info is associated
        public var paymentRef: CLVModels.Base.Reference?
        /// The credit (manual refund) with which this DCC info is associated
        public var creditRef: CLVModels.Base.Reference?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case inquiryRateId
            case dccApplied
            case foreignCurrencyCode
            case foreignAmount
            case exchangeRate
            case marginRatePercentage
            case exchangeRateSourceName
            case exchangeRateSourceTimeStamp
            case paymentRef
            case creditRef
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.inquiryRateId = try rootContainer.decodeIfPresent(Int64.self, forKey: .inquiryRateId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dccApplied = try rootContainer.decodeIfPresent(Bool.self, forKey: .dccApplied)
            } catch {
                decodeError.append(error)
            }
            do {
                self.foreignCurrencyCode = try rootContainer.decodeIfPresent(String.self, forKey: .foreignCurrencyCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.foreignAmount = try rootContainer.decodeIfPresent(Int64.self, forKey: .foreignAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchangeRate = try rootContainer.decodeIfPresent(Double.self, forKey: .exchangeRate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.marginRatePercentage = try rootContainer.decodeIfPresent(String.self, forKey: .marginRatePercentage)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchangeRateSourceName = try rootContainer.decodeIfPresent(String.self, forKey: .exchangeRateSourceName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exchangeRateSourceTimeStamp = try rootContainer.decodeIfPresent(String.self, forKey: .exchangeRateSourceTimeStamp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.paymentRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .paymentRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.creditRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .creditRef)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (inquiryRateId != nil) { try container.encode(inquiryRateId, forKey: .inquiryRateId) }
            if (dccApplied != nil) { try container.encode(dccApplied, forKey: .dccApplied) }
            if (foreignCurrencyCode != nil) { try container.encode(foreignCurrencyCode, forKey: .foreignCurrencyCode) }
            if (foreignAmount != nil) { try container.encode(foreignAmount, forKey: .foreignAmount) }
            if (exchangeRate != nil) { try container.encode(exchangeRate, forKey: .exchangeRate) }
            if (marginRatePercentage != nil) { try container.encode(marginRatePercentage, forKey: .marginRatePercentage) }
            if (exchangeRateSourceName != nil) { try container.encode(exchangeRateSourceName, forKey: .exchangeRateSourceName) }
            if (exchangeRateSourceTimeStamp != nil) { try container.encode(exchangeRateSourceTimeStamp, forKey: .exchangeRateSourceTimeStamp) }
            if (paymentRef != nil) { try container.encode(paymentRef, forKey: .paymentRef) }
            if (creditRef != nil) { try container.encode(creditRef, forKey: .creditRef) }
        }
    }

}