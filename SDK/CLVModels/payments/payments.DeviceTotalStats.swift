/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class DeviceTotalStats: Codable {

        /// Device ID corresponding to these stats
        public var deviceId: Int64?
        /// Device serial number corresponding to these stats
        public var deviceSerial: String?
        /// Device name corresponding to these stats
        public var deviceName: String?
        /// Terminal ID of Device corresponding to these stats
        public var terminalId: String?
        public var sales: CLVModels.Payments.BatchTotalType?
        public var refunds: CLVModels.Payments.BatchTotalType?
        public var net: CLVModels.Payments.BatchTotalType?
        public var giftCardLoads: CLVModels.Payments.BatchTotalType?
        public var giftCardCashOuts: CLVModels.Payments.BatchTotalType?
        public var tax: CLVModels.Payments.BatchTotalType?
        public var tips: CLVModels.Payments.BatchTotalType?
        public var cardTotals: [CLVModels.Payments.BatchCardTotal]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case deviceId
            case deviceSerial
            case deviceName
            case terminalId
            case sales
            case refunds
            case net
            case giftCardLoads
            case giftCardCashOuts
            case tax
            case tips
            case cardTotals
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.deviceId = try rootContainer.decodeIfPresent(Int64.self, forKey: .deviceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deviceSerial = try rootContainer.decodeIfPresent(String.self, forKey: .deviceSerial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deviceName = try rootContainer.decodeIfPresent(String.self, forKey: .deviceName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.terminalId = try rootContainer.decodeIfPresent(String.self, forKey: .terminalId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sales = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .sales)
            } catch {
                decodeError.append(error)
            }
            do {
                self.refunds = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .refunds)
            } catch {
                decodeError.append(error)
            }
            do {
                self.net = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .net)
            } catch {
                decodeError.append(error)
            }
            do {
                self.giftCardLoads = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .giftCardLoads)
            } catch {
                decodeError.append(error)
            }
            do {
                self.giftCardCashOuts = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .giftCardCashOuts)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tax = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .tax)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tips = try rootContainer.decodeIfPresent(CLVModels.Payments.BatchTotalType.self, forKey: .tips)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.cardTotals)) {
                do {
                    let cardTotalsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .cardTotals)
                    self.cardTotals = try cardTotalsContainer.decodeIfPresent([CLVModels.Payments.BatchCardTotal].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (deviceId != nil) { try container.encode(deviceId, forKey: .deviceId) }
            if (deviceSerial != nil) { try container.encode(deviceSerial, forKey: .deviceSerial) }
            if (deviceName != nil) { try container.encode(deviceName, forKey: .deviceName) }
            if (terminalId != nil) { try container.encode(terminalId, forKey: .terminalId) }
            if (sales != nil) { try container.encode(sales, forKey: .sales) }
            if (refunds != nil) { try container.encode(refunds, forKey: .refunds) }
            if (net != nil) { try container.encode(net, forKey: .net) }
            if (giftCardLoads != nil) { try container.encode(giftCardLoads, forKey: .giftCardLoads) }
            if (giftCardCashOuts != nil) { try container.encode(giftCardCashOuts, forKey: .giftCardCashOuts) }
            if (tax != nil) { try container.encode(tax, forKey: .tax) }
            if (tips != nil) { try container.encode(tips, forKey: .tips) }
            if (cardTotals != nil) { try container.encode(cardTotals, forKey: .cardTotals) }
        }
    }

}