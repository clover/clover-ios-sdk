/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Payments {

    public class Payment: Codable {

        /// Unique identifier
        public var id: String?
        /// The order with which the payment is associated
        public var order: CLVModels.Base.Reference?
        /// Device which processed the transaction for this payment, a 128-bit UUID, not a normal base-13 Clover ID.
        public var device: CLVModels.Variant?
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var tender: CLVModels.Base.Tender?
        /// Total amount paid
        public var amount: Int64?
        /// Amount paid in tips
        public var tipAmount: CLVModels.Variant?
        /// Amount paid in tax
        public var taxAmount: CLVModels.Variant?
        /// Amount given back in a cash back transaction
        public var cashbackAmount: CLVModels.Variant?
        /// Amount of cash given by the customer
        public var cashTendered: CLVModels.Variant?
        public var externalPaymentId: String?
        /// The employee who processed the payment
        public var employee: CLVModels.Base.Reference?
        /// Time payment was recorded on server
        public var createdTime: Date?
        public var clientCreatedTime: Date?
        /// Last modified time of the payment
        public var modifiedTime: Date?
        public var offline: Bool?
        public var result: CLVModels.Payments.Result?
        /// Information about the card used for credit/debit card payments
        public var cardTransaction: CLVModels.Payments.CardTransaction?
        /// Amount record as a service charge
        public var serviceCharge: CLVModels.Payments.ServiceChargeAmount?
        public var attributes: [String:String]?
        public var additionalCharges: [CLVModels.Payments.AdditionalChargeAmount]?
        public var taxRates: [CLVModels.Payments.PaymentTaxRate]?
        public var refunds: [CLVModels.Payments.Refund]?
        public var note: String?
        public var lineItemPayments: [CLVModels.Payments.LineItemPayment]?
        /// Authorization which this payment is associated to (opening or closing payment) if one exists
        public var authorization: CLVModels.Base.Reference?
        /// If voided, the corresponding successful payment, and vice versa
        public var voidPaymentRef: CLVModels.Base.Reference?
        /// If voided, the reason why (when available)
        public var voidReason: CLVModels.Order.VoidReason?
        /// Dynamic Currency Conversion information
        public var dccInfo: CLVModels.Variant?
        /// Per transaction settings for the payment
        public var transactionSettings: CLVModels.Payments.TransactionSettings?
        /// German region-specific information
        public var germanInfo: CLVModels.Variant?
        /// Tracking information for the app that created this payment.
        public var appTracking: CLVModels.Variant?
        /// Information specific to cash advance transactions.
        public var cashAdvanceExtra: CLVModels.Variant?
        /// Transaction information
        public var transactionInfo: CLVModels.Variant?
        /// Information displayed to customer for storing electronic signatures
        public var signatureDisclaimer: CLVModels.Variant?
        /// The external reference id if associated with the payment
        public var externalReferenceId: CLVModels.Variant?
        public var merchant: CLVModels.Base.Reference?
        public var increments: [CLVModels.Payments.IncrementalAuthorization]?
        /// Purchase card level 2 data
        public var purchaseCardL2: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case order
            case device
            case tender
            case amount
            case tipAmount
            case taxAmount
            case cashbackAmount
            case cashTendered
            case externalPaymentId
            case employee
            case createdTime
            case clientCreatedTime
            case modifiedTime
            case offline
            case result
            case cardTransaction
            case serviceCharge
            case attributes
            case additionalCharges
            case taxRates
            case refunds
            case note
            case lineItemPayments
            case authorization
            case voidPaymentRef
            case voidReason
            case dccInfo
            case transactionSettings
            case germanInfo
            case appTracking
            case cashAdvanceExtra
            case transactionInfo
            case signatureDisclaimer
            case externalReferenceId
            case merchant
            case increments
            case purchaseCardL2
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.order = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .order)
            } catch {
                decodeError.append(error)
            }
            do {
                self.device = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .device)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tender = try rootContainer.decodeIfPresent(CLVModels.Base.Tender.self, forKey: .tender)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tipAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .taxAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashbackAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cashbackAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashTendered = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cashTendered)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalPaymentId = try rootContainer.decodeIfPresent(String.self, forKey: .externalPaymentId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employee = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .employee)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.clientCreatedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .clientCreatedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.modifiedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .modifiedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offline = try rootContainer.decodeIfPresent(Bool.self, forKey: .offline)
            } catch {
                decodeError.append(error)
            }
            do {
                self.result = try rootContainer.decodeIfPresent(CLVModels.Payments.Result.self, forKey: .result)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardTransaction = try rootContainer.decodeIfPresent(CLVModels.Payments.CardTransaction.self, forKey: .cardTransaction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceCharge = try rootContainer.decodeIfPresent(CLVModels.Payments.ServiceChargeAmount.self, forKey: .serviceCharge)
            } catch {
                decodeError.append(error)
            }
            do {
                self.attributes = try rootContainer.decodeIfPresent([String:String].self, forKey: .attributes)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.additionalCharges)) {
                do {
                    let additionalChargesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .additionalCharges)
                    self.additionalCharges = try additionalChargesContainer.decodeIfPresent([CLVModels.Payments.AdditionalChargeAmount].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.taxRates)) {
                do {
                    let taxRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxRates)
                    self.taxRates = try taxRatesContainer.decodeIfPresent([CLVModels.Payments.PaymentTaxRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.refunds)) {
                do {
                    let refundsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .refunds)
                    self.refunds = try refundsContainer.decodeIfPresent([CLVModels.Payments.Refund].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.note = try rootContainer.decodeIfPresent(String.self, forKey: .note)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.lineItemPayments)) {
                do {
                    let lineItemPaymentsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .lineItemPayments)
                    self.lineItemPayments = try lineItemPaymentsContainer.decodeIfPresent([CLVModels.Payments.LineItemPayment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.authorization = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .authorization)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voidPaymentRef = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .voidPaymentRef)
            } catch {
                decodeError.append(error)
            }
            do {
                self.voidReason = try rootContainer.decodeIfPresent(CLVModels.Order.VoidReason.self, forKey: .voidReason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dccInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .dccInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionSettings = try rootContainer.decodeIfPresent(CLVModels.Payments.TransactionSettings.self, forKey: .transactionSettings)
            } catch {
                decodeError.append(error)
            }
            do {
                self.germanInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .germanInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.appTracking = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .appTracking)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashAdvanceExtra = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cashAdvanceExtra)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionInfo = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .transactionInfo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.signatureDisclaimer = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .signatureDisclaimer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalReferenceId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .externalReferenceId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.increments)) {
                do {
                    let incrementsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .increments)
                    self.increments = try incrementsContainer.decodeIfPresent([CLVModels.Payments.IncrementalAuthorization].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.purchaseCardL2 = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .purchaseCardL2)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (order != nil) { try container.encode(order, forKey: .order) }
            if (device != nil) { try container.encode(device, forKey: .device) }
            if (tender != nil) { try container.encode(tender, forKey: .tender) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (tipAmount != nil) { try container.encode(tipAmount, forKey: .tipAmount) }
            if (taxAmount != nil) { try container.encode(taxAmount, forKey: .taxAmount) }
            if (cashbackAmount != nil) { try container.encode(cashbackAmount, forKey: .cashbackAmount) }
            if (cashTendered != nil) { try container.encode(cashTendered, forKey: .cashTendered) }
            if (externalPaymentId != nil) { try container.encode(externalPaymentId, forKey: .externalPaymentId) }
            if (employee != nil) { try container.encode(employee, forKey: .employee) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (clientCreatedTime != nil) { try container.encode(clientCreatedTime, forKey: .clientCreatedTime) }
            if (modifiedTime != nil) { try container.encode(modifiedTime, forKey: .modifiedTime) }
            if (offline != nil) { try container.encode(offline, forKey: .offline) }
            if (result != nil) { try container.encode(result, forKey: .result) }
            if (cardTransaction != nil) { try container.encode(cardTransaction, forKey: .cardTransaction) }
            if (serviceCharge != nil) { try container.encode(serviceCharge, forKey: .serviceCharge) }
            if (attributes != nil) { try container.encode(attributes, forKey: .attributes) }
            if (additionalCharges != nil) { try container.encode(additionalCharges, forKey: .additionalCharges) }
            if (taxRates != nil) { try container.encode(taxRates, forKey: .taxRates) }
            if (refunds != nil) { try container.encode(refunds, forKey: .refunds) }
            if (note != nil) { try container.encode(note, forKey: .note) }
            if (lineItemPayments != nil) { try container.encode(lineItemPayments, forKey: .lineItemPayments) }
            if (authorization != nil) { try container.encode(authorization, forKey: .authorization) }
            if (voidPaymentRef != nil) { try container.encode(voidPaymentRef, forKey: .voidPaymentRef) }
            if (voidReason != nil) { try container.encode(voidReason, forKey: .voidReason) }
            if (dccInfo != nil) { try container.encode(dccInfo, forKey: .dccInfo) }
            if (transactionSettings != nil) { try container.encode(transactionSettings, forKey: .transactionSettings) }
            if (germanInfo != nil) { try container.encode(germanInfo, forKey: .germanInfo) }
            if (appTracking != nil) { try container.encode(appTracking, forKey: .appTracking) }
            if (cashAdvanceExtra != nil) { try container.encode(cashAdvanceExtra, forKey: .cashAdvanceExtra) }
            if (transactionInfo != nil) { try container.encode(transactionInfo, forKey: .transactionInfo) }
            if (signatureDisclaimer != nil) { try container.encode(signatureDisclaimer, forKey: .signatureDisclaimer) }
            if (externalReferenceId != nil) { try container.encode(externalReferenceId, forKey: .externalReferenceId) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
            if (increments != nil) { try container.encode(increments, forKey: .increments) }
            if (purchaseCardL2 != nil) { try container.encode(purchaseCardL2, forKey: .purchaseCardL2) }
        }
    }

}