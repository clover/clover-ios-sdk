/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Employees {

    public class Employee: Codable {

        /// Unique identifier
        public var id: String?
        /// Full name of the employee
        public var name: CLVModels.Variant?
        /// Nickname of the employee (shows up on receipts)
        public var nickname: CLVModels.Variant?
        /// Custom ID of the employee
        public var customId: CLVModels.Variant?
        /// Email of the employee (optional)
        public var email: CLVModels.Variant?
        /// Returns true if this employee was sent an invite to activate their account
        public var inviteSent: CLVModels.Variant?
        /// Timestamp of when this employee claimed their account
        public var claimedTime: Date?
        /// Timestamp of when this employee was deleted
        public var deletedTime: Date?
        /// Employee PIN (hashed)
        public var pin: CLVModels.Variant?
        /// Employee PIN
        public var unhashedPin: CLVModels.Variant?
        /// Employee System Role
        public var role: CLVModels.Variant?
        public var roles: CLVModels.Variant?
        /// Returns true if this employee is the owner account for this merchant
        public var isOwner: CLVModels.Variant?
        /// This employee's shifts
        public var shifts: CLVModels.Variant?
        /// This employee's payments
        public var payments: CLVModels.Variant?
        /// This employee's orders
        public var orders: CLVModels.Variant?
        /// This employee's employee cards
        public var employeeCards: CLVModels.Variant?
        /// The merchant employing this employee
        public var merchant: CLVModels.Variant?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case nickname
            case customId
            case email
            case inviteSent
            case claimedTime
            case deletedTime
            case pin
            case unhashedPin
            case role
            case roles
            case isOwner
            case shifts
            case payments
            case orders
            case employeeCards
            case merchant
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.nickname = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .nickname)
            } catch {
                decodeError.append(error)
            }
            do {
                self.customId = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .customId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.email = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .email)
            } catch {
                decodeError.append(error)
            }
            do {
                self.inviteSent = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .inviteSent)
            } catch {
                decodeError.append(error)
            }
            do {
                self.claimedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .claimedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deletedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .deletedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pin = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .pin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.unhashedPin = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .unhashedPin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.role = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .role)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.roles)) {
                do {
                    let rolesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .roles)
                    self.roles = try rolesContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.isOwner = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .isOwner)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.shifts)) {
                do {
                    let shiftsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .shifts)
                    self.shifts = try shiftsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.payments)) {
                do {
                    let paymentsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .payments)
                    self.payments = try paymentsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.orders)) {
                do {
                    let ordersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .orders)
                    self.orders = try ordersContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.employeeCards)) {
                do {
                    let employeeCardsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .employeeCards)
                    self.employeeCards = try employeeCardsContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.merchant = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .merchant)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (nickname != nil) { try container.encode(nickname, forKey: .nickname) }
            if (customId != nil) { try container.encode(customId, forKey: .customId) }
            if (email != nil) { try container.encode(email, forKey: .email) }
            if (inviteSent != nil) { try container.encode(inviteSent, forKey: .inviteSent) }
            if (claimedTime != nil) { try container.encode(claimedTime, forKey: .claimedTime) }
            if (deletedTime != nil) { try container.encode(deletedTime, forKey: .deletedTime) }
            if (pin != nil) { try container.encode(pin, forKey: .pin) }
            if (unhashedPin != nil) { try container.encode(unhashedPin, forKey: .unhashedPin) }
            if (role != nil) { try container.encode(role, forKey: .role) }
            if (roles != nil) { try container.encode(roles, forKey: .roles) }
            if (isOwner != nil) { try container.encode(isOwner, forKey: .isOwner) }
            if (shifts != nil) { try container.encode(shifts, forKey: .shifts) }
            if (payments != nil) { try container.encode(payments, forKey: .payments) }
            if (orders != nil) { try container.encode(orders, forKey: .orders) }
            if (employeeCards != nil) { try container.encode(employeeCards, forKey: .employeeCards) }
            if (merchant != nil) { try container.encode(merchant, forKey: .merchant) }
        }
    }

}