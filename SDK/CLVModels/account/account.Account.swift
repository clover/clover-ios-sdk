/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Account {

    public class Account: Codable {

        public var id: String?
        public var name: String?
        public var email: String?
        /// The primary merchant
        public var primaryMerchant: CLVModels.Base.Reference?
        /// The primary developer
        public var primaryDeveloper: CLVModels.Base.Reference?
        /// The primary reseller
        public var primaryReseller: CLVModels.Base.Reference?
        /// The primary enterprise
        public var primaryEnterprise: CLVModels.Base.Reference?
        public var isActive: Bool?
        public var createdTime: Date?
        public var claimedTime: Date?
        public var lastLogin: Int64?
        public var inviteSent: Bool?
        public var status: String?
        public var role: CLVModels.Base.Reference?
        public var merchants: [CLVModels.Base.Reference]?
        public var developers: [CLVModels.Base.Reference]?
        public var resellers: [CLVModels.Base.Reference]?
        public var csrfToken: String?
        public var authFactors: [CLVModels.Base.Reference]?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case name
            case email
            case primaryMerchant
            case primaryDeveloper
            case primaryReseller
            case primaryEnterprise
            case isActive
            case createdTime
            case claimedTime
            case lastLogin
            case inviteSent
            case status
            case role
            case merchants
            case developers
            case resellers
            case csrfToken
            case authFactors
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.name = try rootContainer.decodeIfPresent(String.self, forKey: .name)
            } catch {
                decodeError.append(error)
            }
            do {
                self.email = try rootContainer.decodeIfPresent(String.self, forKey: .email)
            } catch {
                decodeError.append(error)
            }
            do {
                self.primaryMerchant = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .primaryMerchant)
            } catch {
                decodeError.append(error)
            }
            do {
                self.primaryDeveloper = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .primaryDeveloper)
            } catch {
                decodeError.append(error)
            }
            do {
                self.primaryReseller = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .primaryReseller)
            } catch {
                decodeError.append(error)
            }
            do {
                self.primaryEnterprise = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .primaryEnterprise)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isActive = try rootContainer.decodeIfPresent(Bool.self, forKey: .isActive)
            } catch {
                decodeError.append(error)
            }
            do {
                self.createdTime = try rootContainer.decodeIfPresent(Date.self, forKey: .createdTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.claimedTime = try rootContainer.decodeIfPresent(Date.self, forKey: .claimedTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.lastLogin = try rootContainer.decodeIfPresent(Int64.self, forKey: .lastLogin)
            } catch {
                decodeError.append(error)
            }
            do {
                self.inviteSent = try rootContainer.decodeIfPresent(Bool.self, forKey: .inviteSent)
            } catch {
                decodeError.append(error)
            }
            do {
                self.status = try rootContainer.decodeIfPresent(String.self, forKey: .status)
            } catch {
                decodeError.append(error)
            }
            do {
                self.role = try rootContainer.decodeIfPresent(CLVModels.Base.Reference.self, forKey: .role)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.merchants)) {
                do {
                    let merchantsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .merchants)
                    self.merchants = try merchantsContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.developers)) {
                do {
                    let developersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .developers)
                    self.developers = try developersContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.resellers)) {
                do {
                    let resellersContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .resellers)
                    self.resellers = try resellersContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.csrfToken = try rootContainer.decodeIfPresent(String.self, forKey: .csrfToken)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.authFactors)) {
                do {
                    let authFactorsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .authFactors)
                    self.authFactors = try authFactorsContainer.decodeIfPresent([CLVModels.Base.Reference].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (name != nil) { try container.encode(name, forKey: .name) }
            if (email != nil) { try container.encode(email, forKey: .email) }
            if (primaryMerchant != nil) { try container.encode(primaryMerchant, forKey: .primaryMerchant) }
            if (primaryDeveloper != nil) { try container.encode(primaryDeveloper, forKey: .primaryDeveloper) }
            if (primaryReseller != nil) { try container.encode(primaryReseller, forKey: .primaryReseller) }
            if (primaryEnterprise != nil) { try container.encode(primaryEnterprise, forKey: .primaryEnterprise) }
            if (isActive != nil) { try container.encode(isActive, forKey: .isActive) }
            if (createdTime != nil) { try container.encode(createdTime, forKey: .createdTime) }
            if (claimedTime != nil) { try container.encode(claimedTime, forKey: .claimedTime) }
            if (lastLogin != nil) { try container.encode(lastLogin, forKey: .lastLogin) }
            if (inviteSent != nil) { try container.encode(inviteSent, forKey: .inviteSent) }
            if (status != nil) { try container.encode(status, forKey: .status) }
            if (role != nil) { try container.encode(role, forKey: .role) }
            if (merchants != nil) { try container.encode(merchants, forKey: .merchants) }
            if (developers != nil) { try container.encode(developers, forKey: .developers) }
            if (resellers != nil) { try container.encode(resellers, forKey: .resellers) }
            if (csrfToken != nil) { try container.encode(csrfToken, forKey: .csrfToken) }
            if (authFactors != nil) { try container.encode(authFactors, forKey: .authFactors) }
        }
    }

}