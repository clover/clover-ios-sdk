/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Base {

    public class Challenge: Codable {

        /// The type of the challenge.
        public var type_: CLVModels.Base.ChallengeType?
        /// If the challenge is not accepted, then this reason can be used when responding.  The response could be an explicit void of the payment, or some other message, that may or may not use this reason.
        public var reason: CLVModels.Order.VoidReason?
        /// A default message that indicates what the challenge is in a user friendly format.
        public var message: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case type
            case reason
            case message
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Base.ChallengeType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.reason = try rootContainer.decodeIfPresent(CLVModels.Order.VoidReason.self, forKey: .reason)
            } catch {
                decodeError.append(error)
            }
            do {
                self.message = try rootContainer.decodeIfPresent(String.self, forKey: .message)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (reason != nil) { try container.encode(reason, forKey: .reason) }
            if (message != nil) { try container.encode(message, forKey: .message) }
        }
    }

}