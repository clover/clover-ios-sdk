/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Base {

    public class Tender: Codable {

        /// Unique identifier
        public var id: String?
        /// If this merchant tender is editable
        public var editable: Bool?
        /// Label Key
        public var labelKey: String?
        /// Label Key
        public var label: String?
        /// If this tender opens the cash drawer
        public var opensCashDrawer: Bool?
        /// Allow tipping on payment from tender
        public var supportsTipping: Bool?
        /// If this merchant tender is enabled
        public var enabled: Bool?
        /// If this merchant tender is visible
        public var visible: Bool?
        /// Label Key
        public var instructions: String?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case editable
            case labelKey
            case label
            case opensCashDrawer
            case supportsTipping
            case enabled
            case visible
            case instructions
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.editable = try rootContainer.decodeIfPresent(Bool.self, forKey: .editable)
            } catch {
                decodeError.append(error)
            }
            do {
                self.labelKey = try rootContainer.decodeIfPresent(String.self, forKey: .labelKey)
            } catch {
                decodeError.append(error)
            }
            do {
                self.label = try rootContainer.decodeIfPresent(String.self, forKey: .label)
            } catch {
                decodeError.append(error)
            }
            do {
                self.opensCashDrawer = try rootContainer.decodeIfPresent(Bool.self, forKey: .opensCashDrawer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.supportsTipping = try rootContainer.decodeIfPresent(Bool.self, forKey: .supportsTipping)
            } catch {
                decodeError.append(error)
            }
            do {
                self.enabled = try rootContainer.decodeIfPresent(Bool.self, forKey: .enabled)
            } catch {
                decodeError.append(error)
            }
            do {
                self.visible = try rootContainer.decodeIfPresent(Bool.self, forKey: .visible)
            } catch {
                decodeError.append(error)
            }
            do {
                self.instructions = try rootContainer.decodeIfPresent(String.self, forKey: .instructions)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (editable != nil) { try container.encode(editable, forKey: .editable) }
            if (labelKey != nil) { try container.encode(labelKey, forKey: .labelKey) }
            if (label != nil) { try container.encode(label, forKey: .label) }
            if (opensCashDrawer != nil) { try container.encode(opensCashDrawer, forKey: .opensCashDrawer) }
            if (supportsTipping != nil) { try container.encode(supportsTipping, forKey: .supportsTipping) }
            if (enabled != nil) { try container.encode(enabled, forKey: .enabled) }
            if (visible != nil) { try container.encode(visible, forKey: .visible) }
            if (instructions != nil) { try container.encode(instructions, forKey: .instructions) }
        }
    }

}