/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Remotemessage {

    public class RemoteMessage: Codable {

        /// Identifier for the message
        public var id: String?
        public var type_: CLVModels.Remotemessage.RemoteMessageType?
        /// The package name of the sending Clover api
        public var packageName: String?
        /// The name of the business message being sent
        public var method: CLVModels.Remotemessage.Method?
        /// The payload message being sent.  Interpreted based on the method.
        public var payload: String?
        /// The identifier for the source SDK.  This identifies the connector.
        public var remoteSourceSDK: String?
        /// The identifier for the sending application.  This identifies the app.
        public var remoteApplicationID: String?
        /// The Remote Message version.
        public var version_: Int32?
        /// The order of fragments when message is split for large attachments.
        public var fragmentIndex: Int32?
        /// If this is the final fragment in a series.
        public var lastFragment: Bool?
        /// The type of encoding used for the attachment, typically BASE64.
        public var attachmentEncoding: String?
        /// The encoded attachment.
        public var attachment: String?
        /// The attachment URI.
        public var attachmentUri: String?
        /// The Remote Pay Compatibility version, automatically set.
        public var remotePayCompatibilityVersion: Int32?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case type
            case packageName
            case method
            case payload
            case remoteSourceSDK
            case remoteApplicationID
            case version
            case fragmentIndex
            case lastFragment
            case attachmentEncoding
            case attachment
            case attachmentUri
            case remotePayCompatibilityVersion
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.type_ = try rootContainer.decodeIfPresent(CLVModels.Remotemessage.RemoteMessageType.self, forKey: .type)
            } catch {
                decodeError.append(error)
            }
            do {
                self.packageName = try rootContainer.decodeIfPresent(String.self, forKey: .packageName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.method = try rootContainer.decodeIfPresent(CLVModels.Remotemessage.Method.self, forKey: .method)
            } catch {
                decodeError.append(error)
            }
            do {
                self.payload = try rootContainer.decodeIfPresent(String.self, forKey: .payload)
            } catch {
                decodeError.append(error)
            }
            do {
                self.remoteSourceSDK = try rootContainer.decodeIfPresent(String.self, forKey: .remoteSourceSDK)
            } catch {
                decodeError.append(error)
            }
            do {
                self.remoteApplicationID = try rootContainer.decodeIfPresent(String.self, forKey: .remoteApplicationID)
            } catch {
                decodeError.append(error)
            }
            do {
                self.version_ = try rootContainer.decodeIfPresent(Int32.self, forKey: .version)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fragmentIndex = try rootContainer.decodeIfPresent(Int32.self, forKey: .fragmentIndex)
            } catch {
                decodeError.append(error)
            }
            do {
                self.lastFragment = try rootContainer.decodeIfPresent(Bool.self, forKey: .lastFragment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.attachmentEncoding = try rootContainer.decodeIfPresent(String.self, forKey: .attachmentEncoding)
            } catch {
                decodeError.append(error)
            }
            do {
                self.attachment = try rootContainer.decodeIfPresent(String.self, forKey: .attachment)
            } catch {
                decodeError.append(error)
            }
            do {
                self.attachmentUri = try rootContainer.decodeIfPresent(String.self, forKey: .attachmentUri)
            } catch {
                decodeError.append(error)
            }
            do {
                self.remotePayCompatibilityVersion = try rootContainer.decodeIfPresent(Int32.self, forKey: .remotePayCompatibilityVersion)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (type_ != nil) { try container.encode(type_, forKey: .type) }
            if (packageName != nil) { try container.encode(packageName, forKey: .packageName) }
            if (method != nil) { try container.encode(method, forKey: .method) }
            if (payload != nil) { try container.encode(payload, forKey: .payload) }
            if (remoteSourceSDK != nil) { try container.encode(remoteSourceSDK, forKey: .remoteSourceSDK) }
            if (remoteApplicationID != nil) { try container.encode(remoteApplicationID, forKey: .remoteApplicationID) }
            if (version_ != nil) { try container.encode(version_, forKey: .version) }
            if (fragmentIndex != nil) { try container.encode(fragmentIndex, forKey: .fragmentIndex) }
            if (lastFragment != nil) { try container.encode(lastFragment, forKey: .lastFragment) }
            if (attachmentEncoding != nil) { try container.encode(attachmentEncoding, forKey: .attachmentEncoding) }
            if (attachment != nil) { try container.encode(attachment, forKey: .attachment) }
            if (attachmentUri != nil) { try container.encode(attachmentUri, forKey: .attachmentUri) }
            if (remotePayCompatibilityVersion != nil) { try container.encode(remotePayCompatibilityVersion, forKey: .remotePayCompatibilityVersion) }
        }
    }

}