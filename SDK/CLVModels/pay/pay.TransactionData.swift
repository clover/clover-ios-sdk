/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Pay {

    public class TransactionData: Codable {

        public var txResult: CLVModels.Pay.TxResult?
        public var txError: CLVModels.Pay.ErrorCode?
        public var amount: Double?
        public var tipAmount: Double?
        public var cashBackAmount: Double?
        public var errorCode: String?
        public var errorText: String?
        public var transactionDate: String?
        public var transactionTime: String?
        public var msrContainer: String?
        public var msrMaskedTrack1: String?
        public var msrMaskedTrack2: String?
        public var maskedManualPan: String?
        public var sredContainer: String?
        public var sred: String?
        public var ksn: String?
        public var transArmorContainer: String?
        public var transArmorKey: String?
        public var transArmorKeyId: String?
        public var transArmorEncryptedTrack1: String?
        public var transArmorEncryptedTrack2: String?
        public var transArmorEncryptedEmvTag57: String?
        public var transArmorEncryptedEmvTag5A: String?
        public var transArmorEncryptedManualKeyedData: String?
        public var iccContainer: String?
        public var iccApplicationInterchangeProfile: String?
        public var iccMaskedEmv57: String?
        public var iccMaskedEmv5A: String?
        public var iccApplicationPanSequenceNumber: String?
        public var iccApplicationExpirationDate: String?
        public var iccApplicationEffectiveDate: String?
        public var iccAmountAuthorized: String?
        public var iccAmountOther: String?
        public var iccTransactionCurrencyCode: String?
        public var iccTransactionCurrencyExponent: String?
        public var iccApplicationUsageControl: String?
        public var iccIssuerActionCodeDefault: String?
        public var iccIssuerActionCodeDenial: String?
        public var iccIssuerActionCodeOnline: String?
        public var iccApplicationLabel: String?
        public var iccApplicationCryptogram: String?
        public var iccApplicationIdentifierCard: String?
        public var iccApplicationIdentifierTerminal: String?
        public var iccApplicationTransactionCounter: String?
        public var iccApplicationVersionNumber: String?
        public var iccCryptogramInformationData: String?
        public var iccCvmResults: String?
        public var iccInterfaceDeviceSerialNumber: String?
        public var iccIssuerApplicationData: String?
        public var iccPosEntryModeCode: String?
        public var iccTerminalCapabilities: String?
        public var iccTerminalCountryCode: String?
        public var iccTerminalType: String?
        public var iccTvr: String?
        public var iccTransactionDate: String?
        public var iccTsi: String?
        public var iccTransactionType: String?
        public var iccUnpredictableNumber: String?
        public var iccTransactionTime: String?
        public var iccAdditionalTerminalCapabilities: String?
        public var iccTransactionCategoryCode: String?
        public var iccIssuerApplicationPreferredName: String?
        public var iccCardholderName: String?
        public var iccIssuerCodeTableIndex: String?
        public var iccIssuerScripts: String?
        public var iccIssuerScriptResults: String?
        public var debugTrack2EquivalentData: String?
        public var debugApplicationPan: String?
        public var debugAmountAuthorizedBinary: String?
        public var debugAmountOtherBinary: String?
        public var debugTransactionStatusInformation: String?
        public var debugPlainTrack1: String?
        public var debugPlainTrack2: String?
        public var schemePunATC: String?
        public var schemeThirdPartyData: String?
        public var schemeMerchantCustomData: String?
        public var schemeTerminalEntryCapability: String?
        public var pinBlockContainer: String?
        public var pinBlock: String?
        public var pinBlockKsn: String?
        public var mac: String?
        public var macKsn: String?
        public var gwContainer: String?
        public var gwIssuerAuthenticationData: String?
        public var gwIssuerScriptTemplate1: String?
        public var gwIssuerScriptTemplate2: String?
        public var gwIssuerAuthorizationResponseCode: String?
        public var gwMessageControlField: String?
        public var gwTxResult: CLVModels.Pay.GwTxResult?
        public var cvmResult: CLVModels.Payments.CvmResult?
        public var serviceCode1: CLVModels.Pay.ServiceCode1?
        public var serviceCode2: CLVModels.Pay.ServiceCode2?
        public var serviceCode3: CLVModels.Pay.ServiceCode3?
        public var offlineApprovalAuthCode: String?
        public var availableOfflineSpendingAmount: Double?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case txResult
            case txError
            case amount
            case tipAmount
            case cashBackAmount
            case errorCode
            case errorText
            case transactionDate
            case transactionTime
            case msrContainer
            case msrMaskedTrack1
            case msrMaskedTrack2
            case maskedManualPan
            case sredContainer
            case sred
            case ksn
            case transArmorContainer
            case transArmorKey
            case transArmorKeyId
            case transArmorEncryptedTrack1
            case transArmorEncryptedTrack2
            case transArmorEncryptedEmvTag57
            case transArmorEncryptedEmvTag5A
            case transArmorEncryptedManualKeyedData
            case iccContainer
            case iccApplicationInterchangeProfile
            case iccMaskedEmv57
            case iccMaskedEmv5A
            case iccApplicationPanSequenceNumber
            case iccApplicationExpirationDate
            case iccApplicationEffectiveDate
            case iccAmountAuthorized
            case iccAmountOther
            case iccTransactionCurrencyCode
            case iccTransactionCurrencyExponent
            case iccApplicationUsageControl
            case iccIssuerActionCodeDefault
            case iccIssuerActionCodeDenial
            case iccIssuerActionCodeOnline
            case iccApplicationLabel
            case iccApplicationCryptogram
            case iccApplicationIdentifierCard
            case iccApplicationIdentifierTerminal
            case iccApplicationTransactionCounter
            case iccApplicationVersionNumber
            case iccCryptogramInformationData
            case iccCvmResults
            case iccInterfaceDeviceSerialNumber
            case iccIssuerApplicationData
            case iccPosEntryModeCode
            case iccTerminalCapabilities
            case iccTerminalCountryCode
            case iccTerminalType
            case iccTvr
            case iccTransactionDate
            case iccTsi
            case iccTransactionType
            case iccUnpredictableNumber
            case iccTransactionTime
            case iccAdditionalTerminalCapabilities
            case iccTransactionCategoryCode
            case iccIssuerApplicationPreferredName
            case iccCardholderName
            case iccIssuerCodeTableIndex
            case iccIssuerScripts
            case iccIssuerScriptResults
            case debugTrack2EquivalentData
            case debugApplicationPan
            case debugAmountAuthorizedBinary
            case debugAmountOtherBinary
            case debugTransactionStatusInformation
            case debugPlainTrack1
            case debugPlainTrack2
            case schemePunATC
            case schemeThirdPartyData
            case schemeMerchantCustomData
            case schemeTerminalEntryCapability
            case pinBlockContainer
            case pinBlock
            case pinBlockKsn
            case mac
            case macKsn
            case gwContainer
            case gwIssuerAuthenticationData
            case gwIssuerScriptTemplate1
            case gwIssuerScriptTemplate2
            case gwIssuerAuthorizationResponseCode
            case gwMessageControlField
            case gwTxResult
            case cvmResult
            case serviceCode1
            case serviceCode2
            case serviceCode3
            case offlineApprovalAuthCode
            case availableOfflineSpendingAmount
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.txResult = try rootContainer.decodeIfPresent(CLVModels.Pay.TxResult.self, forKey: .txResult)
            } catch {
                decodeError.append(error)
            }
            do {
                self.txError = try rootContainer.decodeIfPresent(CLVModels.Pay.ErrorCode.self, forKey: .txError)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Double.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipAmount = try rootContainer.decodeIfPresent(Double.self, forKey: .tipAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashBackAmount = try rootContainer.decodeIfPresent(Double.self, forKey: .cashBackAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.errorCode = try rootContainer.decodeIfPresent(String.self, forKey: .errorCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.errorText = try rootContainer.decodeIfPresent(String.self, forKey: .errorText)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionDate = try rootContainer.decodeIfPresent(String.self, forKey: .transactionDate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionTime = try rootContainer.decodeIfPresent(String.self, forKey: .transactionTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.msrContainer = try rootContainer.decodeIfPresent(String.self, forKey: .msrContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.msrMaskedTrack1 = try rootContainer.decodeIfPresent(String.self, forKey: .msrMaskedTrack1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.msrMaskedTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .msrMaskedTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedManualPan = try rootContainer.decodeIfPresent(String.self, forKey: .maskedManualPan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sredContainer = try rootContainer.decodeIfPresent(String.self, forKey: .sredContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.sred = try rootContainer.decodeIfPresent(String.self, forKey: .sred)
            } catch {
                decodeError.append(error)
            }
            do {
                self.ksn = try rootContainer.decodeIfPresent(String.self, forKey: .ksn)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorContainer = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorKey = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorKey)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorKeyId = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorKeyId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorEncryptedTrack1 = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorEncryptedTrack1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorEncryptedTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorEncryptedTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorEncryptedEmvTag57 = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorEncryptedEmvTag57)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorEncryptedEmvTag5A = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorEncryptedEmvTag5A)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transArmorEncryptedManualKeyedData = try rootContainer.decodeIfPresent(String.self, forKey: .transArmorEncryptedManualKeyedData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccContainer = try rootContainer.decodeIfPresent(String.self, forKey: .iccContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationInterchangeProfile = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationInterchangeProfile)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccMaskedEmv57 = try rootContainer.decodeIfPresent(String.self, forKey: .iccMaskedEmv57)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccMaskedEmv5A = try rootContainer.decodeIfPresent(String.self, forKey: .iccMaskedEmv5A)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationPanSequenceNumber = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationPanSequenceNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationExpirationDate = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationExpirationDate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationEffectiveDate = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationEffectiveDate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccAmountAuthorized = try rootContainer.decodeIfPresent(String.self, forKey: .iccAmountAuthorized)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccAmountOther = try rootContainer.decodeIfPresent(String.self, forKey: .iccAmountOther)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionCurrencyCode = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionCurrencyCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionCurrencyExponent = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionCurrencyExponent)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationUsageControl = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationUsageControl)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerActionCodeDefault = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerActionCodeDefault)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerActionCodeDenial = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerActionCodeDenial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerActionCodeOnline = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerActionCodeOnline)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationLabel = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationLabel)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationCryptogram = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationCryptogram)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationIdentifierCard = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationIdentifierCard)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationIdentifierTerminal = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationIdentifierTerminal)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationTransactionCounter = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationTransactionCounter)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccApplicationVersionNumber = try rootContainer.decodeIfPresent(String.self, forKey: .iccApplicationVersionNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccCryptogramInformationData = try rootContainer.decodeIfPresent(String.self, forKey: .iccCryptogramInformationData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccCvmResults = try rootContainer.decodeIfPresent(String.self, forKey: .iccCvmResults)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccInterfaceDeviceSerialNumber = try rootContainer.decodeIfPresent(String.self, forKey: .iccInterfaceDeviceSerialNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerApplicationData = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerApplicationData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccPosEntryModeCode = try rootContainer.decodeIfPresent(String.self, forKey: .iccPosEntryModeCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTerminalCapabilities = try rootContainer.decodeIfPresent(String.self, forKey: .iccTerminalCapabilities)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTerminalCountryCode = try rootContainer.decodeIfPresent(String.self, forKey: .iccTerminalCountryCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTerminalType = try rootContainer.decodeIfPresent(String.self, forKey: .iccTerminalType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTvr = try rootContainer.decodeIfPresent(String.self, forKey: .iccTvr)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionDate = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionDate)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTsi = try rootContainer.decodeIfPresent(String.self, forKey: .iccTsi)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionType = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccUnpredictableNumber = try rootContainer.decodeIfPresent(String.self, forKey: .iccUnpredictableNumber)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionTime = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionTime)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccAdditionalTerminalCapabilities = try rootContainer.decodeIfPresent(String.self, forKey: .iccAdditionalTerminalCapabilities)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccTransactionCategoryCode = try rootContainer.decodeIfPresent(String.self, forKey: .iccTransactionCategoryCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerApplicationPreferredName = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerApplicationPreferredName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccCardholderName = try rootContainer.decodeIfPresent(String.self, forKey: .iccCardholderName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerCodeTableIndex = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerCodeTableIndex)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerScripts = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerScripts)
            } catch {
                decodeError.append(error)
            }
            do {
                self.iccIssuerScriptResults = try rootContainer.decodeIfPresent(String.self, forKey: .iccIssuerScriptResults)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugTrack2EquivalentData = try rootContainer.decodeIfPresent(String.self, forKey: .debugTrack2EquivalentData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugApplicationPan = try rootContainer.decodeIfPresent(String.self, forKey: .debugApplicationPan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugAmountAuthorizedBinary = try rootContainer.decodeIfPresent(String.self, forKey: .debugAmountAuthorizedBinary)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugAmountOtherBinary = try rootContainer.decodeIfPresent(String.self, forKey: .debugAmountOtherBinary)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugTransactionStatusInformation = try rootContainer.decodeIfPresent(String.self, forKey: .debugTransactionStatusInformation)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugPlainTrack1 = try rootContainer.decodeIfPresent(String.self, forKey: .debugPlainTrack1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.debugPlainTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .debugPlainTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.schemePunATC = try rootContainer.decodeIfPresent(String.self, forKey: .schemePunATC)
            } catch {
                decodeError.append(error)
            }
            do {
                self.schemeThirdPartyData = try rootContainer.decodeIfPresent(String.self, forKey: .schemeThirdPartyData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.schemeMerchantCustomData = try rootContainer.decodeIfPresent(String.self, forKey: .schemeMerchantCustomData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.schemeTerminalEntryCapability = try rootContainer.decodeIfPresent(String.self, forKey: .schemeTerminalEntryCapability)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pinBlockContainer = try rootContainer.decodeIfPresent(String.self, forKey: .pinBlockContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pinBlock = try rootContainer.decodeIfPresent(String.self, forKey: .pinBlock)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pinBlockKsn = try rootContainer.decodeIfPresent(String.self, forKey: .pinBlockKsn)
            } catch {
                decodeError.append(error)
            }
            do {
                self.mac = try rootContainer.decodeIfPresent(String.self, forKey: .mac)
            } catch {
                decodeError.append(error)
            }
            do {
                self.macKsn = try rootContainer.decodeIfPresent(String.self, forKey: .macKsn)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwContainer = try rootContainer.decodeIfPresent(String.self, forKey: .gwContainer)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwIssuerAuthenticationData = try rootContainer.decodeIfPresent(String.self, forKey: .gwIssuerAuthenticationData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwIssuerScriptTemplate1 = try rootContainer.decodeIfPresent(String.self, forKey: .gwIssuerScriptTemplate1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwIssuerScriptTemplate2 = try rootContainer.decodeIfPresent(String.self, forKey: .gwIssuerScriptTemplate2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwIssuerAuthorizationResponseCode = try rootContainer.decodeIfPresent(String.self, forKey: .gwIssuerAuthorizationResponseCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwMessageControlField = try rootContainer.decodeIfPresent(String.self, forKey: .gwMessageControlField)
            } catch {
                decodeError.append(error)
            }
            do {
                self.gwTxResult = try rootContainer.decodeIfPresent(CLVModels.Pay.GwTxResult.self, forKey: .gwTxResult)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cvmResult = try rootContainer.decodeIfPresent(CLVModels.Payments.CvmResult.self, forKey: .cvmResult)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceCode1 = try rootContainer.decodeIfPresent(CLVModels.Pay.ServiceCode1.self, forKey: .serviceCode1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceCode2 = try rootContainer.decodeIfPresent(CLVModels.Pay.ServiceCode2.self, forKey: .serviceCode2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceCode3 = try rootContainer.decodeIfPresent(CLVModels.Pay.ServiceCode3.self, forKey: .serviceCode3)
            } catch {
                decodeError.append(error)
            }
            do {
                self.offlineApprovalAuthCode = try rootContainer.decodeIfPresent(String.self, forKey: .offlineApprovalAuthCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.availableOfflineSpendingAmount = try rootContainer.decodeIfPresent(Double.self, forKey: .availableOfflineSpendingAmount)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (txResult != nil) { try container.encode(txResult, forKey: .txResult) }
            if (txError != nil) { try container.encode(txError, forKey: .txError) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (tipAmount != nil) { try container.encode(tipAmount, forKey: .tipAmount) }
            if (cashBackAmount != nil) { try container.encode(cashBackAmount, forKey: .cashBackAmount) }
            if (errorCode != nil) { try container.encode(errorCode, forKey: .errorCode) }
            if (errorText != nil) { try container.encode(errorText, forKey: .errorText) }
            if (transactionDate != nil) { try container.encode(transactionDate, forKey: .transactionDate) }
            if (transactionTime != nil) { try container.encode(transactionTime, forKey: .transactionTime) }
            if (msrContainer != nil) { try container.encode(msrContainer, forKey: .msrContainer) }
            if (msrMaskedTrack1 != nil) { try container.encode(msrMaskedTrack1, forKey: .msrMaskedTrack1) }
            if (msrMaskedTrack2 != nil) { try container.encode(msrMaskedTrack2, forKey: .msrMaskedTrack2) }
            if (maskedManualPan != nil) { try container.encode(maskedManualPan, forKey: .maskedManualPan) }
            if (sredContainer != nil) { try container.encode(sredContainer, forKey: .sredContainer) }
            if (sred != nil) { try container.encode(sred, forKey: .sred) }
            if (ksn != nil) { try container.encode(ksn, forKey: .ksn) }
            if (transArmorContainer != nil) { try container.encode(transArmorContainer, forKey: .transArmorContainer) }
            if (transArmorKey != nil) { try container.encode(transArmorKey, forKey: .transArmorKey) }
            if (transArmorKeyId != nil) { try container.encode(transArmorKeyId, forKey: .transArmorKeyId) }
            if (transArmorEncryptedTrack1 != nil) { try container.encode(transArmorEncryptedTrack1, forKey: .transArmorEncryptedTrack1) }
            if (transArmorEncryptedTrack2 != nil) { try container.encode(transArmorEncryptedTrack2, forKey: .transArmorEncryptedTrack2) }
            if (transArmorEncryptedEmvTag57 != nil) { try container.encode(transArmorEncryptedEmvTag57, forKey: .transArmorEncryptedEmvTag57) }
            if (transArmorEncryptedEmvTag5A != nil) { try container.encode(transArmorEncryptedEmvTag5A, forKey: .transArmorEncryptedEmvTag5A) }
            if (transArmorEncryptedManualKeyedData != nil) { try container.encode(transArmorEncryptedManualKeyedData, forKey: .transArmorEncryptedManualKeyedData) }
            if (iccContainer != nil) { try container.encode(iccContainer, forKey: .iccContainer) }
            if (iccApplicationInterchangeProfile != nil) { try container.encode(iccApplicationInterchangeProfile, forKey: .iccApplicationInterchangeProfile) }
            if (iccMaskedEmv57 != nil) { try container.encode(iccMaskedEmv57, forKey: .iccMaskedEmv57) }
            if (iccMaskedEmv5A != nil) { try container.encode(iccMaskedEmv5A, forKey: .iccMaskedEmv5A) }
            if (iccApplicationPanSequenceNumber != nil) { try container.encode(iccApplicationPanSequenceNumber, forKey: .iccApplicationPanSequenceNumber) }
            if (iccApplicationExpirationDate != nil) { try container.encode(iccApplicationExpirationDate, forKey: .iccApplicationExpirationDate) }
            if (iccApplicationEffectiveDate != nil) { try container.encode(iccApplicationEffectiveDate, forKey: .iccApplicationEffectiveDate) }
            if (iccAmountAuthorized != nil) { try container.encode(iccAmountAuthorized, forKey: .iccAmountAuthorized) }
            if (iccAmountOther != nil) { try container.encode(iccAmountOther, forKey: .iccAmountOther) }
            if (iccTransactionCurrencyCode != nil) { try container.encode(iccTransactionCurrencyCode, forKey: .iccTransactionCurrencyCode) }
            if (iccTransactionCurrencyExponent != nil) { try container.encode(iccTransactionCurrencyExponent, forKey: .iccTransactionCurrencyExponent) }
            if (iccApplicationUsageControl != nil) { try container.encode(iccApplicationUsageControl, forKey: .iccApplicationUsageControl) }
            if (iccIssuerActionCodeDefault != nil) { try container.encode(iccIssuerActionCodeDefault, forKey: .iccIssuerActionCodeDefault) }
            if (iccIssuerActionCodeDenial != nil) { try container.encode(iccIssuerActionCodeDenial, forKey: .iccIssuerActionCodeDenial) }
            if (iccIssuerActionCodeOnline != nil) { try container.encode(iccIssuerActionCodeOnline, forKey: .iccIssuerActionCodeOnline) }
            if (iccApplicationLabel != nil) { try container.encode(iccApplicationLabel, forKey: .iccApplicationLabel) }
            if (iccApplicationCryptogram != nil) { try container.encode(iccApplicationCryptogram, forKey: .iccApplicationCryptogram) }
            if (iccApplicationIdentifierCard != nil) { try container.encode(iccApplicationIdentifierCard, forKey: .iccApplicationIdentifierCard) }
            if (iccApplicationIdentifierTerminal != nil) { try container.encode(iccApplicationIdentifierTerminal, forKey: .iccApplicationIdentifierTerminal) }
            if (iccApplicationTransactionCounter != nil) { try container.encode(iccApplicationTransactionCounter, forKey: .iccApplicationTransactionCounter) }
            if (iccApplicationVersionNumber != nil) { try container.encode(iccApplicationVersionNumber, forKey: .iccApplicationVersionNumber) }
            if (iccCryptogramInformationData != nil) { try container.encode(iccCryptogramInformationData, forKey: .iccCryptogramInformationData) }
            if (iccCvmResults != nil) { try container.encode(iccCvmResults, forKey: .iccCvmResults) }
            if (iccInterfaceDeviceSerialNumber != nil) { try container.encode(iccInterfaceDeviceSerialNumber, forKey: .iccInterfaceDeviceSerialNumber) }
            if (iccIssuerApplicationData != nil) { try container.encode(iccIssuerApplicationData, forKey: .iccIssuerApplicationData) }
            if (iccPosEntryModeCode != nil) { try container.encode(iccPosEntryModeCode, forKey: .iccPosEntryModeCode) }
            if (iccTerminalCapabilities != nil) { try container.encode(iccTerminalCapabilities, forKey: .iccTerminalCapabilities) }
            if (iccTerminalCountryCode != nil) { try container.encode(iccTerminalCountryCode, forKey: .iccTerminalCountryCode) }
            if (iccTerminalType != nil) { try container.encode(iccTerminalType, forKey: .iccTerminalType) }
            if (iccTvr != nil) { try container.encode(iccTvr, forKey: .iccTvr) }
            if (iccTransactionDate != nil) { try container.encode(iccTransactionDate, forKey: .iccTransactionDate) }
            if (iccTsi != nil) { try container.encode(iccTsi, forKey: .iccTsi) }
            if (iccTransactionType != nil) { try container.encode(iccTransactionType, forKey: .iccTransactionType) }
            if (iccUnpredictableNumber != nil) { try container.encode(iccUnpredictableNumber, forKey: .iccUnpredictableNumber) }
            if (iccTransactionTime != nil) { try container.encode(iccTransactionTime, forKey: .iccTransactionTime) }
            if (iccAdditionalTerminalCapabilities != nil) { try container.encode(iccAdditionalTerminalCapabilities, forKey: .iccAdditionalTerminalCapabilities) }
            if (iccTransactionCategoryCode != nil) { try container.encode(iccTransactionCategoryCode, forKey: .iccTransactionCategoryCode) }
            if (iccIssuerApplicationPreferredName != nil) { try container.encode(iccIssuerApplicationPreferredName, forKey: .iccIssuerApplicationPreferredName) }
            if (iccCardholderName != nil) { try container.encode(iccCardholderName, forKey: .iccCardholderName) }
            if (iccIssuerCodeTableIndex != nil) { try container.encode(iccIssuerCodeTableIndex, forKey: .iccIssuerCodeTableIndex) }
            if (iccIssuerScripts != nil) { try container.encode(iccIssuerScripts, forKey: .iccIssuerScripts) }
            if (iccIssuerScriptResults != nil) { try container.encode(iccIssuerScriptResults, forKey: .iccIssuerScriptResults) }
            if (debugTrack2EquivalentData != nil) { try container.encode(debugTrack2EquivalentData, forKey: .debugTrack2EquivalentData) }
            if (debugApplicationPan != nil) { try container.encode(debugApplicationPan, forKey: .debugApplicationPan) }
            if (debugAmountAuthorizedBinary != nil) { try container.encode(debugAmountAuthorizedBinary, forKey: .debugAmountAuthorizedBinary) }
            if (debugAmountOtherBinary != nil) { try container.encode(debugAmountOtherBinary, forKey: .debugAmountOtherBinary) }
            if (debugTransactionStatusInformation != nil) { try container.encode(debugTransactionStatusInformation, forKey: .debugTransactionStatusInformation) }
            if (debugPlainTrack1 != nil) { try container.encode(debugPlainTrack1, forKey: .debugPlainTrack1) }
            if (debugPlainTrack2 != nil) { try container.encode(debugPlainTrack2, forKey: .debugPlainTrack2) }
            if (schemePunATC != nil) { try container.encode(schemePunATC, forKey: .schemePunATC) }
            if (schemeThirdPartyData != nil) { try container.encode(schemeThirdPartyData, forKey: .schemeThirdPartyData) }
            if (schemeMerchantCustomData != nil) { try container.encode(schemeMerchantCustomData, forKey: .schemeMerchantCustomData) }
            if (schemeTerminalEntryCapability != nil) { try container.encode(schemeTerminalEntryCapability, forKey: .schemeTerminalEntryCapability) }
            if (pinBlockContainer != nil) { try container.encode(pinBlockContainer, forKey: .pinBlockContainer) }
            if (pinBlock != nil) { try container.encode(pinBlock, forKey: .pinBlock) }
            if (pinBlockKsn != nil) { try container.encode(pinBlockKsn, forKey: .pinBlockKsn) }
            if (mac != nil) { try container.encode(mac, forKey: .mac) }
            if (macKsn != nil) { try container.encode(macKsn, forKey: .macKsn) }
            if (gwContainer != nil) { try container.encode(gwContainer, forKey: .gwContainer) }
            if (gwIssuerAuthenticationData != nil) { try container.encode(gwIssuerAuthenticationData, forKey: .gwIssuerAuthenticationData) }
            if (gwIssuerScriptTemplate1 != nil) { try container.encode(gwIssuerScriptTemplate1, forKey: .gwIssuerScriptTemplate1) }
            if (gwIssuerScriptTemplate2 != nil) { try container.encode(gwIssuerScriptTemplate2, forKey: .gwIssuerScriptTemplate2) }
            if (gwIssuerAuthorizationResponseCode != nil) { try container.encode(gwIssuerAuthorizationResponseCode, forKey: .gwIssuerAuthorizationResponseCode) }
            if (gwMessageControlField != nil) { try container.encode(gwMessageControlField, forKey: .gwMessageControlField) }
            if (gwTxResult != nil) { try container.encode(gwTxResult, forKey: .gwTxResult) }
            if (cvmResult != nil) { try container.encode(cvmResult, forKey: .cvmResult) }
            if (serviceCode1 != nil) { try container.encode(serviceCode1, forKey: .serviceCode1) }
            if (serviceCode2 != nil) { try container.encode(serviceCode2, forKey: .serviceCode2) }
            if (serviceCode3 != nil) { try container.encode(serviceCode3, forKey: .serviceCode3) }
            if (offlineApprovalAuthCode != nil) { try container.encode(offlineApprovalAuthCode, forKey: .offlineApprovalAuthCode) }
            if (availableOfflineSpendingAmount != nil) { try container.encode(availableOfflineSpendingAmount, forKey: .availableOfflineSpendingAmount) }
        }
    }

}