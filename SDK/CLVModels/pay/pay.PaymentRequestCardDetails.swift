/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Pay {

    public class PaymentRequestCardDetails: Codable {

        public var track1: String?
        public var track2: String?
        public var track3: String?
        public var encrypted: Bool?
        public var maskedTrack1: String?
        public var maskedTrack2: String?
        public var maskedTrack3: String?
        public var uniqueToken: String?
        public var pan: String?
        public var firstName: String?
        public var lastName: String?
        public var countryCode: String?
        public var exp: String?
        public var streetAddress: String?
        public var zip: String?
        public var cvv: String?
        public var last4: String?
        public var first4: String?
        public var dukptSerial: String?
        public var swipeStatus: String?
        public var fingerprint: String?
        public var deviceSerial: String?
        public var manualEntered: Bool?
        public var async: Bool?
        public var isFallback: Bool?
        public var isAuth: Bool?
        public var isPrepaid: Bool?
        public var cardFunction: CLVModels.Pay.CardFunction?
        public var qrCode: Bool?
        public var cardType: CLVModels.Payments.CardType?
        public var entryType: CLVModels.Payments.CardEntryType?
        public var transactionNo: String?
        public var cardholderName: String?
        public var plainCardData: String?
        public var transactionData: CLVModels.Pay.TransactionData?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case track1
            case track2
            case track3
            case encrypted
            case maskedTrack1
            case maskedTrack2
            case maskedTrack3
            case uniqueToken
            case pan
            case firstName
            case lastName
            case countryCode
            case exp
            case streetAddress
            case zip
            case cvv
            case last4
            case first4
            case dukptSerial
            case swipeStatus
            case fingerprint
            case deviceSerial
            case manualEntered
            case async
            case isFallback
            case isAuth
            case isPrepaid
            case cardFunction
            case qrCode
            case cardType
            case entryType
            case transactionNo
            case cardholderName
            case plainCardData
            case transactionData
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.track1 = try rootContainer.decodeIfPresent(String.self, forKey: .track1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.track2 = try rootContainer.decodeIfPresent(String.self, forKey: .track2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.track3 = try rootContainer.decodeIfPresent(String.self, forKey: .track3)
            } catch {
                decodeError.append(error)
            }
            do {
                self.encrypted = try rootContainer.decodeIfPresent(Bool.self, forKey: .encrypted)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedTrack1 = try rootContainer.decodeIfPresent(String.self, forKey: .maskedTrack1)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedTrack2 = try rootContainer.decodeIfPresent(String.self, forKey: .maskedTrack2)
            } catch {
                decodeError.append(error)
            }
            do {
                self.maskedTrack3 = try rootContainer.decodeIfPresent(String.self, forKey: .maskedTrack3)
            } catch {
                decodeError.append(error)
            }
            do {
                self.uniqueToken = try rootContainer.decodeIfPresent(String.self, forKey: .uniqueToken)
            } catch {
                decodeError.append(error)
            }
            do {
                self.pan = try rootContainer.decodeIfPresent(String.self, forKey: .pan)
            } catch {
                decodeError.append(error)
            }
            do {
                self.firstName = try rootContainer.decodeIfPresent(String.self, forKey: .firstName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.lastName = try rootContainer.decodeIfPresent(String.self, forKey: .lastName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.countryCode = try rootContainer.decodeIfPresent(String.self, forKey: .countryCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.exp = try rootContainer.decodeIfPresent(String.self, forKey: .exp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.streetAddress = try rootContainer.decodeIfPresent(String.self, forKey: .streetAddress)
            } catch {
                decodeError.append(error)
            }
            do {
                self.zip = try rootContainer.decodeIfPresent(String.self, forKey: .zip)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cvv = try rootContainer.decodeIfPresent(String.self, forKey: .cvv)
            } catch {
                decodeError.append(error)
            }
            do {
                self.last4 = try rootContainer.decodeIfPresent(String.self, forKey: .last4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.first4 = try rootContainer.decodeIfPresent(String.self, forKey: .first4)
            } catch {
                decodeError.append(error)
            }
            do {
                self.dukptSerial = try rootContainer.decodeIfPresent(String.self, forKey: .dukptSerial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.swipeStatus = try rootContainer.decodeIfPresent(String.self, forKey: .swipeStatus)
            } catch {
                decodeError.append(error)
            }
            do {
                self.fingerprint = try rootContainer.decodeIfPresent(String.self, forKey: .fingerprint)
            } catch {
                decodeError.append(error)
            }
            do {
                self.deviceSerial = try rootContainer.decodeIfPresent(String.self, forKey: .deviceSerial)
            } catch {
                decodeError.append(error)
            }
            do {
                self.manualEntered = try rootContainer.decodeIfPresent(Bool.self, forKey: .manualEntered)
            } catch {
                decodeError.append(error)
            }
            do {
                self.async = try rootContainer.decodeIfPresent(Bool.self, forKey: .async)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isFallback = try rootContainer.decodeIfPresent(Bool.self, forKey: .isFallback)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isAuth = try rootContainer.decodeIfPresent(Bool.self, forKey: .isAuth)
            } catch {
                decodeError.append(error)
            }
            do {
                self.isPrepaid = try rootContainer.decodeIfPresent(Bool.self, forKey: .isPrepaid)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardFunction = try rootContainer.decodeIfPresent(CLVModels.Pay.CardFunction.self, forKey: .cardFunction)
            } catch {
                decodeError.append(error)
            }
            do {
                self.qrCode = try rootContainer.decodeIfPresent(Bool.self, forKey: .qrCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardType.self, forKey: .cardType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.entryType = try rootContainer.decodeIfPresent(CLVModels.Payments.CardEntryType.self, forKey: .entryType)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionNo = try rootContainer.decodeIfPresent(String.self, forKey: .transactionNo)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cardholderName = try rootContainer.decodeIfPresent(String.self, forKey: .cardholderName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.plainCardData = try rootContainer.decodeIfPresent(String.self, forKey: .plainCardData)
            } catch {
                decodeError.append(error)
            }
            do {
                self.transactionData = try rootContainer.decodeIfPresent(CLVModels.Pay.TransactionData.self, forKey: .transactionData)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (track1 != nil) { try container.encode(track1, forKey: .track1) }
            if (track2 != nil) { try container.encode(track2, forKey: .track2) }
            if (track3 != nil) { try container.encode(track3, forKey: .track3) }
            if (encrypted != nil) { try container.encode(encrypted, forKey: .encrypted) }
            if (maskedTrack1 != nil) { try container.encode(maskedTrack1, forKey: .maskedTrack1) }
            if (maskedTrack2 != nil) { try container.encode(maskedTrack2, forKey: .maskedTrack2) }
            if (maskedTrack3 != nil) { try container.encode(maskedTrack3, forKey: .maskedTrack3) }
            if (uniqueToken != nil) { try container.encode(uniqueToken, forKey: .uniqueToken) }
            if (pan != nil) { try container.encode(pan, forKey: .pan) }
            if (firstName != nil) { try container.encode(firstName, forKey: .firstName) }
            if (lastName != nil) { try container.encode(lastName, forKey: .lastName) }
            if (countryCode != nil) { try container.encode(countryCode, forKey: .countryCode) }
            if (exp != nil) { try container.encode(exp, forKey: .exp) }
            if (streetAddress != nil) { try container.encode(streetAddress, forKey: .streetAddress) }
            if (zip != nil) { try container.encode(zip, forKey: .zip) }
            if (cvv != nil) { try container.encode(cvv, forKey: .cvv) }
            if (last4 != nil) { try container.encode(last4, forKey: .last4) }
            if (first4 != nil) { try container.encode(first4, forKey: .first4) }
            if (dukptSerial != nil) { try container.encode(dukptSerial, forKey: .dukptSerial) }
            if (swipeStatus != nil) { try container.encode(swipeStatus, forKey: .swipeStatus) }
            if (fingerprint != nil) { try container.encode(fingerprint, forKey: .fingerprint) }
            if (deviceSerial != nil) { try container.encode(deviceSerial, forKey: .deviceSerial) }
            if (manualEntered != nil) { try container.encode(manualEntered, forKey: .manualEntered) }
            if (async != nil) { try container.encode(async, forKey: .async) }
            if (isFallback != nil) { try container.encode(isFallback, forKey: .isFallback) }
            if (isAuth != nil) { try container.encode(isAuth, forKey: .isAuth) }
            if (isPrepaid != nil) { try container.encode(isPrepaid, forKey: .isPrepaid) }
            if (cardFunction != nil) { try container.encode(cardFunction, forKey: .cardFunction) }
            if (qrCode != nil) { try container.encode(qrCode, forKey: .qrCode) }
            if (cardType != nil) { try container.encode(cardType, forKey: .cardType) }
            if (entryType != nil) { try container.encode(entryType, forKey: .entryType) }
            if (transactionNo != nil) { try container.encode(transactionNo, forKey: .transactionNo) }
            if (cardholderName != nil) { try container.encode(cardholderName, forKey: .cardholderName) }
            if (plainCardData != nil) { try container.encode(plainCardData, forKey: .plainCardData) }
            if (transactionData != nil) { try container.encode(transactionData, forKey: .transactionData) }
        }
    }

}