/**
 * Autogenerated by Avro
 * 
 * DO NOT EDIT DIRECTLY
 */


import Foundation

extension CLVModels.Pay {

    public class PaymentRequest: Codable {

        /// Unique identifier
        public var id: String?
        /// Unique identifier of the order with which this payment is associated
        public var orderId: String?
        /// Request timestamp
        public var timestamp: Date?
        /// The tender type associated with this payment, e.g. credit card, cash, etc.
        public var tender: CLVModels.Base.Tender?
        /// Total amount paid
        public var amount: Int64?
        /// Amount paid in tips
        public var tipAmount: CLVModels.Variant?
        /// Amount paid in tax (TBD: sales tax only?)
        public var taxAmount: CLVModels.Variant?
        public var cashBackAmount: CLVModels.Variant?
        /// Cash tendered
        public var cashTendered: CLVModels.Variant?
        /// Employee ID
        public var employeeId: String?
        /// Employee name
        public var employeeName: String?
        /// Used for voice authorization for credit cards
        public var authorizationCode: String?
        /// External payment ID when using custom tender
        public var externalPaymentId: String?
        public var serviceChargeAmount: CLVModels.Payments.ServiceChargeAmount?
        public var taxableAmountRates: [CLVModels.Payments.TaxableAmountRate]?
        /// Payments that were made for this line item
        public var lineItems: [CLVModels.Payments.LineItemPayment]?
        public var card: CLVModels.Pay.PaymentRequestCardDetails?

        public var decodeError:[Swift.Error] = [Swift.Error]()

        enum CodingKeys: CodingKey {
            case id
            case orderId
            case timestamp
            case tender
            case amount
            case tipAmount
            case taxAmount
            case cashBackAmount
            case cashTendered
            case employeeId
            case employeeName
            case authorizationCode
            case externalPaymentId
            case serviceChargeAmount
            case taxableAmountRates
            case lineItems
            case card
        }

        public init() {}

        required public init(from decoder: Decoder) throws {
            let rootContainer = try decoder.container(keyedBy: CodingKeys.self)
            do {
                self.id = try rootContainer.decodeIfPresent(String.self, forKey: .id)
            } catch {
                decodeError.append(error)
            }
            do {
                self.orderId = try rootContainer.decodeIfPresent(String.self, forKey: .orderId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.timestamp = try rootContainer.decodeIfPresent(Date.self, forKey: .timestamp)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tender = try rootContainer.decodeIfPresent(CLVModels.Base.Tender.self, forKey: .tender)
            } catch {
                decodeError.append(error)
            }
            do {
                self.amount = try rootContainer.decodeIfPresent(Int64.self, forKey: .amount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.tipAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .tipAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.taxAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .taxAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashBackAmount = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cashBackAmount)
            } catch {
                decodeError.append(error)
            }
            do {
                self.cashTendered = try rootContainer.decodeIfPresent(CLVModels.Variant.self, forKey: .cashTendered)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employeeId = try rootContainer.decodeIfPresent(String.self, forKey: .employeeId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.employeeName = try rootContainer.decodeIfPresent(String.self, forKey: .employeeName)
            } catch {
                decodeError.append(error)
            }
            do {
                self.authorizationCode = try rootContainer.decodeIfPresent(String.self, forKey: .authorizationCode)
            } catch {
                decodeError.append(error)
            }
            do {
                self.externalPaymentId = try rootContainer.decodeIfPresent(String.self, forKey: .externalPaymentId)
            } catch {
                decodeError.append(error)
            }
            do {
                self.serviceChargeAmount = try rootContainer.decodeIfPresent(CLVModels.Payments.ServiceChargeAmount.self, forKey: .serviceChargeAmount)
            } catch {
                decodeError.append(error)
            }
            if (rootContainer.contains(.taxableAmountRates)) {
                do {
                    let taxableAmountRatesContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .taxableAmountRates)
                    self.taxableAmountRates = try taxableAmountRatesContainer.decodeIfPresent([CLVModels.Payments.TaxableAmountRate].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            if (rootContainer.contains(.lineItems)) {
                do {
                    let lineItemsContainer = try rootContainer.nestedContainer(keyedBy: CLVModels.ElementsKey.self, forKey: .lineItems)
                    self.lineItems = try lineItemsContainer.decodeIfPresent([CLVModels.Payments.LineItemPayment].self, forKey: .elements)
                } catch {
                    decodeError.append(error)
                }
            }
            do {
                self.card = try rootContainer.decodeIfPresent(CLVModels.Pay.PaymentRequestCardDetails.self, forKey: .card)
            } catch {
                decodeError.append(error)
            }
        }

        public func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            if (id != nil) { try container.encode(id, forKey: .id) }
            if (orderId != nil) { try container.encode(orderId, forKey: .orderId) }
            if (timestamp != nil) { try container.encode(timestamp, forKey: .timestamp) }
            if (tender != nil) { try container.encode(tender, forKey: .tender) }
            if (amount != nil) { try container.encode(amount, forKey: .amount) }
            if (tipAmount != nil) { try container.encode(tipAmount, forKey: .tipAmount) }
            if (taxAmount != nil) { try container.encode(taxAmount, forKey: .taxAmount) }
            if (cashBackAmount != nil) { try container.encode(cashBackAmount, forKey: .cashBackAmount) }
            if (cashTendered != nil) { try container.encode(cashTendered, forKey: .cashTendered) }
            if (employeeId != nil) { try container.encode(employeeId, forKey: .employeeId) }
            if (employeeName != nil) { try container.encode(employeeName, forKey: .employeeName) }
            if (authorizationCode != nil) { try container.encode(authorizationCode, forKey: .authorizationCode) }
            if (externalPaymentId != nil) { try container.encode(externalPaymentId, forKey: .externalPaymentId) }
            if (serviceChargeAmount != nil) { try container.encode(serviceChargeAmount, forKey: .serviceChargeAmount) }
            if (taxableAmountRates != nil) { try container.encode(taxableAmountRates, forKey: .taxableAmountRates) }
            if (lineItems != nil) { try container.encode(lineItems, forKey: .lineItems) }
            if (card != nil) { try container.encode(card, forKey: .card) }
        }
    }

}